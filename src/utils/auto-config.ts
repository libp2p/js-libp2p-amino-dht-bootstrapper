/* eslint-disable no-console */
/**
 * If a config option isn't used, and a user doesn't already have a config file,
 * we should automatically generate one by calling `ipfs init` or similar with
 * the Kubo npm package.
 */
import { writeFile, mkdir, access, constants } from 'node:fs/promises'
import { homedir } from 'node:os'
import { join, isAbsolute } from 'node:path'
import { generateKeyPair } from '@libp2p/crypto/keys'
import { peerIdFromPrivateKey } from '@libp2p/peer-id'
import { readConfig, type BootstrapConfig } from './load-config.js'
import { encodePrivateKey } from './peer-id.js'

export const DEFAULT_CONFIG_NAME = 'config.json'

export const CONFIG_FOLDER = join(homedir(), '.config', '@libp2p', 'amino-dht-bootstrapper')
export async function getConfigPath (): Promise<string> {
  return join(CONFIG_FOLDER, DEFAULT_CONFIG_NAME)
}

const defaultConfig: BootstrapConfig = {
  addresses: {
    announce: [],
    noAnnounce: [],
    listen: [
      '/ip4/0.0.0.0/tcp/4003/ws',
      '/ip4/0.0.0.0/tcp/4001',
      '/ip6/::/tcp/4004/ws',
      '/ip6/::/tcp/4001',
      '/ip4/0.0.0.0/udp/4002/webrtc'
    ]
  },
  bootstrap: {
    list: [
      '/dns4/am6.bootstrap.libp2p.io/tcp/443/wss/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb',
      '/dns4/sg1.bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt',
      '/dns4/sv15.bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN'
    ]
  },
  identity: {
    peerId: 'generated by `auto-config.ts`',
    privKey: 'generated by `auto-config.ts`'
  },
  connectionManager: {
    inboundConnectionThreshold: 100,
    maxIncomingPendingConnections: 100,
    maxConnections: 500
  }
}

/**
 * check if DEFAULT_CONFIG_NAME exists, if it does, use it automatically
 * if not, copy example-config.json to ~/.config.json
 * create a private key and peer ID and add it to the config
 */
export async function autoConfig (configPathArg?: string): Promise<BootstrapConfig> {
  if (configPathArg != null) {
    console.info('Attempting to use config file from %s', configPathArg)
    /**
     * If a config path is provided, attempt to use it.
     * If it's not an absolute path, assume it's relative to the current working directory.
     */
    const configFilepath = isAbsolute(configPathArg) ? configPathArg : join(process.cwd(), configPathArg)
    return readConfig(configFilepath)
  }

  const configPath = await getConfigPath()
  console.info('Checking for config file at %s', configPath)
  try {
    const config = readConfig(configPath)
    console.info('Config file found')
    return config
  } catch {
    // eslint-disable-next-line no-console
    console.info('No config file found, generating one automatically...')
  }

  // check for config folder existence, if it doesn't exist, create it.
  try {
    console.info('Checking for config folder at %s', CONFIG_FOLDER)
    await access(CONFIG_FOLDER, constants.R_OK | constants.W_OK)
  } catch (e) {
    console.info('Config folder not found, creating it...')
    await mkdir(CONFIG_FOLDER, { recursive: true })
  }

  try {
    console.info('Using default config object: %O', defaultConfig)
    const configJson = { ...defaultConfig }

    console.info('Generating private key and peer ID...')
    const libp2pGeneratedPrivateKey = await generateKeyPair('Ed25519')
    configJson.identity.privKey = encodePrivateKey(libp2pGeneratedPrivateKey)
    configJson.identity.peerId = peerIdFromPrivateKey(libp2pGeneratedPrivateKey).toString()

    console.info('Writing config file')
    await writeFile(configPath, JSON.stringify(configJson, null, 2))
    console.info('Config file created successfully at %s', configPath)
    return configJson
  } catch (e) {
    console.error('Error creating config', e)
    throw e
  }
}
