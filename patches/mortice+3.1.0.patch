diff --git a/node_modules/mortice/dist/index.min.js b/node_modules/mortice/dist/index.min.js
index 6328767..0184a06 100644
--- a/node_modules/mortice/dist/index.min.js
+++ b/node_modules/mortice/dist/index.min.js
@@ -1,4 +1,4 @@
 (function (root, factory) {(typeof module === 'object' && module.exports) ? module.exports = factory() : root.Mortice = factory()}(typeof self !== 'undefined' ? self : this, function () {
-"use strict";var Mortice=(()=>{var Z=Object.create;var T=Object.defineProperty;var j=Object.getOwnPropertyDescriptor;var ee=Object.getOwnPropertyNames;var te=Object.getPrototypeOf,re=Object.prototype.hasOwnProperty;var ne=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),ie=(r,e)=>{for(var t in e)T(r,t,{get:e[t],enumerable:!0})},$=(r,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of ee(e))!re.call(r,i)&&i!==t&&T(r,i,{get:()=>e[i],enumerable:!(n=j(e,i))||n.enumerable});return r};var se=(r,e,t)=>(t=r!=null?Z(te(r)):{},$(e||!r||!r.__esModule?T(t,"default",{value:r,enumerable:!0}):t,r)),ae=r=>$(T({},"__esModule",{value:!0}),r);var U=ne((Ee,O)=>{"use strict";var oe=Object.prototype.hasOwnProperty,m="~";function w(){}Object.create&&(w.prototype=Object.create(null),new w().__proto__||(m=!1));function ue(r,e,t){this.fn=r,this.context=e,this.once=t||!1}function B(r,e,t,n,i){if(typeof t!="function")throw new TypeError("The listener must be a function");var s=new ue(t,n||r,i),a=m?m+e:e;return r._events[a]?r._events[a].fn?r._events[a]=[r._events[a],s]:r._events[a].push(s):(r._events[a]=s,r._eventsCount++),r}function x(r,e){--r._eventsCount===0?r._events=new w:delete r._events[e]}function h(){this._events=new w,this._eventsCount=0}h.prototype.eventNames=function(){var e=[],t,n;if(this._eventsCount===0)return e;for(n in t=this._events)oe.call(t,n)&&e.push(m?n.slice(1):n);return Object.getOwnPropertySymbols?e.concat(Object.getOwnPropertySymbols(t)):e};h.prototype.listeners=function(e){var t=m?m+e:e,n=this._events[t];if(!n)return[];if(n.fn)return[n.fn];for(var i=0,s=n.length,a=new Array(s);i<s;i++)a[i]=n[i].fn;return a};h.prototype.listenerCount=function(e){var t=m?m+e:e,n=this._events[t];return n?n.fn?1:n.length:0};h.prototype.emit=function(e,t,n,i,s,a){var c=m?m+e:e;if(!this._events[c])return!1;var o=this._events[c],l=arguments.length,f,u;if(o.fn){switch(o.once&&this.removeListener(e,o.fn,void 0,!0),l){case 1:return o.fn.call(o.context),!0;case 2:return o.fn.call(o.context,t),!0;case 3:return o.fn.call(o.context,t,n),!0;case 4:return o.fn.call(o.context,t,n,i),!0;case 5:return o.fn.call(o.context,t,n,i,s),!0;case 6:return o.fn.call(o.context,t,n,i,s,a),!0}for(u=1,f=new Array(l-1);u<l;u++)f[u-1]=arguments[u];o.fn.apply(o.context,f)}else{var E=o.length,d;for(u=0;u<E;u++)switch(o[u].once&&this.removeListener(e,o[u].fn,void 0,!0),l){case 1:o[u].fn.call(o[u].context);break;case 2:o[u].fn.call(o[u].context,t);break;case 3:o[u].fn.call(o[u].context,t,n);break;case 4:o[u].fn.call(o[u].context,t,n,i);break;default:if(!f)for(d=1,f=new Array(l-1);d<l;d++)f[d-1]=arguments[d];o[u].fn.apply(o[u].context,f)}}return!0};h.prototype.on=function(e,t,n){return B(this,e,t,n,!1)};h.prototype.once=function(e,t,n){return B(this,e,t,n,!0)};h.prototype.removeListener=function(e,t,n,i){var s=m?m+e:e;if(!this._events[s])return this;if(!t)return x(this,s),this;var a=this._events[s];if(a.fn)a.fn===t&&(!i||a.once)&&(!n||a.context===n)&&x(this,s);else{for(var c=0,o=[],l=a.length;c<l;c++)(a[c].fn!==t||i&&!a[c].once||n&&a[c].context!==n)&&o.push(a[c]);o.length?this._events[s]=o.length===1?o[0]:o:x(this,s)}return this};h.prototype.removeAllListeners=function(e){var t;return e?(t=m?m+e:e,this._events[t]&&x(this,t)):(this._events=new w,this._eventsCount=0),this};h.prototype.off=h.prototype.removeListener;h.prototype.addListener=h.prototype.on;h.prefixed=m;h.EventEmitter=h;typeof O<"u"&&(O.exports=h)});var de={};ie(de,{default:()=>X});var g=class extends Error{static name="AbortError";name="AbortError";constructor(e="The operation was aborted",...t){super(e,...t)}};var I=se(U(),1);var L=class extends Error{constructor(e){super(e),this.name="TimeoutError"}},A=class extends Error{constructor(e){super(),this.name="AbortError",this.message=e}},F=r=>globalThis.DOMException===void 0?new A(r):new DOMException(r),G=r=>{let e=r.reason===void 0?F("This operation was aborted."):r.reason;return e instanceof Error?e:F(e)};function C(r,e){let{milliseconds:t,fallback:n,message:i,customTimers:s={setTimeout,clearTimeout}}=e,a,c,l=new Promise((f,u)=>{if(typeof t!="number"||Math.sign(t)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${t}\``);if(e.signal){let{signal:d}=e;d.aborted&&u(G(d)),c=()=>{u(G(d))},d.addEventListener("abort",c,{once:!0})}if(t===Number.POSITIVE_INFINITY){r.then(f,u);return}let E=new L;a=s.setTimeout.call(void 0,()=>{if(n){try{f(n())}catch(d){u(d)}return}typeof r.cancel=="function"&&r.cancel(),i===!1?f():i instanceof Error?u(i):(E.message=i??`Promise timed out after ${t} milliseconds`,u(E))},t),(async()=>{try{f(await r)}catch(d){u(d)}})()}).finally(()=>{l.clear(),c&&e.signal&&e.signal.removeEventListener("abort",c)});return l.clear=()=>{s.clearTimeout.call(void 0,a),a=void 0},l}function k(r,e,t){let n=0,i=r.length;for(;i>0;){let s=Math.trunc(i/2),a=n+s;t(r[a],e)<=0?(n=++a,i-=s+1):i=s}return n}var b=class{#e=[];enqueue(e,t){t={priority:0,...t};let n={priority:t.priority,id:t.id,run:e};if(this.size===0||this.#e[this.size-1].priority>=t.priority){this.#e.push(n);return}let i=k(this.#e,n,(s,a)=>a.priority-s.priority);this.#e.splice(i,0,n)}setPriority(e,t){let n=this.#e.findIndex(s=>s.id===e);if(n===-1)throw new ReferenceError(`No promise function with the id "${e}" exists in the queue.`);let[i]=this.#e.splice(n,1);this.enqueue(i.run,{priority:t,id:e})}dequeue(){return this.#e.shift()?.run}filter(e){return this.#e.filter(t=>t.priority===e.priority).map(t=>t.run)}get size(){return this.#e.length}};var _=class extends I.default{#e;#a;#s=0;#h;#o;#m=0;#r;#u;#t;#E;#n=0;#l;#i;#p;#g=1n;timeout;constructor(e){if(super(),e={carryoverConcurrencyCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:b,...e},!(typeof e.intervalCap=="number"&&e.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${e.intervalCap?.toString()??""}\` (${typeof e.intervalCap})`);if(e.interval===void 0||!(Number.isFinite(e.interval)&&e.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${e.interval?.toString()??""}\` (${typeof e.interval})`);this.#e=e.carryoverConcurrencyCount,this.#a=e.intervalCap===Number.POSITIVE_INFINITY||e.interval===0,this.#h=e.intervalCap,this.#o=e.interval,this.#t=new e.queueClass,this.#E=e.queueClass,this.concurrency=e.concurrency,this.timeout=e.timeout,this.#p=e.throwOnTimeout===!0,this.#i=e.autoStart===!1}get#_(){return this.#a||this.#s<this.#h}get#R(){return this.#n<this.#l}#w(){this.#n--,this.#c(),this.emit("next")}#L(){this.#y(),this.#v(),this.#u=void 0}get#b(){let e=Date.now();if(this.#r===void 0){let t=this.#m-e;if(t<0)this.#s=this.#e?this.#n:0;else return this.#u===void 0&&(this.#u=setTimeout(()=>{this.#L()},t)),!0}return!1}#c(){if(this.#t.size===0)return this.#r&&clearInterval(this.#r),this.#r=void 0,this.emit("empty"),this.#n===0&&this.emit("idle"),!1;if(!this.#i){let e=!this.#b;if(this.#_&&this.#R){let t=this.#t.dequeue();return t?(this.emit("active"),t(),e&&this.#v(),!0):!1}}return!1}#v(){this.#a||this.#r!==void 0||(this.#r=setInterval(()=>{this.#y()},this.#o),this.#m=Date.now()+this.#o)}#y(){this.#s===0&&this.#n===0&&this.#r&&(clearInterval(this.#r),this.#r=void 0),this.#s=this.#e?this.#n:0,this.#f()}#f(){for(;this.#c(););}get concurrency(){return this.#l}set concurrency(e){if(!(typeof e=="number"&&e>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);this.#l=e,this.#f()}async#T(e){return new Promise((t,n)=>{e.addEventListener("abort",()=>{n(e.reason)},{once:!0})})}setPriority(e,t){this.#t.setPriority(e,t)}async add(e,t={}){return t.id??=(this.#g++).toString(),t={timeout:this.timeout,throwOnTimeout:this.#p,...t},new Promise((n,i)=>{this.#t.enqueue(async()=>{this.#n++,this.#s++;try{t.signal?.throwIfAborted();let s=e({signal:t.signal});t.timeout&&(s=C(Promise.resolve(s),{milliseconds:t.timeout})),t.signal&&(s=Promise.race([s,this.#T(t.signal)]));let a=await s;n(a),this.emit("completed",a)}catch(s){if(s instanceof L&&!t.throwOnTimeout){n();return}i(s),this.emit("error",s)}finally{this.#w()}},t),this.emit("add"),this.#c()})}async addAll(e,t){return Promise.all(e.map(async n=>this.add(n,t)))}start(){return this.#i?(this.#i=!1,this.#f(),this):this}pause(){this.#i=!0}clear(){this.#t=new this.#E}async onEmpty(){this.#t.size!==0&&await this.#d("empty")}async onSizeLessThan(e){this.#t.size<e||await this.#d("next",()=>this.#t.size<e)}async onIdle(){this.#n===0&&this.#t.size===0||await this.#d("idle")}async#d(e,t){return new Promise(n=>{let i=()=>{t&&!t()||(this.off(e,i),n())};this.on(e,i)})}get size(){return this.#t.size}sizeBy(e){return this.#t.filter(e).length}get pending(){return this.#n}get isPaused(){return this.#i}};var v={},R=r=>{r.addEventListener("message",e=>{R.dispatchEvent("message",r,e)}),r.port!=null&&r.port.addEventListener("message",e=>{R.dispatchEvent("message",r,e)})};R.addEventListener=(r,e)=>{v[r]==null&&(v[r]=[]),v[r].push(e)};R.removeEventListener=(r,e)=>{v[r]!=null&&(v[r]=v[r].filter(t=>t===e))};R.dispatchEvent=function(r,e,t){v[r]!=null&&v[r].forEach(n=>n(e,t))};var P=R;var S="lock:worker:request-read",W="lock:worker:abort-read-request",q="lock:worker:release-read",K="lock:master:grant-read",N="lock:worker:request-write",M="lock:worker:abort-write-request",z="lock:worker:release-write",D="lock:master:grant-write";var V=(r=10)=>Math.random().toString().substring(2,r+2);var Y=(r,e,t,n,i,s,a)=>(c,o)=>{if(o.data==null)return;let l={type:o.data.type,name:o.data.name,identifier:o.data.identifier};o.data.type===n&&r.dispatchEvent(new MessageEvent(e,{data:{name:l.name,handler:async()=>{c.postMessage({type:a,name:l.name,identifier:l.identifier}),await new Promise(f=>{let u=E=>{if(E?.data==null)return;let d={type:E.data.type,name:E.data.name,identifier:E.data.identifier};d.type===s&&d.identifier===l.identifier&&(c.removeEventListener("message",u),f())};c.addEventListener("message",u)})}}})),l.type===i&&(c.postMessage({type:i,name:l.name,identifier:l.identifier}),r.dispatchEvent(new MessageEvent(t,{data:{name:l.name}})))},H=(r,e,t,n,i)=>async s=>{s?.signal?.throwIfAborted();let a=V();return globalThis.postMessage({type:e,identifier:a,name:r}),new Promise((c,o)=>{let l=()=>{process.send?.({type:t,identifier:a,name:r}),o(new g)};s?.signal?.addEventListener("abort",l,{once:!0});let f=u=>{if(u?.data==null)return;let E={type:u.data.type,identifier:u.data.identifier};E.type===n&&E.identifier===a&&(globalThis.removeEventListener("message",f),s?.signal?.removeEventListener("abort",l),c(()=>{globalThis.postMessage({type:i,identifier:a,name:r})}))};globalThis.addEventListener("message",f)})},le={singleProcess:!1},J=r=>{if(r=Object.assign({},le,r),!!globalThis.document||r.singleProcess){let t=new EventTarget;return P.addEventListener("message",Y(t,"requestReadLock","abortReadLockRequest",S,W,q,K)),P.addEventListener("message",Y(t,"requestWriteLock","abortWriteLockRequest",N,M,z,D)),t}return{isWorker:!0,readLock:t=>H(t,S,W,K,q),writeLock:t=>H(t,N,M,D,z)}};var y={},p;async function Q(r,e){let t,n,i=new Promise((a,c)=>{t=a,n=c}),s=()=>{n(new g)};return e?.signal?.addEventListener("abort",s,{once:!0}),r.add(async()=>{await new Promise(a=>{t(()=>{e?.signal?.removeEventListener("abort",s),a()})})},{signal:e?.signal}).catch(a=>{n(a)}),i}var ce=(r,e)=>{if(p.isWorker===!0)return{readLock:p.readLock(r,e),writeLock:p.writeLock(r,e)};let t=new _({concurrency:1}),n;return{async readLock(i){if(n!=null)return Q(n,i);n=new _({concurrency:e.concurrency,autoStart:!1});let s=n,a=Q(n,i);return t.add(async()=>{s.start(),await s.onIdle().then(()=>{n===s&&(n=null)})}),a},async writeLock(i){return n=null,Q(t,i)}}},fe={name:"lock",concurrency:1/0,singleProcess:!1};function X(r){let e=Object.assign({},fe,r);return p==null&&(p=J(e),p.isWorker!==!0&&(p.addEventListener("requestReadLock",t=>{let n=t.data.name;if(y[n]==null)return;let i=new AbortController,s=a=>{a.data.name===n&&i.abort()};p.addEventListener("abortReadLockRequest",s),y[n].readLock({signal:i.signal}).then(async a=>t.data.handler().finally(()=>{a()})).finally(()=>{p.removeEventListener("abortReadLockRequest",s)})}),p.addEventListener("requestWriteLock",async t=>{let n=t.data.name;if(y[n]==null)return;let i=new AbortController,s=a=>{a.data.name===n&&i.abort()};p.addEventListener("abortWriteLockRequest",s),y[t.data.name].writeLock({signal:i.signal}).then(async a=>t.data.handler().finally(()=>{a()})).finally(()=>{p.removeEventListener("abortWriteLockRequest",s)})}))),y[e.name]==null&&(y[e.name]=ce(e.name,e)),y[e.name]}return ae(de);})();
+"use strict";var Mortice=(()=>{var K=Object.defineProperty;var ne=Object.getOwnPropertyDescriptor;var se=Object.getOwnPropertyNames;var ie=Object.prototype.hasOwnProperty;var oe=(n,e)=>{for(var t in e)K(n,t,{get:e[t],enumerable:!0})},ae=(n,e,t,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of se(e))!ie.call(n,s)&&s!==t&&K(n,s,{get:()=>e[s],enumerable:!(r=ne(e,s))||r.enumerable});return n};var ue=n=>ae(K({},"__esModule",{value:!0}),n);var Ee={};oe(Ee,{default:()=>ee});var f=class extends Error{static name="AbortError";name="AbortError";constructor(e="The operation was aborted",...t){super(e,...t)}};function A(){let n={};return n.promise=new Promise((e,t)=>{n.resolve=e,n.reject=t}),n}var T=class{buffer;mask;top;btm;next;constructor(e){if(!(e>0)||(e-1&e)!==0)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){let e=this.buffer[this.btm];if(e!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return this.buffer[this.btm]===void 0}},y=class{size;hwm;head;tail;constructor(e={}){this.hwm=e.splitLimit??16,this.head=new T(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return e?.byteLength!=null?e.byteLength:1}push(e){if(e?.value!=null&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){let t=this.head;this.head=t.next=new T(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(e===void 0&&this.tail.next!=null){let t=this.tail.next;this.tail.next=null,this.tail=t,e=this.tail.shift()}return e?.value!=null&&(this.size-=this.calculateSize(e.value)),e}isEmpty(){return this.head.isEmpty()}};var C=class extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.code=t??"ABORT_ERR"}};function Y(n={}){return le(t=>{let r=t.shift();if(r==null)return{done:!0};if(r.error!=null)throw r.error;return{done:r.done===!0,value:r.value}},n)}function le(n,e){e=e??{};let t=e.onEnd,r=new y,s,i,o,u=A(),l=async()=>{try{return r.isEmpty()?o?{done:!0}:await new Promise((a,g)=>{i=_=>{i=null,r.push(_);try{a(n(r))}catch(v){g(v)}return s}}):n(r)}finally{r.isEmpty()&&queueMicrotask(()=>{u.resolve(),u=A()})}},c=a=>i!=null?i(a):(r.push(a),s),E=a=>(r=new y,i!=null?i({error:a}):(r.push({error:a}),s)),d=a=>{if(o)return s;if(e?.objectMode!==!0&&a?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return c({done:!1,value:a})},h=a=>o?s:(o=!0,a!=null?E(a):c({done:!0})),x=()=>(r=new y,h(),{done:!0}),te=a=>(h(a),{done:!0});if(s={[Symbol.asyncIterator](){return this},next:l,return:x,throw:te,push:d,end:h,get readableLength(){return r.size},onEmpty:async a=>{let g=a?.signal;if(g?.throwIfAborted(),r.isEmpty())return;let _,v;g!=null&&(_=new Promise((pe,re)=>{v=()=>{re(new C)},g.addEventListener("abort",v)}));try{await Promise.race([u.promise,_])}finally{v!=null&&g!=null&&g?.removeEventListener("abort",v)}}},t==null)return s;let L=s;return s={[Symbol.asyncIterator](){return this},next(){return L.next()},throw(a){return L.throw(a),t!=null&&(t(a),t=void 0),{done:!0}},return(){return L.return(),t!=null&&(t(),t=void 0),{done:!0}},push:d,end(a){return L.end(a),t!=null&&(t(a),t=void 0),s},get readableLength(){return L.readableLength},onEmpty:a=>L.onEmpty(a)},s}var S=class extends EventTarget{#e=new Map;constructor(){super()}listenerCount(e){let t=this.#e.get(e);return t==null?0:t.length}addEventListener(e,t,r){super.addEventListener(e,t,r);let s=this.#e.get(e);s==null&&(s=[],this.#e.set(e,s)),s.push({callback:t,once:(r!==!0&&r!==!1&&r?.once)??!1})}removeEventListener(e,t,r){super.removeEventListener(e.toString(),t??null,r);let s=this.#e.get(e);s!=null&&(s=s.filter(({callback:i})=>i!==t),this.#e.set(e,s))}dispatchEvent(e){let t=super.dispatchEvent(e),r=this.#e.get(e.type);return r==null||(r=r.filter(({once:s})=>!s),this.#e.set(e.type,r)),t}safeDispatchEvent(e,t={}){return this.dispatchEvent(new CustomEvent(e,t))}};var M=class extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.name="AbortError",this.code=t??"ABORT_ERR"}};async function k(n,e,t,r){let s=new M(r?.errorMessage,r?.errorCode);return t?.aborted===!0?Promise.reject(s):new Promise((i,o)=>{function u(){t?.removeEventListener("abort",E),n.removeEventListener(e,l),r?.errorEvent!=null&&n.removeEventListener(r.errorEvent,c)}let l=d=>{try{if(r?.filter?.(d)===!1)return}catch(h){u(),o(h);return}u(),i(d)},c=d=>{u(),o(d.detail)},E=()=>{u(),o(s)};t?.addEventListener("abort",E),n.addEventListener(e,l),r?.errorEvent!=null&&n.addEventListener(r.errorEvent,c)})}var q=class extends Error{static name="QueueFullError";constructor(e="The queue was full"){super(e),this.name="QueueFullError"}};var O=class extends Error{type;code;constructor(e,t,r){super(e??"The operation was aborted"),this.type="aborted",this.name=r??"AbortError",this.code=t??"ABORT_ERR"}};async function $(n,e,t){if(e==null)return n;if(e.aborted)return n.catch(()=>{}),Promise.reject(new O(t?.errorMessage,t?.errorCode,t?.errorName));let r,s=new O(t?.errorMessage,t?.errorCode,t?.errorName);try{return await Promise.race([n,new Promise((i,o)=>{r=()=>{o(s)},e.addEventListener("abort",r)})])}finally{r!=null&&e.removeEventListener("abort",r)}}var I=class{deferred;signal;constructor(e){this.signal=e,this.deferred=Promise.withResolvers(),this.onAbort=this.onAbort.bind(this),this.signal?.addEventListener("abort",this.onAbort)}onAbort(){this.deferred.reject(this.signal?.reason??new f)}cleanup(){this.signal?.removeEventListener("abort",this.onAbort)}};function de(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}var W=class{id;fn;options;recipients;status;timeline;controller;constructor(e,t){this.id=de(),this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((t,r)=>t&&r.signal?.aborted===!0,!0)&&(this.controller.abort(new f),this.cleanup())}async join(e={}){let t=new I(e.signal);return this.recipients.push(t),e.signal?.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();let e=await $(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{e.cleanup(),e.signal?.removeEventListener("abort",this.onAbort)})}};function z(n,e){let t,r=function(){let s=function(){t=void 0,n()};clearTimeout(t),t=setTimeout(s,e)};return r.start=()=>{},r.stop=()=>{clearTimeout(t)},r}var w=class extends S{concurrency;maxSize;queue;pending;sort;autoStart;constructor(e={}){super(),this.concurrency=e.concurrency??Number.POSITIVE_INFINITY,this.maxSize=e.maxSize??Number.POSITIVE_INFINITY,this.pending=0,this.autoStart=e.autoStart??!0,this.sort=e.sort,this.queue=[],this.emitEmpty=z(this.emitEmpty.bind(this),1),this.emitIdle=z(this.emitIdle.bind(this),1)}[Symbol.asyncIterator](){return this.toGenerator()}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let e;for(let t of this.queue)if(t.status==="queued"){e=t;break}return e==null?!1:(this.safeDispatchEvent("active"),this.pending++,e.run().finally(()=>{for(let t=0;t<this.queue.length;t++)if(this.queue[t]===e){this.queue.splice(t,1);break}this.pending--,this.tryToStartAnother(),this.safeDispatchEvent("next")}),!0)}return!1}enqueue(e){this.queue.push(e),this.sort!=null&&this.queue.sort(this.sort)}start(){this.autoStart===!1&&(this.autoStart=!0,this.tryToStartAnother())}async add(e,t){if(t?.signal?.throwIfAborted(),this.size===this.maxSize)throw new q;let r=new W(e,t);return this.enqueue(r),this.safeDispatchEvent("add"),this.autoStart&&this.tryToStartAnother(),r.join(t).then(s=>(this.safeDispatchEvent("success",{detail:{job:r,result:s}}),s)).catch(s=>{if(r.status==="queued"){for(let i=0;i<this.queue.length;i++)if(this.queue[i]===r){this.queue.splice(i,1);break}}throw this.safeDispatchEvent("failure",{detail:{job:r,error:s}}),s})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(e=>{e.abort(new f)}),this.clear()}async onEmpty(e){this.size!==0&&await k(this,"empty",e?.signal)}async onSizeLessThan(e,t){this.size<e||await k(this,"next",t?.signal,{filter:()=>this.size<e})}async onIdle(e){this.pending===0&&this.size===0||await k(this,"idle",e?.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){e?.signal?.throwIfAborted();let t=Y({objectMode:!0}),r=l=>{l!=null?this.abort():this.clear(),t.end(l)},s=l=>{l.detail!=null&&t.push(l.detail.result)},i=l=>{r(l.detail.error)},o=()=>{r()},u=()=>{r(new f("Queue aborted"))};this.addEventListener("success",s),this.addEventListener("failure",i),this.addEventListener("idle",o),e?.signal?.addEventListener("abort",u);try{yield*t}finally{this.removeEventListener("success",s),this.removeEventListener("failure",i),this.removeEventListener("idle",o),e?.signal?.removeEventListener("abort",u),r()}}};var p={},R=n=>{n.addEventListener("message",e=>{R.dispatchEvent("message",n,e)}),n.port!=null&&n.port.addEventListener("message",e=>{R.dispatchEvent("message",n,e)})};R.addEventListener=(n,e)=>{p[n]==null&&(p[n]=[]),p[n].push(e)};R.removeEventListener=(n,e)=>{p[n]!=null&&(p[n]=p[n].filter(t=>t===e))};R.dispatchEvent=function(n,e,t){p[n]!=null&&p[n].forEach(r=>r(e,t))};var P=R;var D="lock:worker:request-read",N="lock:worker:abort-read-request",Q="lock:worker:release-read",j="lock:master:grant-read",U="lock:worker:request-write",B="lock:worker:abort-write-request",G="lock:worker:release-write",F="lock:master:grant-write";var J=(n=10)=>Math.random().toString().substring(2,n+2);var H=(n,e,t,r,s,i,o)=>(u,l)=>{if(l.data==null)return;let c={type:l.data.type,name:l.data.name,identifier:l.data.identifier};l.data.type===r&&n.dispatchEvent(new MessageEvent(e,{data:{name:c.name,handler:async()=>{u.postMessage({type:o,name:c.name,identifier:c.identifier}),await new Promise(E=>{let d=h=>{if(h?.data==null)return;let x={type:h.data.type,name:h.data.name,identifier:h.data.identifier};x.type===i&&x.identifier===c.identifier&&(u.removeEventListener("message",d),E())};u.addEventListener("message",d)})}}})),c.type===s&&(u.postMessage({type:s,name:c.name,identifier:c.identifier}),n.dispatchEvent(new MessageEvent(t,{data:{name:c.name}})))},X=(n,e,t,r,s)=>async i=>{i?.signal?.throwIfAborted();let o=J();return globalThis.postMessage({type:e,identifier:o,name:n}),new Promise((u,l)=>{let c=()=>{process.send?.({type:t,identifier:o,name:n}),l(new f)};i?.signal?.addEventListener("abort",c,{once:!0});let E=d=>{if(d?.data==null)return;let h={type:d.data.type,identifier:d.data.identifier};h.type===r&&h.identifier===o&&(globalThis.removeEventListener("message",E),i?.signal?.removeEventListener("abort",c),u(()=>{globalThis.postMessage({type:s,identifier:o,name:n})}))};globalThis.addEventListener("message",E)})},he={singleProcess:!1},Z=n=>{if(n=Object.assign({},he,n),!!globalThis.document||n.singleProcess){let t=new EventTarget;return P.addEventListener("message",H(t,"requestReadLock","abortReadLockRequest",D,N,Q,j)),P.addEventListener("message",H(t,"requestWriteLock","abortWriteLockRequest",U,B,G,F)),t}return{isWorker:!0,readLock:t=>X(t,D,N,j,Q),writeLock:t=>X(t,U,B,F,G)}};var b={},m;async function V(n,e){let t,r,s=new Promise((o,u)=>{t=o,r=u}),i=()=>{r(new f)};return e?.signal?.addEventListener("abort",i,{once:!0}),n.add(async()=>{await new Promise(o=>{t(()=>{e?.signal?.removeEventListener("abort",i),o()})})},{signal:e?.signal}).catch(o=>{r(o)}),s}var fe=(n,e)=>{if(m.isWorker===!0)return{readLock:m.readLock(n,e),writeLock:m.writeLock(n,e),cleanUp:()=>{}};let t=new w({concurrency:1}),r;return{async readLock(s){if(r!=null)return V(r,s);r=new w({concurrency:e.concurrency,autoStart:!1});let i=r,o=V(r,s);return t.add(async()=>{i.start(),await i.onIdle().then(()=>{r===i&&(r=null)})}),o},async writeLock(s){return r=null,V(t,s)},cleanUp:()=>{delete b[n]},queue:t}},me={name:"lock",concurrency:1/0,singleProcess:!1};function ee(n){let e=Object.assign({},me,n);return m==null&&(m=Z(e),m.isWorker!==!0&&(m.addEventListener("requestReadLock",t=>{let r=t.data.name;if(b[r]==null)return;let s=new AbortController,i=o=>{o.data.name===r&&s.abort()};m.addEventListener("abortReadLockRequest",i),b[r].readLock({signal:s.signal}).then(async o=>t.data.handler().finally(()=>{o()})).finally(()=>{m.removeEventListener("abortReadLockRequest",i)})}),m.addEventListener("requestWriteLock",async t=>{let r=t.data.name;if(b[r]==null)return;let s=new AbortController,i=o=>{o.data.name===r&&s.abort()};m.addEventListener("abortWriteLockRequest",i),b[t.data.name].writeLock({signal:s.signal}).then(async o=>t.data.handler().finally(()=>{o()})).finally(()=>{m.removeEventListener("abortWriteLockRequest",i)})}))),b[e.name]==null&&(b[e.name]=fe(e.name,e)),b[e.name]}return ue(Ee);})();
 return Mortice}));
 //# sourceMappingURL=index.min.js.map
diff --git a/node_modules/mortice/dist/index.min.js.map b/node_modules/mortice/dist/index.min.js.map
index b55ab45..4fa878b 100644
--- a/node_modules/mortice/dist/index.min.js.map
+++ b/node_modules/mortice/dist/index.min.js.map
@@ -1,7 +1,7 @@
 {
   "version": 3,
-  "sources": ["../node_modules/eventemitter3/index.js", "../src/index.ts", "../node_modules/abort-error/src/index.ts", "../node_modules/eventemitter3/index.mjs", "../node_modules/p-timeout/index.js", "../node_modules/p-queue/dist/lower-bound.js", "../node_modules/p-queue/dist/priority-queue.js", "../node_modules/p-queue/dist/index.js", "../node_modules/observable-webworkers/src/index.ts", "../src/constants.ts", "../src/utils.ts", "../src/browser.ts"],
-  "sourcesContent": ["'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n", "/**\n * @packageDocumentation\n *\n * - Reads occur concurrently\n * - Writes occur one at a time\n * - No reads occur while a write operation is in progress\n * - Locks can be created with different names\n * - Reads/writes can time out\n *\n * @example\n *\n * ```javascript\n * import mortice from 'mortice'\n * import delay from 'delay'\n *\n * // the lock name & options objects are both optional\n * const mutex = mortice()\n *\n * Promise.all([\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 1')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 2')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.writeLock()\n *\n *     try {\n *       await delay(1000)\n *\n *       console.info('write 1')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 3')\n *     } finally {\n *       release()\n *     }\n *   })()\n * ])\n * ```\n *\n *     read 1\n *     read 2\n *     <small pause>\n *     write 1\n *     read 3\n *\n * ## Browser\n *\n * Because there's no global way to eavesdrop on messages sent by Web Workers,\n * please pass all created Web Workers to the [`observable-webworkers`](https://npmjs.org/package/observable-webworkers)\n * module:\n *\n * ```javascript\n * // main.js\n * import mortice from 'mortice'\n * import observe from 'observable-webworkers'\n *\n * // create our lock on the main thread, it will be held here\n * const mutex = mortice()\n *\n * const worker = new Worker('worker.js')\n *\n * observe(worker)\n * ```\n *\n * ```javascript\n * // worker.js\n * import mortice from 'mortice'\n * import delay from 'delay'\n *\n * const mutex = mortice()\n *\n * let release = await mutex.readLock()\n * // read something\n * release()\n *\n * release = await mutex.writeLock()\n * // write something\n * release()\n * ```\n */\n\nimport { AbortError } from 'abort-error'\nimport PQueue from 'p-queue'\nimport impl from './node.js'\nimport type { AbortOptions } from 'abort-error'\n\nexport interface MorticeOptions {\n  /**\n   * An optional name for the lock\n   */\n  name?: string\n\n  /**\n   * How many read operations are executed concurrently\n   *\n   * @default Infinity\n   */\n  concurrency?: number\n\n  /**\n   * By default the the lock will be held on the main thread and child/worker\n   * processes will coordinate to share the lock.\n   *\n   * Set this to true if each main/child/worker thread should maintain it's own\n   * lock with no coordination between them.\n   *\n   * @default false\n   */\n  singleProcess?: boolean\n}\n\nexport interface Mortice {\n  readLock(options?: AbortOptions): Promise<Release>\n  writeLock(options?: AbortOptions): Promise<Release>\n}\n\nexport interface Release {\n  (): void\n}\n\nconst mutexes: Record<string, Mortice> = {}\nlet implementation: any\n\nasync function createReleaseable (queue: PQueue, options?: AbortOptions): Promise<Release> {\n  let res: (release: Release) => void\n  let rej: (err: Error) => void\n\n  const p = new Promise<Release>((resolve, reject) => {\n    res = resolve\n    rej = reject\n  })\n\n  const listener = (): void => {\n    rej(new AbortError())\n  }\n\n  options?.signal?.addEventListener('abort', listener, {\n    once: true\n  })\n\n  queue.add(async () => {\n    await new Promise<void>((resolve) => {\n      res(() => {\n        options?.signal?.removeEventListener('abort', listener)\n        resolve()\n      })\n    })\n  }, {\n    signal: options?.signal\n  })\n    .catch((err) => {\n      rej(err)\n    })\n\n  return p\n}\n\nconst createMutex = (name: string, options: Required<MorticeOptions>): Mortice => {\n  if (implementation.isWorker === true) {\n    return {\n      readLock: implementation.readLock(name, options),\n      writeLock: implementation.writeLock(name, options)\n    }\n  }\n\n  const masterQueue = new PQueue({ concurrency: 1 })\n  let readQueue: PQueue | null\n\n  return {\n    async readLock (opts?: AbortOptions) {\n      // If there's already a read queue, just add the task to it\n      if (readQueue != null) {\n        return createReleaseable(readQueue, opts)\n      }\n\n      // Create a new read queue\n      readQueue = new PQueue({\n        concurrency: options.concurrency,\n        autoStart: false\n      })\n      const localReadQueue = readQueue\n\n      // Add the task to the read queue\n      const readPromise = createReleaseable(readQueue, opts)\n\n      void masterQueue.add(async () => {\n        // Start the task only once the master queue has completed processing\n        // any previous tasks\n        localReadQueue.start()\n\n        // Once all the tasks in the read queue have completed, remove it so\n        // that the next read lock will occur after any write locks that were\n        // started in the interim\n        await localReadQueue.onIdle()\n          .then(() => {\n            if (readQueue === localReadQueue) {\n              readQueue = null\n            }\n          })\n      })\n\n      return readPromise\n    },\n    async writeLock (opts?: AbortOptions) {\n      // Remove the read queue reference, so that any later read locks will be\n      // added to a new queue that starts after this write lock has been\n      // released\n      readQueue = null\n\n      return createReleaseable(masterQueue, opts)\n    }\n  }\n}\n\nconst defaultOptions = {\n  name: 'lock',\n  concurrency: Infinity,\n  singleProcess: false\n}\n\ninterface EventData {\n  name: string\n  handler(): Promise<void>\n}\n\nexport default function createMortice (options?: MorticeOptions): Mortice {\n  const opts: Required<MorticeOptions> = Object.assign({}, defaultOptions, options)\n\n  if (implementation == null) {\n    implementation = impl(opts)\n\n    if (implementation.isWorker !== true) {\n      // we are master, set up worker requests\n      implementation.addEventListener('requestReadLock', (event: MessageEvent<EventData>) => {\n        const mutexName = event.data.name\n\n        if (mutexes[mutexName] == null) {\n          return\n        }\n\n        const abortController = new AbortController()\n\n        const abortListener = (event: MessageEvent<EventData>): void => {\n          if (event.data.name !== mutexName) {\n            return\n          }\n\n          abortController.abort()\n        }\n\n        implementation.addEventListener('abortReadLockRequest', abortListener)\n\n        void mutexes[mutexName].readLock({\n          signal: abortController.signal\n        })\n          .then(async release => event.data.handler()\n            .finally(() => {\n              release()\n            })\n          )\n          .finally(() => {\n            implementation.removeEventListener('abortReadLockRequest', abortListener)\n          })\n      })\n\n      implementation.addEventListener('requestWriteLock', async (event: MessageEvent<EventData>) => {\n        const mutexName = event.data.name\n\n        if (mutexes[mutexName] == null) {\n          return\n        }\n\n        const abortController = new AbortController()\n\n        const abortListener = (event: MessageEvent<EventData>): void => {\n          if (event.data.name !== mutexName) {\n            return\n          }\n\n          abortController.abort()\n        }\n\n        implementation.addEventListener('abortWriteLockRequest', abortListener)\n\n        void mutexes[event.data.name].writeLock({\n          signal: abortController.signal\n        })\n          .then(async release => event.data.handler()\n            .finally(() => {\n              release()\n            })\n          )\n          .finally(() => {\n            implementation.removeEventListener('abortWriteLockRequest', abortListener)\n          })\n      })\n    }\n  }\n\n  if (mutexes[opts.name] == null) {\n    mutexes[opts.name] = createMutex(opts.name, opts)\n  }\n\n  return mutexes[opts.name]\n}\n", "/**\n * @packageDocumentation\n *\n * A simple error class and options interface that seems to get copied from\n * project to project.\n *\n * @example Using `AbortError`\n *\n * ```JavaScript\n * import { AbortError } from 'abort-error'\n *\n * // a promise that will be settled later\n * const deferred = Promise.withResolvers()\n *\n * const signal = AbortSignal.timeout(1000)\n * signal.addEventListener('abort', () => {\n *   deferred.reject(new AbortError())\n * })\n * ```\n *\n * @example Using `AbortOptions`\n *\n * ```TypeScript\n * import type { AbortOptions } from 'abort-error'\n *\n * async function myFunction (options?: AbortOptions) {\n *   return fetch('https://example.com', {\n *     signal: options?.signal\n *   })\n * }\n * ```\n */\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\nexport class AbortError extends Error {\n  static name = 'AbortError'\n  name = 'AbortError'\n\n  constructor (message: string = 'The operation was aborted', ...rest: any[]) {\n    super(message, ...rest)\n  }\n}\n", "import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n", "export class TimeoutError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = 'TimeoutError';\n\t}\n}\n\n/**\nAn error to be thrown when the request is aborted by AbortController.\nDOMException is thrown instead of this Error when DOMException is available.\n*/\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\n/**\nTODO: Remove AbortError and just throw DOMException when targeting Node 18.\n*/\nconst getDOMException = errorMessage => globalThis.DOMException === undefined\n\t? new AbortError(errorMessage)\n\t: new DOMException(errorMessage);\n\n/**\nTODO: Remove below function and just 'reject(signal.reason)' when targeting Node 18.\n*/\nconst getAbortedReason = signal => {\n\tconst reason = signal.reason === undefined\n\t\t? getDOMException('This operation was aborted.')\n\t\t: signal.reason;\n\n\treturn reason instanceof Error ? reason : getDOMException(reason);\n};\n\nexport default function pTimeout(promise, options) {\n\tconst {\n\t\tmilliseconds,\n\t\tfallback,\n\t\tmessage,\n\t\tcustomTimers = {setTimeout, clearTimeout},\n\t} = options;\n\n\tlet timer;\n\tlet abortHandler;\n\n\tconst wrappedPromise = new Promise((resolve, reject) => {\n\t\tif (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {\n\t\t\tthrow new TypeError(`Expected \\`milliseconds\\` to be a positive number, got \\`${milliseconds}\\``);\n\t\t}\n\n\t\tif (options.signal) {\n\t\t\tconst {signal} = options;\n\t\t\tif (signal.aborted) {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t}\n\n\t\t\tabortHandler = () => {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t};\n\n\t\t\tsignal.addEventListener('abort', abortHandler, {once: true});\n\t\t}\n\n\t\tif (milliseconds === Number.POSITIVE_INFINITY) {\n\t\t\tpromise.then(resolve, reject);\n\t\t\treturn;\n\t\t}\n\n\t\t// We create the error outside of `setTimeout` to preserve the stack trace.\n\t\tconst timeoutError = new TimeoutError();\n\n\t\ttimer = customTimers.setTimeout.call(undefined, () => {\n\t\t\tif (fallback) {\n\t\t\t\ttry {\n\t\t\t\t\tresolve(fallback());\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof promise.cancel === 'function') {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\n\t\t\tif (message === false) {\n\t\t\t\tresolve();\n\t\t\t} else if (message instanceof Error) {\n\t\t\t\treject(message);\n\t\t\t} else {\n\t\t\t\ttimeoutError.message = message ?? `Promise timed out after ${milliseconds} milliseconds`;\n\t\t\t\treject(timeoutError);\n\t\t\t}\n\t\t}, milliseconds);\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tresolve(await promise);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t})();\n\t});\n\n\tconst cancelablePromise = wrappedPromise.finally(() => {\n\t\tcancelablePromise.clear();\n\t\tif (abortHandler && options.signal) {\n\t\t\toptions.signal.removeEventListener('abort', abortHandler);\n\t\t}\n\t});\n\n\tcancelablePromise.clear = () => {\n\t\tcustomTimers.clearTimeout.call(undefined, timer);\n\t\ttimer = undefined;\n\t};\n\n\treturn cancelablePromise;\n}\n", "// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\nexport default function lowerBound(array, value, comparator) {\n    let first = 0;\n    let count = array.length;\n    while (count > 0) {\n        const step = Math.trunc(count / 2);\n        let it = first + step;\n        if (comparator(array[it], value) <= 0) {\n            first = ++it;\n            count -= step + 1;\n        }\n        else {\n            count = step;\n        }\n    }\n    return first;\n}\n", "import lowerBound from './lower-bound.js';\nexport default class PriorityQueue {\n    #queue = [];\n    enqueue(run, options) {\n        options = {\n            priority: 0,\n            ...options,\n        };\n        const element = {\n            priority: options.priority,\n            id: options.id,\n            run,\n        };\n        if (this.size === 0 || this.#queue[this.size - 1].priority >= options.priority) {\n            this.#queue.push(element);\n            return;\n        }\n        const index = lowerBound(this.#queue, element, (a, b) => b.priority - a.priority);\n        this.#queue.splice(index, 0, element);\n    }\n    setPriority(id, priority) {\n        const index = this.#queue.findIndex((element) => element.id === id);\n        if (index === -1) {\n            throw new ReferenceError(`No promise function with the id \"${id}\" exists in the queue.`);\n        }\n        const [item] = this.#queue.splice(index, 1);\n        this.enqueue(item.run, { priority, id });\n    }\n    dequeue() {\n        const item = this.#queue.shift();\n        return item?.run;\n    }\n    filter(options) {\n        return this.#queue.filter((element) => element.priority === options.priority).map((element) => element.run);\n    }\n    get size() {\n        return this.#queue.length;\n    }\n}\n", "import { EventEmitter } from 'eventemitter3';\nimport pTimeout, { TimeoutError } from 'p-timeout';\nimport PriorityQueue from './priority-queue.js';\n/**\nPromise queue with concurrency control.\n*/\nexport default class PQueue extends EventEmitter {\n    #carryoverConcurrencyCount;\n    #isIntervalIgnored;\n    #intervalCount = 0;\n    #intervalCap;\n    #interval;\n    #intervalEnd = 0;\n    #intervalId;\n    #timeoutId;\n    #queue;\n    #queueClass;\n    #pending = 0;\n    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194\n    #concurrency;\n    #isPaused;\n    #throwOnTimeout;\n    // Use to assign a unique identifier to a promise function, if not explicitly specified\n    #idAssigner = 1n;\n    /**\n    Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.\n\n    Applies to each future operation.\n    */\n    timeout;\n    // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`\n    constructor(options) {\n        super();\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = {\n            carryoverConcurrencyCount: false,\n            intervalCap: Number.POSITIVE_INFINITY,\n            interval: 0,\n            concurrency: Number.POSITIVE_INFINITY,\n            autoStart: true,\n            queueClass: PriorityQueue,\n            ...options,\n        };\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${options.intervalCap?.toString() ?? ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${options.interval?.toString() ?? ''}\\` (${typeof options.interval})`);\n        }\n        this.#carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n        this.#isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;\n        this.#intervalCap = options.intervalCap;\n        this.#interval = options.interval;\n        this.#queue = new options.queueClass();\n        this.#queueClass = options.queueClass;\n        this.concurrency = options.concurrency;\n        this.timeout = options.timeout;\n        this.#throwOnTimeout = options.throwOnTimeout === true;\n        this.#isPaused = options.autoStart === false;\n    }\n    get #doesIntervalAllowAnother() {\n        return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;\n    }\n    get #doesConcurrentAllowAnother() {\n        return this.#pending < this.#concurrency;\n    }\n    #next() {\n        this.#pending--;\n        this.#tryToStartAnother();\n        this.emit('next');\n    }\n    #onResumeInterval() {\n        this.#onInterval();\n        this.#initializeIntervalIfNeeded();\n        this.#timeoutId = undefined;\n    }\n    get #isIntervalPaused() {\n        const now = Date.now();\n        if (this.#intervalId === undefined) {\n            const delay = this.#intervalEnd - now;\n            if (delay < 0) {\n                // Act as the interval was done\n                // We don't need to resume it here because it will be resumed on line 160\n                this.#intervalCount = (this.#carryoverConcurrencyCount) ? this.#pending : 0;\n            }\n            else {\n                // Act as the interval is pending\n                if (this.#timeoutId === undefined) {\n                    this.#timeoutId = setTimeout(() => {\n                        this.#onResumeInterval();\n                    }, delay);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    #tryToStartAnother() {\n        if (this.#queue.size === 0) {\n            // We can clear the interval (\"pause\")\n            // Because we can redo it later (\"resume\")\n            if (this.#intervalId) {\n                clearInterval(this.#intervalId);\n            }\n            this.#intervalId = undefined;\n            this.emit('empty');\n            if (this.#pending === 0) {\n                this.emit('idle');\n            }\n            return false;\n        }\n        if (!this.#isPaused) {\n            const canInitializeInterval = !this.#isIntervalPaused;\n            if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {\n                const job = this.#queue.dequeue();\n                if (!job) {\n                    return false;\n                }\n                this.emit('active');\n                job();\n                if (canInitializeInterval) {\n                    this.#initializeIntervalIfNeeded();\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    #initializeIntervalIfNeeded() {\n        if (this.#isIntervalIgnored || this.#intervalId !== undefined) {\n            return;\n        }\n        this.#intervalId = setInterval(() => {\n            this.#onInterval();\n        }, this.#interval);\n        this.#intervalEnd = Date.now() + this.#interval;\n    }\n    #onInterval() {\n        if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {\n            clearInterval(this.#intervalId);\n            this.#intervalId = undefined;\n        }\n        this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;\n        this.#processQueue();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n    #processQueue() {\n        // eslint-disable-next-line no-empty\n        while (this.#tryToStartAnother()) { }\n    }\n    get concurrency() {\n        return this.#concurrency;\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        this.#concurrency = newConcurrency;\n        this.#processQueue();\n    }\n    async #throwOnAbort(signal) {\n        return new Promise((_resolve, reject) => {\n            signal.addEventListener('abort', () => {\n                reject(signal.reason);\n            }, { once: true });\n        });\n    }\n    /**\n    Updates the priority of a promise function by its id, affecting its execution order. Requires a defined concurrency limit to take effect.\n\n    For example, this can be used to prioritize a promise function to run earlier.\n\n    ```js\n    import PQueue from 'p-queue';\n\n    const queue = new PQueue({concurrency: 1});\n\n    queue.add(async () => '\uD83E\uDD84', {priority: 1});\n    queue.add(async () => '\uD83E\uDD80', {priority: 0, id: '\uD83E\uDD80'});\n    queue.add(async () => '\uD83E\uDD84', {priority: 1});\n    queue.add(async () => '\uD83E\uDD84', {priority: 1});\n\n    queue.setPriority('\uD83E\uDD80', 2);\n    ```\n\n    In this case, the promise function with `id: '\uD83E\uDD80'` runs second.\n\n    You can also deprioritize a promise function to delay its execution:\n\n    ```js\n    import PQueue from 'p-queue';\n\n    const queue = new PQueue({concurrency: 1});\n\n    queue.add(async () => '\uD83E\uDD84', {priority: 1});\n    queue.add(async () => '\uD83E\uDD80', {priority: 1, id: '\uD83E\uDD80'});\n    queue.add(async () => '\uD83E\uDD84');\n    queue.add(async () => '\uD83E\uDD84', {priority: 0});\n\n    queue.setPriority('\uD83E\uDD80', -1);\n    ```\n    Here, the promise function with `id: '\uD83E\uDD80'` executes last.\n    */\n    setPriority(id, priority) {\n        this.#queue.setPriority(id, priority);\n    }\n    async add(function_, options = {}) {\n        // In case `id` is not defined.\n        options.id ??= (this.#idAssigner++).toString();\n        options = {\n            timeout: this.timeout,\n            throwOnTimeout: this.#throwOnTimeout,\n            ...options,\n        };\n        return new Promise((resolve, reject) => {\n            this.#queue.enqueue(async () => {\n                this.#pending++;\n                this.#intervalCount++;\n                try {\n                    options.signal?.throwIfAborted();\n                    let operation = function_({ signal: options.signal });\n                    if (options.timeout) {\n                        operation = pTimeout(Promise.resolve(operation), { milliseconds: options.timeout });\n                    }\n                    if (options.signal) {\n                        operation = Promise.race([operation, this.#throwOnAbort(options.signal)]);\n                    }\n                    const result = await operation;\n                    resolve(result);\n                    this.emit('completed', result);\n                }\n                catch (error) {\n                    if (error instanceof TimeoutError && !options.throwOnTimeout) {\n                        resolve();\n                        return;\n                    }\n                    reject(error);\n                    this.emit('error', error);\n                }\n                finally {\n                    this.#next();\n                }\n            }, options);\n            this.emit('add');\n            this.#tryToStartAnother();\n        });\n    }\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!this.#isPaused) {\n            return this;\n        }\n        this.#isPaused = false;\n        this.#processQueue();\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        this.#isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        this.#queue = new this.#queueClass();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (this.#queue.size === 0) {\n            return;\n        }\n        await this.#onEvent('empty');\n    }\n    /**\n    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.\n\n    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.\n\n    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.\n    */\n    async onSizeLessThan(limit) {\n        // Instantly resolve if the queue is empty.\n        if (this.#queue.size < limit) {\n            return;\n        }\n        await this.#onEvent('next', () => this.#queue.size < limit);\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this.#pending === 0 && this.#queue.size === 0) {\n            return;\n        }\n        await this.#onEvent('idle');\n    }\n    async #onEvent(event, filter) {\n        return new Promise(resolve => {\n            const listener = () => {\n                if (filter && !filter()) {\n                    return;\n                }\n                this.off(event, listener);\n                resolve();\n            };\n            this.on(event, listener);\n        });\n    }\n    /**\n    Size of the queue, the number of queued items waiting to run.\n    */\n    get size() {\n        return this.#queue.size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-array-callback-reference\n        return this.#queue.filter(options).length;\n    }\n    /**\n    Number of running items (no longer in the queue).\n    */\n    get pending() {\n        return this.#pending;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return this.#isPaused;\n    }\n}\n", "export interface WebworkerEventListener <T = any> {\n  (worker: Worker, event: MessageEvent<T>): void\n}\n\nconst events: Record<string, WebworkerEventListener[]> = {}\n\nconst observable = (worker: Worker & { port?: any }) => {\n  worker.addEventListener('message', (event) => {\n    observable.dispatchEvent('message', worker, event)\n  })\n\n  if (worker.port != null) {\n    worker.port.addEventListener('message', (event: any) => {\n      observable.dispatchEvent('message', worker, event)\n    })\n  }\n}\n\nobservable.addEventListener = (type: string, fn: WebworkerEventListener) => {\n  if (events[type] == null) {\n    events[type] = []\n  }\n\n  events[type].push(fn)\n}\n\nobservable.removeEventListener = (type: string, fn: WebworkerEventListener) => {\n  if (events[type] == null) {\n    return\n  }\n\n  events[type] = events[type]\n    .filter(listener => listener === fn)\n}\n\nobservable.dispatchEvent = function (type: string, worker: Worker, event: MessageEvent<any>) {\n  if (events[type] == null) {\n    return\n  }\n\n  events[type].forEach(fn => fn(worker, event))\n}\n\nexport default observable\n", "export const WORKER_REQUEST_READ_LOCK = 'lock:worker:request-read'\nexport const WORKER_ABORT_READ_LOCK_REQUEST = 'lock:worker:abort-read-request'\nexport const WORKER_RELEASE_READ_LOCK = 'lock:worker:release-read'\nexport const MASTER_GRANT_READ_LOCK = 'lock:master:grant-read'\n\nexport const WORKER_REQUEST_WRITE_LOCK = 'lock:worker:request-write'\nexport const WORKER_ABORT_WRITE_LOCK_REQUEST = 'lock:worker:abort-write-request'\nexport const WORKER_RELEASE_WRITE_LOCK = 'lock:worker:release-write'\nexport const MASTER_GRANT_WRITE_LOCK = 'lock:master:grant-write'\n", "export const nanoid = (size: number = 10): string => {\n  return Math.random().toString().substring(2, size + 2)\n}\n", "import { AbortError } from 'abort-error'\nimport observer from 'observable-webworkers'\nimport {\n  WORKER_REQUEST_READ_LOCK,\n  WORKER_RELEASE_READ_LOCK,\n  MASTER_GRANT_READ_LOCK,\n  WORKER_REQUEST_WRITE_LOCK,\n  WORKER_RELEASE_WRITE_LOCK,\n  MASTER_GRANT_WRITE_LOCK,\n  WORKER_ABORT_READ_LOCK_REQUEST,\n  WORKER_ABORT_WRITE_LOCK_REQUEST\n} from './constants.js'\nimport { nanoid } from './utils.js'\nimport type { MorticeOptions, Release } from './index.js'\nimport type { AbortRequestType, MorticeImplementation, RequestType } from './interface.js'\nimport type { AbortOptions } from 'abort-error'\n\nconst handleWorkerLockRequest = (emitter: EventTarget, masterEvent: RequestType, abortMasterEvent: AbortRequestType, requestType: string, abortType: string, releaseType: string, grantType: string) => {\n  return (worker: Worker, event: MessageEvent) => {\n    if (event.data == null) {\n      return\n    }\n\n    const requestEvent = {\n      type: event.data.type,\n      name: event.data.name,\n      identifier: event.data.identifier\n    }\n\n    if (event.data.type === requestType) {\n      emitter.dispatchEvent(new MessageEvent(masterEvent, {\n        data: {\n          name: requestEvent.name,\n          handler: async (): Promise<void> => {\n            // grant lock to worker\n            worker.postMessage({\n              type: grantType,\n              name: requestEvent.name,\n              identifier: requestEvent.identifier\n            })\n\n            // wait for worker to finish\n            await new Promise<void>((resolve) => {\n              const releaseEventListener = (event: MessageEvent): void => {\n                if (event?.data == null) {\n                  return\n                }\n\n                const releaseEvent = {\n                  type: event.data.type,\n                  name: event.data.name,\n                  identifier: event.data.identifier\n                }\n\n                if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {\n                  worker.removeEventListener('message', releaseEventListener)\n                  resolve()\n                }\n              }\n\n              worker.addEventListener('message', releaseEventListener)\n            })\n          }\n        }\n      }))\n    }\n\n    if (requestEvent.type === abortType) {\n      // tell worker we are no longer interested in the lock\n      worker.postMessage({\n        type: abortType,\n        name: requestEvent.name,\n        identifier: requestEvent.identifier\n      })\n\n      emitter.dispatchEvent(new MessageEvent(abortMasterEvent, {\n        data: {\n          name: requestEvent.name\n        }\n      }))\n    }\n  }\n}\n\nconst makeWorkerLockRequest = (name: string, requestType: string, abortType: string, grantType: string, releaseType: string) => {\n  return async (options?: AbortOptions) => {\n    options?.signal?.throwIfAborted()\n    const id = nanoid()\n\n    globalThis.postMessage({\n      type: requestType,\n      identifier: id,\n      name\n    })\n\n    return new Promise<Release>((resolve, reject) => {\n      const abortListener = (): void => {\n        process.send?.({\n          type: abortType,\n          identifier: id,\n          name\n        })\n\n        reject(new AbortError())\n      }\n\n      options?.signal?.addEventListener('abort', abortListener, {\n        once: true\n      })\n\n      const listener = (event: MessageEvent): void => {\n        if (event?.data == null) {\n          return\n        }\n\n        const responseEvent = {\n          type: event.data.type,\n          identifier: event.data.identifier\n        }\n\n        if (responseEvent.type === grantType && responseEvent.identifier === id) {\n          globalThis.removeEventListener('message', listener)\n          options?.signal?.removeEventListener('abort', abortListener)\n\n          // grant lock\n          resolve(() => {\n            // release lock\n            globalThis.postMessage({\n              type: releaseType,\n              identifier: id,\n              name\n            })\n          })\n        }\n      }\n\n      globalThis.addEventListener('message', listener)\n    })\n  }\n}\n\nconst defaultOptions = {\n  singleProcess: false\n}\n\nexport default (options: Required<MorticeOptions>): MorticeImplementation | EventTarget => {\n  options = Object.assign({}, defaultOptions, options)\n  const isPrimary = Boolean(globalThis.document) || options.singleProcess\n\n  if (isPrimary) {\n    const emitter = new EventTarget()\n\n    observer.addEventListener('message', handleWorkerLockRequest(emitter, 'requestReadLock', 'abortReadLockRequest', WORKER_REQUEST_READ_LOCK, WORKER_ABORT_READ_LOCK_REQUEST, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK))\n    observer.addEventListener('message', handleWorkerLockRequest(emitter, 'requestWriteLock', 'abortWriteLockRequest', WORKER_REQUEST_WRITE_LOCK, WORKER_ABORT_WRITE_LOCK_REQUEST, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK))\n\n    return emitter\n  }\n\n  return {\n    isWorker: true,\n    readLock: (name) => makeWorkerLockRequest(name, WORKER_REQUEST_READ_LOCK, WORKER_ABORT_READ_LOCK_REQUEST, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),\n    writeLock: (name) => makeWorkerLockRequest(name, WORKER_REQUEST_WRITE_LOCK, WORKER_ABORT_WRITE_LOCK_REQUEST, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)\n  }\n}\n"],
-  "mappings": "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",
-  "names": ["require_eventemitter3", "__commonJSMin", "exports", "module", "has", "prefix", "Events", "EE", "fn", "context", "once", "addListener", "emitter", "event", "listener", "evt", "clearEvent", "EventEmitter", "names", "events", "name", "handlers", "l", "ee", "listeners", "a1", "a2", "a3", "a4", "a5", "len", "args", "i", "length", "j", "index_exports", "__export", "createMortice", "AbortError", "message", "rest", "import_index", "TimeoutError", "message", "AbortError", "getDOMException", "errorMessage", "getAbortedReason", "signal", "reason", "pTimeout", "promise", "options", "milliseconds", "fallback", "customTimers", "timer", "abortHandler", "cancelablePromise", "resolve", "reject", "timeoutError", "error", "lowerBound", "array", "value", "comparator", "first", "count", "step", "it", "PriorityQueue", "#queue", "run", "options", "element", "index", "lowerBound", "a", "b", "id", "priority", "item", "PQueue", "EventEmitter", "#carryoverConcurrencyCount", "#isIntervalIgnored", "#intervalCount", "#intervalCap", "#interval", "#intervalEnd", "#intervalId", "#timeoutId", "#queue", "#queueClass", "#pending", "#concurrency", "#isPaused", "#throwOnTimeout", "#idAssigner", "options", "PriorityQueue", "#doesIntervalAllowAnother", "#doesConcurrentAllowAnother", "#next", "#tryToStartAnother", "#onResumeInterval", "#onInterval", "#initializeIntervalIfNeeded", "#isIntervalPaused", "now", "delay", "canInitializeInterval", "job", "#processQueue", "newConcurrency", "#throwOnAbort", "signal", "_resolve", "reject", "id", "priority", "function_", "resolve", "operation", "pTimeout", "result", "error", "TimeoutError", "functions", "#onEvent", "limit", "event", "filter", "listener", "events", "observable", "worker", "event", "type", "fn", "listener", "src_default", "WORKER_REQUEST_READ_LOCK", "WORKER_ABORT_READ_LOCK_REQUEST", "WORKER_RELEASE_READ_LOCK", "MASTER_GRANT_READ_LOCK", "WORKER_REQUEST_WRITE_LOCK", "WORKER_ABORT_WRITE_LOCK_REQUEST", "WORKER_RELEASE_WRITE_LOCK", "MASTER_GRANT_WRITE_LOCK", "nanoid", "size", "handleWorkerLockRequest", "emitter", "masterEvent", "abortMasterEvent", "requestType", "abortType", "releaseType", "grantType", "worker", "event", "requestEvent", "resolve", "releaseEventListener", "releaseEvent", "makeWorkerLockRequest", "name", "options", "id", "nanoid", "reject", "abortListener", "AbortError", "listener", "responseEvent", "defaultOptions", "browser_default", "src_default", "WORKER_REQUEST_READ_LOCK", "WORKER_ABORT_READ_LOCK_REQUEST", "WORKER_RELEASE_READ_LOCK", "MASTER_GRANT_READ_LOCK", "WORKER_REQUEST_WRITE_LOCK", "WORKER_ABORT_WRITE_LOCK_REQUEST", "WORKER_RELEASE_WRITE_LOCK", "MASTER_GRANT_WRITE_LOCK", "mutexes", "implementation", "createReleaseable", "queue", "options", "res", "rej", "p", "resolve", "reject", "listener", "AbortError", "err", "createMutex", "name", "masterQueue", "PQueue", "readQueue", "opts", "localReadQueue", "readPromise", "defaultOptions", "createMortice", "browser_default", "event", "mutexName", "abortController", "abortListener", "release"]
+  "sources": ["../src/index.ts", "../node_modules/abort-error/src/index.ts", "../node_modules/p-defer/index.js", "../node_modules/it-pushable/src/fifo.ts", "../node_modules/it-pushable/src/index.ts", "../node_modules/main-event/src/index.ts", "../node_modules/race-event/src/index.ts", "../node_modules/it-queue/src/errors.ts", "../node_modules/race-signal/src/index.ts", "../node_modules/it-queue/src/recipient.ts", "../node_modules/it-queue/src/job.ts", "../node_modules/it-queue/src/utils.ts", "../node_modules/it-queue/src/index.ts", "../node_modules/observable-webworkers/src/index.ts", "../src/constants.ts", "../src/utils.ts", "../src/browser.ts"],
+  "sourcesContent": ["/**\n * @packageDocumentation\n *\n * - Reads occur concurrently\n * - Writes occur one at a time\n * - No reads occur while a write operation is in progress\n * - Locks can be created with different names\n * - Reads/writes can time out\n *\n * @example\n *\n * ```javascript\n * import mortice from 'mortice'\n * import delay from 'delay'\n *\n * // the lock name & options objects are both optional\n * const mutex = mortice()\n *\n * Promise.all([\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 1')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 2')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.writeLock()\n *\n *     try {\n *       await delay(1000)\n *\n *       console.info('write 1')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 3')\n *     } finally {\n *       release()\n *     }\n *   })()\n * ])\n * ```\n *\n *     read 1\n *     read 2\n *     <small pause>\n *     write 1\n *     read 3\n *\n * ## Browser\n *\n * Because there's no global way to eavesdrop on messages sent by Web Workers,\n * please pass all created Web Workers to the [`observable-webworkers`](https://npmjs.org/package/observable-webworkers)\n * module:\n *\n * ```javascript\n * // main.js\n * import mortice from 'mortice'\n * import observe from 'observable-webworkers'\n *\n * // create our lock on the main thread, it will be held here\n * const mutex = mortice()\n *\n * const worker = new Worker('worker.js')\n *\n * observe(worker)\n * ```\n *\n * ```javascript\n * // worker.js\n * import mortice from 'mortice'\n * import delay from 'delay'\n *\n * const mutex = mortice()\n *\n * let release = await mutex.readLock()\n * // read something\n * release()\n *\n * release = await mutex.writeLock()\n * // write something\n * release()\n * ```\n *\n * ## Cleanup\n *\n * If creating temporary mutexes, the `.cleanUp` function should be called when\n * the mutex is no longer required.\n *\n * This must be done in the execution context that controls the mutex (normally\n * the main or renderer thread), calling it in a worker is a no-op.\n *\n * ```javascript\n * import mortice from 'mortice'\n *\n * const mutex = mortice()\n *\n * // ...some time later\n *\n * mutex.cleanUp()\n * ```\n */\n\nimport { AbortError } from 'abort-error'\nimport { Queue } from 'it-queue'\nimport impl from './node.js'\nimport type { AbortOptions } from 'abort-error'\n\nexport interface MorticeOptions {\n  /**\n   * An optional name for the lock\n   */\n  name?: string\n\n  /**\n   * How many read operations are executed concurrently\n   *\n   * @default Infinity\n   */\n  concurrency?: number\n\n  /**\n   * By default the the lock will be held on the main thread and child/worker\n   * processes will coordinate to share the lock.\n   *\n   * Set this to true if each main/child/worker thread should maintain it's own\n   * lock with no coordination between them.\n   *\n   * @default false\n   */\n  singleProcess?: boolean\n}\n\nexport interface Mortice {\n  /**\n   * Acquire a read lock. Multiple reads will occur simultaneously up to the\n   * concurrency limit passed to the constructor.\n   */\n  readLock(options?: AbortOptions): Promise<Release>\n\n  /**\n   * Acquire a write lock. The write lock will wait for any in-flight reads to\n   * complete, then prevent any further reads or writes until the lock is\n   * released.\n   */\n  writeLock(options?: AbortOptions): Promise<Release>\n\n  /**\n   * Removes this mutex from the global state, after invoking this method it\n   * cannot be used any more.\n   *\n   * It must be called in the owning context, calling this method in a worker\n   * is a no-op.\n   */\n  cleanUp(): void\n\n  /**\n   * If this is the main thread, the state of the read/write queue may be\n   * inspected here\n   */\n  queue?: Queue\n}\n\nexport interface Release {\n  (): void\n}\n\nconst mutexes: Record<string, Mortice> = {}\nlet implementation: any\n\nasync function createReleaseable (queue: Queue, options?: AbortOptions): Promise<Release> {\n  let res: (release: Release) => void\n  let rej: (err: Error) => void\n\n  const p = new Promise<Release>((resolve, reject) => {\n    res = resolve\n    rej = reject\n  })\n\n  const listener = (): void => {\n    rej(new AbortError())\n  }\n\n  options?.signal?.addEventListener('abort', listener, {\n    once: true\n  })\n\n  queue.add(async () => {\n    await new Promise<void>((resolve) => {\n      res(() => {\n        options?.signal?.removeEventListener('abort', listener)\n        resolve()\n      })\n    })\n  }, {\n    signal: options?.signal\n  })\n    .catch((err) => {\n      rej(err)\n    })\n\n  return p\n}\n\nconst createMutex = (name: string, options: Required<MorticeOptions>): Mortice => {\n  if (implementation.isWorker === true) {\n    return {\n      readLock: implementation.readLock(name, options),\n      writeLock: implementation.writeLock(name, options),\n      cleanUp: () => {}\n    }\n  }\n\n  const masterQueue = new Queue({\n    concurrency: 1\n  })\n  let readQueue: Queue | null\n\n  return {\n    async readLock (opts?: AbortOptions) {\n      // If there's already a read queue, just add the task to it\n      if (readQueue != null) {\n        return createReleaseable(readQueue, opts)\n      }\n\n      // Create a new read queue\n      readQueue = new Queue({\n        concurrency: options.concurrency,\n        autoStart: false\n      })\n      const localReadQueue = readQueue\n\n      // Add the task to the read queue\n      const readPromise = createReleaseable(readQueue, opts)\n\n      void masterQueue.add(async () => {\n        // Start the task only once the master queue has completed processing\n        // any previous tasks\n        localReadQueue.start()\n\n        // Once all the tasks in the read queue have completed, remove it so\n        // that the next read lock will occur after any write locks that were\n        // started in the interim\n        await localReadQueue.onIdle()\n          .then(() => {\n            if (readQueue === localReadQueue) {\n              readQueue = null\n            }\n          })\n      })\n\n      return readPromise\n    },\n    async writeLock (opts?: AbortOptions) {\n      // Remove the read queue reference, so that any later read locks will be\n      // added to a new queue that starts after this write lock has been\n      // released\n      readQueue = null\n\n      return createReleaseable(masterQueue, opts)\n    },\n    cleanUp: () => {\n      delete mutexes[name]\n    },\n    queue: masterQueue\n  }\n}\n\nconst defaultOptions = {\n  name: 'lock',\n  concurrency: Infinity,\n  singleProcess: false\n}\n\ninterface EventData {\n  name: string\n  handler(): Promise<void>\n}\n\nexport default function createMortice (options?: MorticeOptions): Mortice {\n  const opts: Required<MorticeOptions> = Object.assign({}, defaultOptions, options)\n\n  if (implementation == null) {\n    implementation = impl(opts)\n\n    if (implementation.isWorker !== true) {\n      // we are master, set up worker requests\n      implementation.addEventListener('requestReadLock', (event: MessageEvent<EventData>) => {\n        const mutexName = event.data.name\n\n        if (mutexes[mutexName] == null) {\n          return\n        }\n\n        const abortController = new AbortController()\n\n        const abortListener = (event: MessageEvent<EventData>): void => {\n          if (event.data.name !== mutexName) {\n            return\n          }\n\n          abortController.abort()\n        }\n\n        implementation.addEventListener('abortReadLockRequest', abortListener)\n\n        void mutexes[mutexName].readLock({\n          signal: abortController.signal\n        })\n          .then(async release => event.data.handler()\n            .finally(() => {\n              release()\n            })\n          )\n          .finally(() => {\n            implementation.removeEventListener('abortReadLockRequest', abortListener)\n          })\n      })\n\n      implementation.addEventListener('requestWriteLock', async (event: MessageEvent<EventData>) => {\n        const mutexName = event.data.name\n\n        if (mutexes[mutexName] == null) {\n          return\n        }\n\n        const abortController = new AbortController()\n\n        const abortListener = (event: MessageEvent<EventData>): void => {\n          if (event.data.name !== mutexName) {\n            return\n          }\n\n          abortController.abort()\n        }\n\n        implementation.addEventListener('abortWriteLockRequest', abortListener)\n\n        void mutexes[event.data.name].writeLock({\n          signal: abortController.signal\n        })\n          .then(async release => event.data.handler()\n            .finally(() => {\n              release()\n            })\n          )\n          .finally(() => {\n            implementation.removeEventListener('abortWriteLockRequest', abortListener)\n          })\n      })\n    }\n  }\n\n  if (mutexes[opts.name] == null) {\n    mutexes[opts.name] = createMutex(opts.name, opts)\n  }\n\n  return mutexes[opts.name]\n}\n", "/**\n * @packageDocumentation\n *\n * A simple error class and options interface that seems to get copied from\n * project to project.\n *\n * @example Using `AbortError`\n *\n * ```JavaScript\n * import { AbortError } from 'abort-error'\n *\n * // a promise that will be settled later\n * const deferred = Promise.withResolvers()\n *\n * const signal = AbortSignal.timeout(1000)\n * signal.addEventListener('abort', () => {\n *   deferred.reject(new AbortError())\n * })\n * ```\n *\n * @example Using `AbortOptions`\n *\n * ```TypeScript\n * import type { AbortOptions } from 'abort-error'\n *\n * async function myFunction (options?: AbortOptions) {\n *   return fetch('https://example.com', {\n *     signal: options?.signal\n *   })\n * }\n * ```\n */\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\nexport class AbortError extends Error {\n  static name = 'AbortError'\n  name = 'AbortError'\n\n  constructor (message: string = 'The operation was aborted', ...rest: any[]) {\n    super(message, ...rest)\n  }\n}\n", "export default function pDefer() {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n}\n", "// ported from https://www.npmjs.com/package/fast-fifo\n\nexport interface Next<T> {\n  done?: boolean\n  error?: Error\n  value?: T\n}\n\nclass FixedFIFO<T> {\n  public buffer: Array<Next<T> | undefined>\n  private readonly mask: number\n  private top: number\n  private btm: number\n  public next: FixedFIFO<T> | null\n\n  constructor (hwm: number) {\n    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) {\n      throw new Error('Max size for a FixedFIFO should be a power of two')\n    }\n\n    this.buffer = new Array(hwm)\n    this.mask = hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.next = null\n  }\n\n  push (data: Next<T>): boolean {\n    if (this.buffer[this.top] !== undefined) {\n      return false\n    }\n\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n\n    return true\n  }\n\n  shift (): Next<T> | undefined {\n    const last = this.buffer[this.btm]\n\n    if (last === undefined) {\n      return undefined\n    }\n\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    return last\n  }\n\n  isEmpty (): boolean {\n    return this.buffer[this.btm] === undefined\n  }\n}\n\nexport interface FIFOOptions {\n  /**\n   * When the queue reaches this size, it will be split into head/tail parts\n   */\n  splitLimit?: number\n}\n\nexport class FIFO<T> {\n  public size: number\n  private readonly hwm: number\n  private head: FixedFIFO<T>\n  private tail: FixedFIFO<T>\n\n  constructor (options: FIFOOptions = {}) {\n    this.hwm = options.splitLimit ?? 16\n    this.head = new FixedFIFO<T>(this.hwm)\n    this.tail = this.head\n    this.size = 0\n  }\n\n  calculateSize (obj: any): number {\n    if (obj?.byteLength != null) {\n      return obj.byteLength\n    }\n\n    return 1\n  }\n\n  push (val: Next<T>): void {\n    if (val?.value != null) {\n      this.size += this.calculateSize(val.value)\n    }\n\n    if (!this.head.push(val)) {\n      const prev = this.head\n      this.head = prev.next = new FixedFIFO<T>(2 * this.head.buffer.length)\n      this.head.push(val)\n    }\n  }\n\n  shift (): Next<T> | undefined {\n    let val = this.tail.shift()\n\n    if (val === undefined && (this.tail.next != null)) {\n      const next = this.tail.next\n      this.tail.next = null\n      this.tail = next\n      val = this.tail.shift()\n    }\n\n    if (val?.value != null) {\n      this.size -= this.calculateSize(val.value)\n    }\n\n    return val\n  }\n\n  isEmpty (): boolean {\n    return this.head.isEmpty()\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\n\nimport deferred from 'p-defer'\nimport { FIFO, type Next } from './fifo.js'\n\nexport class AbortError extends Error {\n  type: string\n  code: string\n\n  constructor (message?: string, code?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\ninterface BasePushable<T> {\n  /**\n   * End the iterable after all values in the buffer (if any) have been yielded. If an\n   * error is passed the buffer is cleared immediately and the next iteration will\n   * throw the passed error\n   */\n  end(err?: Error): this\n\n  /**\n   * Push a value into the iterable. Values are yielded from the iterable in the order\n   * they are pushed. Values not yet consumed from the iterable are buffered.\n   */\n  push(value: T): this\n\n  /**\n   * Returns a promise that resolves when the underlying queue becomes empty (e.g.\n   * this.readableLength === 0).\n   *\n   * If an AbortSignal is passed as an option and that signal aborts, it only\n   * causes the returned promise to reject - it does not end the pushable.\n   */\n  onEmpty(options?: AbortOptions): Promise<void>\n\n  /**\n   * This property contains the number of bytes (or objects) in the queue ready to be read.\n   *\n   * If `objectMode` is true, this is the number of objects in the queue, if false it's the\n   * total number of bytes in the queue.\n   */\n  readableLength: number\n}\n\n/**\n * An iterable that you can push values into.\n */\nexport interface Pushable<T, R = void, N = unknown> extends AsyncGenerator<T, R, N>, BasePushable<T> {}\n\n/**\n * Similar to `pushable`, except it yields multiple buffered chunks at a time. All values yielded from the iterable will be arrays.\n */\nexport interface PushableV<T, R = void, N = unknown> extends AsyncGenerator<T[], R, N>, BasePushable<T> {}\n\nexport interface Options {\n  /**\n   * A boolean value that means non-`Uint8Array`s will be passed to `.push`, default: `false`\n   */\n  objectMode?: boolean\n\n  /**\n   * A function called after *all* values have been yielded from the iterator (including\n   * buffered values). In the case when the iterator is ended with an error it will be\n   * passed the error as a parameter.\n   */\n  onEnd?(err?: Error): void\n}\n\nexport interface DoneResult { done: true }\nexport interface ValueResult<T> { done: false, value: T }\nexport type NextResult<T> = ValueResult<T> | DoneResult\n\ninterface getNext<T, V = T> { (buffer: FIFO<T>): NextResult<V> }\n\nexport interface ObjectPushableOptions extends Options {\n  objectMode: true\n}\n\nexport interface BytePushableOptions extends Options {\n  objectMode?: false\n}\n\n/**\n * Create a new async iterable. The values yielded from calls to `.next()`\n * or when used in a `for await of`loop are \"pushed\" into the iterable.\n * Returns an async iterable object with additional methods.\n */\nexport function pushable<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): Pushable<T>\nexport function pushable<T> (options: ObjectPushableOptions): Pushable<T>\nexport function pushable<T> (options: Options = {}): Pushable<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T> => {\n    const next: Next<T> | undefined = buffer.shift()\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    if (next.error != null) {\n      throw next.error\n    }\n\n    return {\n      done: next.done === true,\n      // @ts-expect-error if done is false, value will be present\n      value: next.value\n    }\n  }\n\n  return _pushable<T, T, Pushable<T>>(getNext, options)\n}\n\nexport function pushableV<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): PushableV<T>\nexport function pushableV<T> (options: ObjectPushableOptions): PushableV<T>\nexport function pushableV<T> (options: Options = {}): PushableV<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T[]> => {\n    let next: Next<T> | undefined\n    const values: T[] = []\n\n    while (!buffer.isEmpty()) {\n      next = buffer.shift()\n\n      if (next == null) {\n        break\n      }\n\n      if (next.error != null) {\n        throw next.error\n      }\n\n      if (next.done === false) {\n        // @ts-expect-error if done is false value should be pushed\n        values.push(next.value)\n      }\n    }\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    return {\n      done: next.done === true,\n      value: values\n    }\n  }\n\n  return _pushable<T, T[], PushableV<T>>(getNext, options)\n}\n\nfunction _pushable<PushType, ValueType, ReturnType> (getNext: getNext<PushType, ValueType>, options?: Options): ReturnType {\n  options = options ?? {}\n  let onEnd = options.onEnd\n  let buffer = new FIFO<PushType>()\n  let pushable: any\n  let onNext: ((next: Next<PushType>) => ReturnType) | null\n  let ended: boolean\n  let drain = deferred()\n\n  const waitNext = async (): Promise<NextResult<ValueType>> => {\n    try {\n      if (!buffer.isEmpty()) {\n        return getNext(buffer)\n      }\n\n      if (ended) {\n        return { done: true }\n      }\n\n      return await new Promise<NextResult<ValueType>>((resolve, reject) => {\n        onNext = (next: Next<PushType>) => {\n          onNext = null\n          buffer.push(next)\n\n          try {\n            resolve(getNext(buffer))\n          } catch (err) {\n            reject(err)\n          }\n\n          return pushable\n        }\n      })\n    } finally {\n      if (buffer.isEmpty()) {\n        // settle promise in the microtask queue to give consumers a chance to\n        // await after calling .push\n        queueMicrotask(() => {\n          drain.resolve()\n          drain = deferred()\n        })\n      }\n    }\n  }\n\n  const bufferNext = (next: Next<PushType>): ReturnType => {\n    if (onNext != null) {\n      return onNext(next)\n    }\n\n    buffer.push(next)\n    return pushable\n  }\n\n  const bufferError = (err: Error): ReturnType => {\n    buffer = new FIFO()\n\n    if (onNext != null) {\n      return onNext({ error: err })\n    }\n\n    buffer.push({ error: err })\n    return pushable\n  }\n\n  const push = (value: PushType): ReturnType => {\n    if (ended) {\n      return pushable\n    }\n\n    // @ts-expect-error `byteLength` is not declared on PushType\n    if (options?.objectMode !== true && value?.byteLength == null) {\n      throw new Error('objectMode was not true but tried to push non-Uint8Array value')\n    }\n\n    return bufferNext({ done: false, value })\n  }\n  const end = (err?: Error): ReturnType => {\n    if (ended) return pushable\n    ended = true\n\n    return (err != null) ? bufferError(err) : bufferNext({ done: true })\n  }\n  const _return = (): DoneResult => {\n    buffer = new FIFO()\n    end()\n\n    return { done: true }\n  }\n  const _throw = (err: Error): DoneResult => {\n    end(err)\n\n    return { done: true }\n  }\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next: waitNext,\n    return: _return,\n    throw: _throw,\n    push,\n    end,\n    get readableLength (): number {\n      return buffer.size\n    },\n    onEmpty: async (options?: AbortOptions) => {\n      const signal = options?.signal\n      signal?.throwIfAborted()\n\n      if (buffer.isEmpty()) {\n        return\n      }\n\n      let cancel: Promise<void> | undefined\n      let listener: (() => void) | undefined\n\n      if (signal != null) {\n        cancel = new Promise((resolve, reject) => {\n          listener = () => {\n            reject(new AbortError())\n          }\n\n          signal.addEventListener('abort', listener)\n        })\n      }\n\n      try {\n        await Promise.race([\n          drain.promise,\n          cancel\n        ])\n      } finally {\n        if (listener != null && signal != null) {\n          signal?.removeEventListener('abort', listener)\n        }\n      }\n    }\n  }\n\n  if (onEnd == null) {\n    return pushable\n  }\n\n  const _pushable = pushable\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next () {\n      return _pushable.next()\n    },\n    throw (err: Error) {\n      _pushable.throw(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    return () {\n      _pushable.return()\n\n      if (onEnd != null) {\n        onEnd()\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    push,\n    end (err: Error) {\n      _pushable.end(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return pushable\n    },\n    get readableLength () {\n      return _pushable.readableLength\n    },\n    onEmpty: (opts?: AbortOptions) => {\n      return _pushable.onEmpty(opts)\n    }\n  }\n\n  return pushable\n}\n", "/**\n * @packageDocumentation\n *\n * Adds types to the EventTarget class.\n *\n * Hopefully this won't be necessary\n * forever:\n *\n * - https://github.com/microsoft/TypeScript/issues/28357\n * - https://github.com/microsoft/TypeScript/issues/43477\n * - https://github.com/microsoft/TypeScript/issues/299\n * - https://www.npmjs.com/package/typed-events\n * - https://www.npmjs.com/package/typed-event-emitter\n * - https://www.npmjs.com/package/typed-event-target\n * - etc\n *\n * In addition to types, a `safeDispatchEvent` method is available which\n * prevents dispatching events that aren't in the event map, and a\n * `listenerCount` method which reports the number of listeners that are\n * currently registered for a given event.\n *\n * @example\n *\n * ```ts\n * import { TypedEventEmitter } from 'main-event'\n * import type { TypedEventTarget } from 'main-event'\n *\n * interface EventTypes {\n *   'test': CustomEvent<string>\n * }\n *\n * const target = new TypedEventEmitter<EventTypes>()\n *\n * // it's a regular EventTarget\n * console.info(target instanceof EventTarget) // true\n *\n * // register listeners normally\n * target.addEventListener('test', (evt) => {\n *   // evt is CustomEvent<string>\n * })\n *\n * // @ts-expect-error 'derp' is not in the event map\n * target.addEventListener('derp', () => {})\n *\n * // use normal dispatchEvent method\n * target.dispatchEvent(new CustomEvent('test', {\n *   detail: 'hello'\n * }))\n *\n * // use type safe dispatch method\n * target.safeDispatchEvent('test', {\n *   detail: 'world'\n * })\n *\n * // report listener count\n * console.info(target.listenerCount('test')) // 0\n *\n * // event emitters can be used purely as interfaces too\n * function acceptTarget (target: TypedEventTarget<EventTypes>) {\n *   // ...\n * }\n * ```\n */\n\nimport { setMaxListeners } from './events.js'\n\nexport interface EventCallback<EventType> { (evt: EventType): void }\nexport interface EventObject<EventType> { handleEvent: EventCallback<EventType> }\nexport type EventHandler<EventType> = EventCallback<EventType> | EventObject<EventType>\n\ninterface Listener {\n  once: boolean\n  callback: any\n}\n\n/**\n *\n */\nexport interface TypedEventTarget <EventMap extends Record<string, any>> extends EventTarget {\n  addEventListener<K extends keyof EventMap>(type: K, listener: EventHandler<EventMap[K]> | null, options?: boolean | AddEventListenerOptions): void\n\n  listenerCount (type: string): number\n\n  removeEventListener<K extends keyof EventMap>(type: K, listener?: EventHandler<EventMap[K]> | null, options?: boolean | EventListenerOptions): void\n\n  removeEventListener (type: string, listener?: EventHandler<Event>, options?: boolean | EventListenerOptions): void\n\n  safeDispatchEvent<Detail>(type: keyof EventMap, detail?: CustomEventInit<Detail>): boolean\n}\n\n/**\n * An implementation of a typed event target\n */\nexport class TypedEventEmitter<EventMap extends Record<string, any>> extends EventTarget implements TypedEventTarget<EventMap> {\n  readonly #listeners = new Map<any, Listener[]>()\n\n  constructor () {\n    super()\n\n    // silence MaxListenersExceededWarning warning on Node.js, this is a red\n    // herring almost all of the time\n    setMaxListeners(Infinity, this)\n  }\n\n  listenerCount (type: string): number {\n    const listeners = this.#listeners.get(type)\n\n    if (listeners == null) {\n      return 0\n    }\n\n    return listeners.length\n  }\n\n  addEventListener<K extends keyof EventMap>(type: K, listener: EventHandler<EventMap[K]> | null, options?: boolean | AddEventListenerOptions): void\n  addEventListener (type: string, listener: EventHandler<Event>, options?: boolean | AddEventListenerOptions): void {\n    super.addEventListener(type, listener, options)\n\n    let list = this.#listeners.get(type)\n\n    if (list == null) {\n      list = []\n      this.#listeners.set(type, list)\n    }\n\n    list.push({\n      callback: listener,\n      once: (options !== true && options !== false && options?.once) ?? false\n    })\n  }\n\n  removeEventListener<K extends keyof EventMap>(type: K, listener?: EventHandler<EventMap[K]> | null, options?: boolean | EventListenerOptions): void\n  removeEventListener (type: string, listener?: EventHandler<Event>, options?: boolean | EventListenerOptions): void {\n    super.removeEventListener(type.toString(), listener ?? null, options)\n\n    let list = this.#listeners.get(type)\n\n    if (list == null) {\n      return\n    }\n\n    list = list.filter(({ callback }) => callback !== listener)\n    this.#listeners.set(type, list)\n  }\n\n  dispatchEvent (event: Event): boolean {\n    const result = super.dispatchEvent(event)\n\n    let list = this.#listeners.get(event.type)\n\n    if (list == null) {\n      return result\n    }\n\n    list = list.filter(({ once }) => !once)\n    this.#listeners.set(event.type, list)\n\n    return result\n  }\n\n  safeDispatchEvent<Detail>(type: keyof EventMap, detail: CustomEventInit<Detail> = {}): boolean {\n    return this.dispatchEvent(new CustomEvent<Detail>(type as string, detail))\n  }\n}\n\nexport { setMaxListeners }\n", "/**\n * @packageDocumentation\n *\n * Race an event against an AbortSignal, taking care to remove any event\n * listeners that were added.\n *\n * @example Getting started\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * setTimeout(() => {\n *   controller.abort()\n * }, 500)\n *\n * setTimeout(() => {\n *   // too late\n *   emitter.dispatchEvent(new CustomEvent('event'))\n * }, 1000)\n *\n * // throws an AbortError\n * const resolve = await raceEvent(emitter, 'event', controller.signal)\n * ```\n *\n * @example Aborting the promise with an error event\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const emitter = new EventTarget()\n *\n * setTimeout(() => {\n *   emitter.dispatchEvent(new CustomEvent('failure', {\n *     detail: new Error('Oh no!')\n *   }))\n * }, 1000)\n *\n * // throws 'Oh no!' error\n * const resolve = await raceEvent(emitter, 'success', AbortSignal.timeout(5000), {\n *   errorEvent: 'failure'\n * })\n * ```\n *\n * @example Customising the thrown AbortError\n *\n * The error message and `.code` property of the thrown `AbortError` can be\n * specified by passing options:\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * setTimeout(() => {\n *   controller.abort()\n * }, 500)\n *\n * // throws a Error: Oh no!\n * const resolve = await raceEvent(emitter, 'event', controller.signal, {\n *   errorMessage: 'Oh no!',\n *   errorCode: 'ERR_OH_NO'\n * })\n * ```\n *\n * @example Only resolving on specific events\n *\n * Where multiple events with the same type are emitted, a `filter` function can\n * be passed to only resolve on one of them:\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * // throws a Error: Oh no!\n * const resolve = await raceEvent(emitter, 'event', controller.signal, {\n *   filter: (evt: Event) => {\n *     return evt.detail.foo === 'bar'\n *   }\n * })\n * ```\n *\n * @example Terminating early by throwing from the filter\n *\n * You can cause listening for the event to cease and all event listeners to be\n * removed by throwing from the filter:\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * // throws Error: Cannot continue\n * const resolve = await raceEvent(emitter, 'event', controller.signal, {\n *   filter: (evt) => {\n *     if (...reasons) {\n *       throw new Error('Cannot continue')\n *     }\n *\n *     return true\n *   }\n * })\n * ```\n */\n\n/**\n * An abort error class that extends error\n */\nexport class AbortError extends Error {\n  public type: string\n  public code: string | string\n\n  constructor (message?: string, code?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.name = 'AbortError'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface RaceEventOptions<T> {\n  /**\n   * The message for the error thrown if the signal aborts\n   */\n  errorMessage?: string\n\n  /**\n   * The code for the error thrown if the signal aborts\n   */\n  errorCode?: string\n\n  /**\n   * The name of an event emitted on the emitter that should cause the returned\n   * promise to reject. The rejection reason will be the `.detail` field of the\n   * event.\n   */\n  errorEvent?: string\n\n  /**\n   * When multiple events with the same name may be emitted, pass a filter\n   * function here to allow ignoring ones that should not cause the returned\n   * promise to resolve.\n   */\n  filter?(evt: T): boolean\n}\n\n/**\n * Race a promise against an abort signal\n */\nexport async function raceEvent <T> (emitter: EventTarget, eventName: string, signal?: AbortSignal, opts?: RaceEventOptions<T>): Promise<T> {\n  // create the error here so we have more context in the stack trace\n  const error = new AbortError(opts?.errorMessage, opts?.errorCode)\n\n  if (signal?.aborted === true) {\n    return Promise.reject(error)\n  }\n\n  return new Promise((resolve, reject) => {\n    function removeListeners (): void {\n      signal?.removeEventListener('abort', abortListener)\n      emitter.removeEventListener(eventName, eventListener)\n\n      if (opts?.errorEvent != null) {\n        emitter.removeEventListener(opts.errorEvent, errorEventListener)\n      }\n    }\n\n    const eventListener = (evt: any): void => {\n      try {\n        if (opts?.filter?.(evt) === false) {\n          return\n        }\n      } catch (err: any) {\n        removeListeners()\n        reject(err)\n        return\n      }\n\n      removeListeners()\n      resolve(evt)\n    }\n\n    const errorEventListener = (evt: any): void => {\n      removeListeners()\n      reject(evt.detail)\n    }\n\n    const abortListener = (): void => {\n      removeListeners()\n      reject(error)\n    }\n\n    signal?.addEventListener('abort', abortListener)\n    emitter.addEventListener(eventName, eventListener)\n\n    if (opts?.errorEvent != null) {\n      emitter.addEventListener(opts.errorEvent, errorEventListener)\n    }\n  })\n}\n", "export class QueueFullError extends Error {\n  static name = 'QueueFullError'\n\n  constructor (message: string = 'The queue was full') {\n    super(message)\n    this.name = 'QueueFullError'\n  }\n}\n", "/**\n * An abort error class that extends error\n */\nexport class AbortError extends Error {\n  public type: string\n  public code: string | string\n\n  constructor (message?: string, code?: string, name?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.name = name ?? 'AbortError'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface RaceSignalOptions {\n  /**\n   * The message for the error thrown if the signal aborts\n   */\n  errorMessage?: string\n\n  /**\n   * The code for the error thrown if the signal aborts\n   */\n  errorCode?: string\n\n  /**\n   * The name for the error thrown if the signal aborts\n   */\n  errorName?: string\n}\n\n/**\n * Race a promise against an abort signal\n */\nexport async function raceSignal <T> (promise: Promise<T>, signal?: AbortSignal, opts?: RaceSignalOptions): Promise<T> {\n  if (signal == null) {\n    return promise\n  }\n\n  if (signal.aborted) {\n    // the passed promise may yet resolve or reject but the use has signalled\n    // they are no longer interested so smother the error\n    promise.catch(() => {})\n    return Promise.reject(new AbortError(opts?.errorMessage, opts?.errorCode, opts?.errorName))\n  }\n\n  let listener\n\n  // create the error here so we have more context in the stack trace\n  const error = new AbortError(opts?.errorMessage, opts?.errorCode, opts?.errorName)\n\n  try {\n    return await Promise.race([\n      promise,\n      new Promise<T>((resolve, reject) => {\n        listener = () => {\n          reject(error)\n        }\n        signal.addEventListener('abort', listener)\n      })\n    ])\n  } finally {\n    if (listener != null) {\n      signal.removeEventListener('abort', listener)\n    }\n  }\n}\n", "import { AbortError } from 'abort-error'\n\nexport class JobRecipient<JobReturnType> {\n  public deferred: PromiseWithResolvers<JobReturnType>\n  public signal?: AbortSignal\n\n  constructor (signal?: AbortSignal) {\n    this.signal = signal\n    this.deferred = Promise.withResolvers()\n\n    this.onAbort = this.onAbort.bind(this)\n    this.signal?.addEventListener('abort', this.onAbort)\n  }\n\n  onAbort (): void {\n    this.deferred.reject(this.signal?.reason ?? new AbortError())\n  }\n\n  cleanup (): void {\n    this.signal?.removeEventListener('abort', this.onAbort)\n  }\n}\n", "import { AbortError } from 'abort-error'\nimport { setMaxListeners } from 'main-event'\nimport { raceSignal } from 'race-signal'\nimport { JobRecipient } from './recipient.js'\nimport type { JobStatus } from './index.js'\nimport type { AbortOptions } from 'abort-error'\n\n/**\n * Returns a random string\n */\nfunction randomId (): string {\n  return `${(parseInt(String(Math.random() * 1e9), 10)).toString()}${Date.now()}`\n}\n\nexport interface JobTimeline {\n  created: number\n  started?: number\n  finished?: number\n}\n\nexport class Job <JobOptions extends AbortOptions = AbortOptions, JobReturnType = unknown> {\n  public id: string\n  public fn: (options: JobOptions) => Promise<JobReturnType>\n  public options: JobOptions\n  public recipients: Array<JobRecipient<JobReturnType>>\n  public status: JobStatus\n  public readonly timeline: JobTimeline\n  private readonly controller: AbortController\n\n  constructor (fn: (options: JobOptions) => Promise<JobReturnType>, options: any) {\n    this.id = randomId()\n    this.status = 'queued'\n    this.fn = fn\n    this.options = options\n    this.recipients = []\n    this.timeline = {\n      created: Date.now()\n    }\n\n    this.controller = new AbortController()\n    setMaxListeners(Infinity, this.controller.signal)\n\n    this.onAbort = this.onAbort.bind(this)\n  }\n\n  abort (err: Error): void {\n    this.controller.abort(err)\n  }\n\n  onAbort (): void {\n    const allAborted = this.recipients.reduce((acc, curr) => {\n      return acc && (curr.signal?.aborted === true)\n    }, true)\n\n    // if all recipients have aborted the job, actually abort the job\n    if (allAborted) {\n      this.controller.abort(new AbortError())\n      this.cleanup()\n    }\n  }\n\n  async join (options: AbortOptions = {}): Promise<JobReturnType> {\n    const recipient = new JobRecipient<JobReturnType>(options.signal)\n    this.recipients.push(recipient)\n\n    options.signal?.addEventListener('abort', this.onAbort)\n\n    return recipient.deferred.promise\n  }\n\n  async run (): Promise<void> {\n    this.status = 'running'\n    this.timeline.started = Date.now()\n\n    try {\n      this.controller.signal.throwIfAborted()\n\n      const result = await raceSignal(this.fn({\n        ...(this.options ?? {}),\n        signal: this.controller.signal\n      }), this.controller.signal)\n\n      this.recipients.forEach(recipient => {\n        recipient.deferred.resolve(result)\n      })\n\n      this.status = 'complete'\n    } catch (err) {\n      this.recipients.forEach(recipient => {\n        recipient.deferred.reject(err)\n      })\n\n      this.status = 'errored'\n    } finally {\n      this.timeline.finished = Date.now()\n      this.cleanup()\n    }\n  }\n\n  cleanup (): void {\n    this.recipients.forEach(recipient => {\n      recipient.cleanup()\n      recipient.signal?.removeEventListener('abort', this.onAbort)\n    })\n  }\n}\n", "/**\n * A function with additional start/stop methods\n */\nexport interface DebouncedFunction {\n  (): void\n\n  start(): void\n  stop(): void\n}\n\n/**\n * Returns a function wrapper that will only call the passed function once\n *\n * Important - the passed function should not throw or reject\n */\nexport function debounce (func: () => void | Promise<void>, wait: number): DebouncedFunction {\n  let timeout: ReturnType<typeof setTimeout> | undefined\n\n  const output = function (): void {\n    const later = function (): void {\n      timeout = undefined\n      void func()\n    }\n\n    clearTimeout(timeout)\n    timeout = setTimeout(later, wait)\n  }\n  output.start = (): void => {}\n  output.stop = (): void => {\n    clearTimeout(timeout)\n  }\n\n  return output\n}\n", "/**\n * @packageDocumentation\n *\n * Based on `p-queue` but with access to the underlying queue, aborting a task\n * removes it from the queue and you can iterate over the queue results.\n *\n * @example\n *\n * ```ts\n * import all from 'it-all'\n * import { Queue } from 'it-queue'\n *\n * const queue = new Queue({\n *   concurrency: Infinity\n * })\n * void queue.add(async () => {\n *   return 'hello'\n * })\n * void queue.add(async () => {\n *   return 'world'\n * })\n *\n * const results = await all(queue)\n * // ['hello', 'world']\n *\n * // how many items are in the queue (includes running items)\n * console.info(queue.size)\n *\n * // how many items are running\n * console.info(queue.running)\n *\n * // how many items have not started running yet\n * console.info(queue.queued)\n * ```\n */\n\nimport { AbortError } from 'abort-error'\nimport { pushable } from 'it-pushable'\nimport { TypedEventEmitter } from 'main-event'\nimport { raceEvent } from 'race-event'\nimport { QueueFullError } from './errors.js'\nimport { Job } from './job.js'\nimport { debounce } from './utils.js'\nimport type { AbortOptions } from 'abort-error'\nexport type { Job, JobTimeline } from './job.js'\nexport type { JobRecipient } from './recipient.js'\n\nexport interface Comparator<T> {\n  (a: T, b: T): -1 | 0 | 1\n}\n\nexport interface QueueInit<JobReturnType, JobOptions extends AbortOptions = AbortOptions> {\n  /**\n   * Concurrency limit.\n   *\n   * Minimum: `1`.\n   *\n   * @default Infinity\n   */\n  concurrency?: number\n\n  /**\n   * If the queue size grows to larger than this number the promise returned\n   * from the add function will reject\n   *\n   * @default Infinity\n   */\n  maxSize?: number\n\n  /**\n   * An optional function that will sort the queue after a job has been added\n   */\n  sort?: Comparator<Job<JobOptions, JobReturnType>>\n\n  /**\n   * If false, `.start` will need to be called to start processing jobs\n   *\n   * @default true\n   */\n  autoStart?: boolean\n}\n\nexport type JobStatus = 'queued' | 'running' | 'errored' | 'complete'\n\nexport interface RunFunction<Options extends AbortOptions = AbortOptions, ReturnType = void> {\n  (options: Options): Promise<ReturnType>\n}\n\nexport interface JobMatcher<JobOptions extends AbortOptions = AbortOptions> {\n  (options?: Partial<JobOptions>): boolean\n}\n\nexport interface QueueJobSuccess<JobReturnType, JobOptions extends AbortOptions = AbortOptions> {\n  job: Job<JobOptions, JobReturnType>\n  result: JobReturnType\n}\n\nexport interface QueueJobFailure<JobReturnType, JobOptions extends AbortOptions = AbortOptions> {\n  job: Job<JobOptions, JobReturnType>\n  error: Error\n}\n\nexport interface QueueEvents<JobReturnType, JobOptions extends AbortOptions = AbortOptions> {\n  /**\n   * A job is about to start running\n   */\n  active: CustomEvent\n\n  /**\n   * All jobs have finished and the queue is empty\n   */\n  idle: CustomEvent\n\n  /**\n   * The queue is empty, jobs may be running\n   */\n  empty: CustomEvent\n\n  /**\n   * A job was added to the queue\n   */\n  add: CustomEvent\n\n  /**\n   * A job has finished or failed\n   */\n  next: CustomEvent\n\n  /**\n   * Emitted just after `\"completed\", a job has finished successfully - this\n   * event gives access to the job and it's result\n   */\n  success: CustomEvent<QueueJobSuccess<JobReturnType, JobOptions>>\n\n  /**\n   * A job has failed - this event gives access to the job and the thrown error\n   */\n  failure: CustomEvent<QueueJobFailure<JobReturnType, JobOptions>>\n}\n\n/**\n * Heavily influence by `p-queue` with the following differences:\n *\n * 1. Items remain at the head of the queue while they are running so `queue.size` includes `queue.pending` items - this is so interested parties can join the results of a queue item while it is running\n * 2. The options for a job are stored separately to the job in order for them to be modified while they are still in the queue\n * 3. If a job's abort signal fires before execution begins, it is removed from the queue immediately\n * 4. 'success'/'failure' events are emitted instead of 'error'/'complete'\n */\nexport class Queue<JobReturnType = unknown, JobOptions extends AbortOptions = AbortOptions> extends TypedEventEmitter<QueueEvents<JobReturnType, JobOptions>> {\n  public concurrency: number\n  public maxSize: number\n  public queue: Array<Job<JobOptions, JobReturnType>>\n  private pending: number\n  private readonly sort?: Comparator<Job<JobOptions, JobReturnType>>\n  private readonly autoStart: boolean\n\n  constructor (init: QueueInit<JobReturnType, JobOptions> = {}) {\n    super()\n\n    this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY\n    this.maxSize = init.maxSize ?? Number.POSITIVE_INFINITY\n    this.pending = 0\n    this.autoStart = init.autoStart ?? true\n\n    this.sort = init.sort\n    this.queue = []\n\n    this.emitEmpty = debounce(this.emitEmpty.bind(this), 1)\n    this.emitIdle = debounce(this.emitIdle.bind(this), 1)\n  }\n\n  [Symbol.asyncIterator] (): AsyncGenerator<JobReturnType, void, unknown> {\n    return this.toGenerator()\n  }\n\n  emitEmpty (): void {\n    if (this.size !== 0) {\n      return\n    }\n\n    this.safeDispatchEvent('empty')\n  }\n\n  emitIdle (): void {\n    if (this.running !== 0) {\n      return\n    }\n\n    this.safeDispatchEvent('idle')\n  }\n\n  private tryToStartAnother (): boolean {\n    if (this.size === 0) {\n      this.emitEmpty()\n\n      if (this.running === 0) {\n        this.emitIdle()\n      }\n\n      return false\n    }\n\n    if (this.pending < this.concurrency) {\n      let job: Job<JobOptions, JobReturnType> | undefined\n\n      for (const j of this.queue) {\n        if (j.status === 'queued') {\n          job = j\n          break\n        }\n      }\n\n      if (job == null) {\n        return false\n      }\n\n      this.safeDispatchEvent('active')\n\n      this.pending++\n\n      void job.run()\n        .finally(() => {\n          // remove the job from the queue\n          for (let i = 0; i < this.queue.length; i++) {\n            if (this.queue[i] === job) {\n              this.queue.splice(i, 1)\n              break\n            }\n          }\n\n          this.pending--\n          this.tryToStartAnother()\n          this.safeDispatchEvent('next')\n        })\n\n      return true\n    }\n\n    return false\n  }\n\n  private enqueue (job: Job<JobOptions, JobReturnType>): void {\n    this.queue.push(job)\n\n    if (this.sort != null) {\n      this.queue.sort(this.sort)\n    }\n  }\n\n  /**\n   * Start the queue. If the `autoStart` parameter passed to the constructor was\n   * not `false` this is a no-op\n   */\n  start () {\n    if (this.autoStart !== false) {\n      return\n    }\n\n    this.tryToStartAnother()\n  }\n\n  /**\n   * Adds a sync or async task to the queue. Always returns a promise.\n   */\n  async add (fn: RunFunction<JobOptions, JobReturnType>, options?: JobOptions): Promise<JobReturnType> {\n    options?.signal?.throwIfAborted()\n\n    if (this.size === this.maxSize) {\n      throw new QueueFullError()\n    }\n\n    const job = new Job<JobOptions, JobReturnType>(fn, options)\n    this.enqueue(job)\n    this.safeDispatchEvent('add')\n\n    if (this.autoStart) {\n      this.tryToStartAnother()\n    }\n\n    return job.join(options)\n      .then(result => {\n        this.safeDispatchEvent('success', { detail: { job, result } })\n\n        return result\n      })\n      .catch(err => {\n        if (job.status === 'queued') {\n          // job was aborted before it started - remove the job from the queue\n          for (let i = 0; i < this.queue.length; i++) {\n            if (this.queue[i] === job) {\n              this.queue.splice(i, 1)\n              break\n            }\n          }\n        }\n\n        this.safeDispatchEvent('failure', { detail: { job, error: err } })\n\n        throw err\n      })\n  }\n\n  /**\n   * Clear the queue\n   */\n  clear (): void {\n    this.queue.splice(0, this.queue.length)\n  }\n\n  /**\n   * Abort all jobs in the queue and clear it\n   */\n  abort (): void {\n    this.queue.forEach(job => {\n      job.abort(new AbortError())\n    })\n\n    this.clear()\n  }\n\n  /**\n   * Can be called multiple times. Useful if you for example add additional items at a later time.\n   *\n   * @returns A promise that settles when the queue becomes empty.\n   */\n  async onEmpty (options?: AbortOptions): Promise<void> {\n    // Instantly resolve if the queue is empty\n    if (this.size === 0) {\n      return\n    }\n\n    await raceEvent(this, 'empty', options?.signal)\n  }\n\n  /**\n   * @returns A promise that settles when the queue size is less than the given\n   * limit: `queue.size < limit`.\n   *\n   * If you want to avoid having the queue grow beyond a certain size you can\n   * `await queue.onSizeLessThan()` before adding a new item.\n   *\n   * Note that this only limits the number of items waiting to start. There\n   * could still be up to `concurrency` jobs already running that this call does\n   * not include in its calculation.\n   */\n  async onSizeLessThan (limit: number, options?: AbortOptions): Promise<void> {\n    // Instantly resolve if the queue is empty.\n    if (this.size < limit) {\n      return\n    }\n\n    await raceEvent(this, 'next', options?.signal, {\n      filter: () => this.size < limit\n    })\n  }\n\n  /**\n   * The difference with `.onEmpty` is that `.onIdle` guarantees that all work\n   * from the queue has finished. `.onEmpty` merely signals that the queue is\n   * empty, but it could mean that some promises haven't completed yet.\n   *\n   * @returns A promise that settles when the queue becomes empty, and all\n   * promises have completed; `queue.size === 0 && queue.pending === 0`.\n   */\n  async onIdle (options?: AbortOptions): Promise<void> {\n    // Instantly resolve if none pending and if nothing else is queued\n    if (this.pending === 0 && this.size === 0) {\n      return\n    }\n\n    await raceEvent(this, 'idle', options?.signal)\n  }\n\n  /**\n   * Size of the queue including running items\n   */\n  get size (): number {\n    return this.queue.length\n  }\n\n  /**\n   * The number of queued items waiting to run.\n   */\n  get queued (): number {\n    return this.queue.length - this.pending\n  }\n\n  /**\n   * The number of items currently running.\n   */\n  get running (): number {\n    return this.pending\n  }\n\n  /**\n   * Returns an async generator that makes it easy to iterate over the results\n   * of jobs added to the queue.\n   *\n   * The generator will end when the queue becomes idle, that is there are no\n   * jobs running and no jobs that have yet to run.\n   *\n   * If you need to keep the queue open indefinitely, consider using it-pushable\n   * instead.\n   */\n  async * toGenerator (options?: AbortOptions): AsyncGenerator<JobReturnType, void, unknown> {\n    options?.signal?.throwIfAborted()\n\n    const stream = pushable<JobReturnType>({\n      objectMode: true\n    })\n\n    const cleanup = (err?: Error): void => {\n      if (err != null) {\n        this.abort()\n      } else {\n        this.clear()\n      }\n\n      stream.end(err)\n    }\n\n    const onQueueJobComplete = (evt: CustomEvent<QueueJobSuccess<JobReturnType, JobOptions>>): void => {\n      if (evt.detail != null) {\n        stream.push(evt.detail.result)\n      }\n    }\n\n    const onQueueError = (evt: CustomEvent<QueueJobFailure<JobReturnType, JobOptions>>): void => {\n      cleanup(evt.detail.error)\n    }\n\n    const onQueueIdle = (): void => {\n      cleanup()\n    }\n\n    // clear the queue and throw if the query is aborted\n    const onSignalAbort = (): void => {\n      cleanup(new AbortError('Queue aborted'))\n    }\n\n    // add listeners\n    this.addEventListener('success', onQueueJobComplete)\n    this.addEventListener('failure', onQueueError)\n    this.addEventListener('idle', onQueueIdle)\n    options?.signal?.addEventListener('abort', onSignalAbort)\n\n    try {\n      yield * stream\n    } finally {\n      // remove listeners\n      this.removeEventListener('success', onQueueJobComplete)\n      this.removeEventListener('failure', onQueueError)\n      this.removeEventListener('idle', onQueueIdle)\n      options?.signal?.removeEventListener('abort', onSignalAbort)\n\n      // empty the queue for when the user has broken out of a loop early\n      cleanup()\n    }\n  }\n}\n", "export interface WebworkerEventListener <T = any> {\n  (worker: Worker, event: MessageEvent<T>): void\n}\n\nconst events: Record<string, WebworkerEventListener[]> = {}\n\nconst observable = (worker: Worker & { port?: any }) => {\n  worker.addEventListener('message', (event) => {\n    observable.dispatchEvent('message', worker, event)\n  })\n\n  if (worker.port != null) {\n    worker.port.addEventListener('message', (event: any) => {\n      observable.dispatchEvent('message', worker, event)\n    })\n  }\n}\n\nobservable.addEventListener = (type: string, fn: WebworkerEventListener) => {\n  if (events[type] == null) {\n    events[type] = []\n  }\n\n  events[type].push(fn)\n}\n\nobservable.removeEventListener = (type: string, fn: WebworkerEventListener) => {\n  if (events[type] == null) {\n    return\n  }\n\n  events[type] = events[type]\n    .filter(listener => listener === fn)\n}\n\nobservable.dispatchEvent = function (type: string, worker: Worker, event: MessageEvent<any>) {\n  if (events[type] == null) {\n    return\n  }\n\n  events[type].forEach(fn => fn(worker, event))\n}\n\nexport default observable\n", "export const WORKER_REQUEST_READ_LOCK = 'lock:worker:request-read'\nexport const WORKER_ABORT_READ_LOCK_REQUEST = 'lock:worker:abort-read-request'\nexport const WORKER_RELEASE_READ_LOCK = 'lock:worker:release-read'\nexport const MASTER_GRANT_READ_LOCK = 'lock:master:grant-read'\n\nexport const WORKER_REQUEST_WRITE_LOCK = 'lock:worker:request-write'\nexport const WORKER_ABORT_WRITE_LOCK_REQUEST = 'lock:worker:abort-write-request'\nexport const WORKER_RELEASE_WRITE_LOCK = 'lock:worker:release-write'\nexport const MASTER_GRANT_WRITE_LOCK = 'lock:master:grant-write'\n", "export const nanoid = (size: number = 10): string => {\n  return Math.random().toString().substring(2, size + 2)\n}\n", "import { AbortError } from 'abort-error'\nimport observer from 'observable-webworkers'\nimport {\n  WORKER_REQUEST_READ_LOCK,\n  WORKER_RELEASE_READ_LOCK,\n  MASTER_GRANT_READ_LOCK,\n  WORKER_REQUEST_WRITE_LOCK,\n  WORKER_RELEASE_WRITE_LOCK,\n  MASTER_GRANT_WRITE_LOCK,\n  WORKER_ABORT_READ_LOCK_REQUEST,\n  WORKER_ABORT_WRITE_LOCK_REQUEST\n} from './constants.js'\nimport { nanoid } from './utils.js'\nimport type { MorticeOptions, Release } from './index.js'\nimport type { AbortRequestType, MorticeImplementation, RequestType } from './interface.js'\nimport type { AbortOptions } from 'abort-error'\n\nconst handleWorkerLockRequest = (emitter: EventTarget, masterEvent: RequestType, abortMasterEvent: AbortRequestType, requestType: string, abortType: string, releaseType: string, grantType: string) => {\n  return (worker: Worker, event: MessageEvent) => {\n    if (event.data == null) {\n      return\n    }\n\n    const requestEvent = {\n      type: event.data.type,\n      name: event.data.name,\n      identifier: event.data.identifier\n    }\n\n    if (event.data.type === requestType) {\n      emitter.dispatchEvent(new MessageEvent(masterEvent, {\n        data: {\n          name: requestEvent.name,\n          handler: async (): Promise<void> => {\n            // grant lock to worker\n            worker.postMessage({\n              type: grantType,\n              name: requestEvent.name,\n              identifier: requestEvent.identifier\n            })\n\n            // wait for worker to finish\n            await new Promise<void>((resolve) => {\n              const releaseEventListener = (event: MessageEvent): void => {\n                if (event?.data == null) {\n                  return\n                }\n\n                const releaseEvent = {\n                  type: event.data.type,\n                  name: event.data.name,\n                  identifier: event.data.identifier\n                }\n\n                if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {\n                  worker.removeEventListener('message', releaseEventListener)\n                  resolve()\n                }\n              }\n\n              worker.addEventListener('message', releaseEventListener)\n            })\n          }\n        }\n      }))\n    }\n\n    if (requestEvent.type === abortType) {\n      // tell worker we are no longer interested in the lock\n      worker.postMessage({\n        type: abortType,\n        name: requestEvent.name,\n        identifier: requestEvent.identifier\n      })\n\n      emitter.dispatchEvent(new MessageEvent(abortMasterEvent, {\n        data: {\n          name: requestEvent.name\n        }\n      }))\n    }\n  }\n}\n\nconst makeWorkerLockRequest = (name: string, requestType: string, abortType: string, grantType: string, releaseType: string) => {\n  return async (options?: AbortOptions) => {\n    options?.signal?.throwIfAborted()\n    const id = nanoid()\n\n    globalThis.postMessage({\n      type: requestType,\n      identifier: id,\n      name\n    })\n\n    return new Promise<Release>((resolve, reject) => {\n      const abortListener = (): void => {\n        process.send?.({\n          type: abortType,\n          identifier: id,\n          name\n        })\n\n        reject(new AbortError())\n      }\n\n      options?.signal?.addEventListener('abort', abortListener, {\n        once: true\n      })\n\n      const listener = (event: MessageEvent): void => {\n        if (event?.data == null) {\n          return\n        }\n\n        const responseEvent = {\n          type: event.data.type,\n          identifier: event.data.identifier\n        }\n\n        if (responseEvent.type === grantType && responseEvent.identifier === id) {\n          globalThis.removeEventListener('message', listener)\n          options?.signal?.removeEventListener('abort', abortListener)\n\n          // grant lock\n          resolve(() => {\n            // release lock\n            globalThis.postMessage({\n              type: releaseType,\n              identifier: id,\n              name\n            })\n          })\n        }\n      }\n\n      globalThis.addEventListener('message', listener)\n    })\n  }\n}\n\nconst defaultOptions = {\n  singleProcess: false\n}\n\nexport default (options: Required<MorticeOptions>): MorticeImplementation | EventTarget => {\n  options = Object.assign({}, defaultOptions, options)\n  const isPrimary = Boolean(globalThis.document) || options.singleProcess\n\n  if (isPrimary) {\n    const emitter = new EventTarget()\n\n    observer.addEventListener('message', handleWorkerLockRequest(emitter, 'requestReadLock', 'abortReadLockRequest', WORKER_REQUEST_READ_LOCK, WORKER_ABORT_READ_LOCK_REQUEST, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK))\n    observer.addEventListener('message', handleWorkerLockRequest(emitter, 'requestWriteLock', 'abortWriteLockRequest', WORKER_REQUEST_WRITE_LOCK, WORKER_ABORT_WRITE_LOCK_REQUEST, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK))\n\n    return emitter\n  }\n\n  return {\n    isWorker: true,\n    readLock: (name) => makeWorkerLockRequest(name, WORKER_REQUEST_READ_LOCK, WORKER_ABORT_READ_LOCK_REQUEST, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),\n    writeLock: (name) => makeWorkerLockRequest(name, WORKER_REQUEST_WRITE_LOCK, WORKER_ABORT_WRITE_LOCK_REQUEST, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)\n  }\n}\n"],
+  "mappings": "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",
+  "names": ["index_exports", "__export", "createMortice", "AbortError", "message", "rest", "pDefer", "deferred", "resolve", "reject", "FixedFIFO", "hwm", "data", "last", "FIFO", "options", "obj", "val", "prev", "next", "AbortError", "message", "code", "pushable", "options", "_pushable", "buffer", "next", "_pushable", "getNext", "options", "onEnd", "buffer", "FIFO", "pushable", "onNext", "ended", "drain", "pDefer", "waitNext", "resolve", "reject", "next", "err", "bufferNext", "bufferError", "push", "value", "end", "_return", "_throw", "signal", "cancel", "listener", "AbortError", "opts", "TypedEventEmitter", "#listeners", "type", "listeners", "listener", "options", "list", "callback", "event", "result", "once", "detail", "AbortError", "message", "code", "raceEvent", "emitter", "eventName", "signal", "opts", "error", "resolve", "reject", "removeListeners", "abortListener", "eventListener", "errorEventListener", "evt", "err", "QueueFullError", "message", "AbortError", "message", "code", "name", "raceSignal", "promise", "signal", "opts", "listener", "error", "resolve", "reject", "JobRecipient", "signal", "AbortError", "randomId", "Job", "fn", "options", "err", "acc", "curr", "AbortError", "recipient", "JobRecipient", "result", "raceSignal", "debounce", "func", "wait", "timeout", "output", "later", "Queue", "TypedEventEmitter", "init", "debounce", "job", "j", "i", "fn", "options", "QueueFullError", "Job", "result", "err", "AbortError", "raceEvent", "limit", "stream", "pushable", "cleanup", "onQueueJobComplete", "evt", "onQueueError", "onQueueIdle", "onSignalAbort", "events", "observable", "worker", "event", "type", "fn", "listener", "src_default", "WORKER_REQUEST_READ_LOCK", "WORKER_ABORT_READ_LOCK_REQUEST", "WORKER_RELEASE_READ_LOCK", "MASTER_GRANT_READ_LOCK", "WORKER_REQUEST_WRITE_LOCK", "WORKER_ABORT_WRITE_LOCK_REQUEST", "WORKER_RELEASE_WRITE_LOCK", "MASTER_GRANT_WRITE_LOCK", "nanoid", "size", "handleWorkerLockRequest", "emitter", "masterEvent", "abortMasterEvent", "requestType", "abortType", "releaseType", "grantType", "worker", "event", "requestEvent", "resolve", "releaseEventListener", "releaseEvent", "makeWorkerLockRequest", "name", "options", "id", "nanoid", "reject", "abortListener", "AbortError", "listener", "responseEvent", "defaultOptions", "browser_default", "src_default", "WORKER_REQUEST_READ_LOCK", "WORKER_ABORT_READ_LOCK_REQUEST", "WORKER_RELEASE_READ_LOCK", "MASTER_GRANT_READ_LOCK", "WORKER_REQUEST_WRITE_LOCK", "WORKER_ABORT_WRITE_LOCK_REQUEST", "WORKER_RELEASE_WRITE_LOCK", "MASTER_GRANT_WRITE_LOCK", "mutexes", "implementation", "createReleaseable", "queue", "options", "res", "rej", "p", "resolve", "reject", "listener", "AbortError", "err", "createMutex", "name", "masterQueue", "Queue", "readQueue", "opts", "localReadQueue", "readPromise", "defaultOptions", "createMortice", "browser_default", "event", "mutexName", "abortController", "abortListener", "release"]
 }
diff --git a/node_modules/mortice/dist/src/index.d.ts b/node_modules/mortice/dist/src/index.d.ts
index b59ecb7..f15747a 100644
--- a/node_modules/mortice/dist/src/index.d.ts
+++ b/node_modules/mortice/dist/src/index.d.ts
@@ -98,7 +98,26 @@
  * // write something
  * release()
  * ```
+ *
+ * ## Cleanup
+ *
+ * If creating temporary mutexes, the `.cleanUp` function should be called when
+ * the mutex is no longer required.
+ *
+ * This must be done in the execution context that controls the mutex (normally
+ * the main or renderer thread), calling it in a worker is a no-op.
+ *
+ * ```javascript
+ * import mortice from 'mortice'
+ *
+ * const mutex = mortice()
+ *
+ * // ...some time later
+ *
+ * mutex.cleanUp()
+ * ```
  */
+import { Queue } from 'it-queue';
 import type { AbortOptions } from 'abort-error';
 export interface MorticeOptions {
     /**
@@ -123,8 +142,30 @@ export interface MorticeOptions {
     singleProcess?: boolean;
 }
 export interface Mortice {
+    /**
+     * Acquire a read lock. Multiple reads will occur simultaneously up to the
+     * concurrency limit passed to the constructor.
+     */
     readLock(options?: AbortOptions): Promise<Release>;
+    /**
+     * Acquire a write lock. The write lock will wait for any in-flight reads to
+     * complete, then prevent any further reads or writes until the lock is
+     * released.
+     */
     writeLock(options?: AbortOptions): Promise<Release>;
+    /**
+     * Removes this mutex from the global state, after invoking this method it
+     * cannot be used any more.
+     *
+     * It must be called in the owning context, calling this method in a worker
+     * is a no-op.
+     */
+    cleanUp(): void;
+    /**
+     * If this is the main thread, the state of the read/write queue may be
+     * inspected here
+     */
+    queue?: Queue;
 }
 export interface Release {
     (): void;
diff --git a/node_modules/mortice/dist/src/index.d.ts.map b/node_modules/mortice/dist/src/index.d.ts.map
index 9096941..439dc5c 100644
--- a/node_modules/mortice/dist/src/index.d.ts.map
+++ b/node_modules/mortice/dist/src/index.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAoGG;AAKH,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,aAAa,CAAA;AAE/C,MAAM,WAAW,cAAc;IAC7B;;OAEG;IACH,IAAI,CAAC,EAAE,MAAM,CAAA;IAEb;;;;OAIG;IACH,WAAW,CAAC,EAAE,MAAM,CAAA;IAEpB;;;;;;;;OAQG;IACH,aAAa,CAAC,EAAE,OAAO,CAAA;CACxB;AAED,MAAM,WAAW,OAAO;IACtB,QAAQ,CAAC,OAAO,CAAC,EAAE,YAAY,GAAG,OAAO,CAAC,OAAO,CAAC,CAAA;IAClD,SAAS,CAAC,OAAO,CAAC,EAAE,YAAY,GAAG,OAAO,CAAC,OAAO,CAAC,CAAA;CACpD;AAED,MAAM,WAAW,OAAO;IACtB,IAAI,IAAI,CAAA;CACT;AA2GD,MAAM,CAAC,OAAO,UAAU,aAAa,CAAE,OAAO,CAAC,EAAE,cAAc,GAAG,OAAO,CA+ExE"}
\ No newline at end of file
+{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAsHG;AAGH,OAAO,EAAE,KAAK,EAAE,MAAM,UAAU,CAAA;AAEhC,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,aAAa,CAAA;AAE/C,MAAM,WAAW,cAAc;IAC7B;;OAEG;IACH,IAAI,CAAC,EAAE,MAAM,CAAA;IAEb;;;;OAIG;IACH,WAAW,CAAC,EAAE,MAAM,CAAA;IAEpB;;;;;;;;OAQG;IACH,aAAa,CAAC,EAAE,OAAO,CAAA;CACxB;AAED,MAAM,WAAW,OAAO;IACtB;;;OAGG;IACH,QAAQ,CAAC,OAAO,CAAC,EAAE,YAAY,GAAG,OAAO,CAAC,OAAO,CAAC,CAAA;IAElD;;;;OAIG;IACH,SAAS,CAAC,OAAO,CAAC,EAAE,YAAY,GAAG,OAAO,CAAC,OAAO,CAAC,CAAA;IAEnD;;;;;;OAMG;IACH,OAAO,IAAI,IAAI,CAAA;IAEf;;;OAGG;IACH,KAAK,CAAC,EAAE,KAAK,CAAA;CACd;AAED,MAAM,WAAW,OAAO;IACtB,IAAI,IAAI,CAAA;CACT;AAkHD,MAAM,CAAC,OAAO,UAAU,aAAa,CAAE,OAAO,CAAC,EAAE,cAAc,GAAG,OAAO,CA+ExE"}
\ No newline at end of file
diff --git a/node_modules/mortice/dist/src/index.js b/node_modules/mortice/dist/src/index.js
index 2c826fe..e48b951 100644
--- a/node_modules/mortice/dist/src/index.js
+++ b/node_modules/mortice/dist/src/index.js
@@ -98,9 +98,27 @@
  * // write something
  * release()
  * ```
+ *
+ * ## Cleanup
+ *
+ * If creating temporary mutexes, the `.cleanUp` function should be called when
+ * the mutex is no longer required.
+ *
+ * This must be done in the execution context that controls the mutex (normally
+ * the main or renderer thread), calling it in a worker is a no-op.
+ *
+ * ```javascript
+ * import mortice from 'mortice'
+ *
+ * const mutex = mortice()
+ *
+ * // ...some time later
+ *
+ * mutex.cleanUp()
+ * ```
  */
 import { AbortError } from 'abort-error';
-import PQueue from 'p-queue';
+import { Queue } from 'it-queue';
 import impl from './node.js';
 const mutexes = {};
 let implementation;
@@ -136,10 +154,13 @@ const createMutex = (name, options) => {
     if (implementation.isWorker === true) {
         return {
             readLock: implementation.readLock(name, options),
-            writeLock: implementation.writeLock(name, options)
+            writeLock: implementation.writeLock(name, options),
+            cleanUp: () => { }
         };
     }
-    const masterQueue = new PQueue({ concurrency: 1 });
+    const masterQueue = new Queue({
+        concurrency: 1
+    });
     let readQueue;
     return {
         async readLock(opts) {
@@ -148,7 +169,7 @@ const createMutex = (name, options) => {
                 return createReleaseable(readQueue, opts);
             }
             // Create a new read queue
-            readQueue = new PQueue({
+            readQueue = new Queue({
                 concurrency: options.concurrency,
                 autoStart: false
             });
@@ -177,7 +198,11 @@ const createMutex = (name, options) => {
             // released
             readQueue = null;
             return createReleaseable(masterQueue, opts);
-        }
+        },
+        cleanUp: () => {
+            delete mutexes[name];
+        },
+        queue: masterQueue
     };
 };
 const defaultOptions = {
diff --git a/node_modules/mortice/dist/src/index.js.map b/node_modules/mortice/dist/src/index.js.map
index ce933fa..2a753cf 100644
--- a/node_modules/mortice/dist/src/index.js.map
+++ b/node_modules/mortice/dist/src/index.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/browser.d.ts b/node_modules/mortice/dist/test/browser.d.ts
new file mode 100644
index 0000000..9eeeeee
--- /dev/null
+++ b/node_modules/mortice/dist/test/browser.d.ts
@@ -0,0 +1,3 @@
+import './index.test.js';
+import './webworkers.test.js';
+//# sourceMappingURL=browser.d.ts.map
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/browser.d.ts.map b/node_modules/mortice/dist/test/browser.d.ts.map
new file mode 100644
index 0000000..e00bb88
--- /dev/null
+++ b/node_modules/mortice/dist/test/browser.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"browser.d.ts","sourceRoot":"","sources":["../../test/browser.ts"],"names":[],"mappings":"AAAA,OAAO,iBAAiB,CAAA;AACxB,OAAO,sBAAsB,CAAA"}
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/browser.js b/node_modules/mortice/dist/test/browser.js
new file mode 100644
index 0000000..f6f8a83
--- /dev/null
+++ b/node_modules/mortice/dist/test/browser.js
@@ -0,0 +1,3 @@
+import './index.test.js';
+import './webworkers.test.js';
+//# sourceMappingURL=browser.js.map
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/browser.js.map b/node_modules/mortice/dist/test/browser.js.map
new file mode 100644
index 0000000..6eaf6ea
--- /dev/null
+++ b/node_modules/mortice/dist/test/browser.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"browser.js","sourceRoot":"","sources":["../../test/browser.ts"],"names":[],"mappings":"AAAA,OAAO,iBAAiB,CAAA;AACxB,OAAO,sBAAsB,CAAA"}
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/cluster.test.d.ts b/node_modules/mortice/dist/test/cluster.test.d.ts
new file mode 100644
index 0000000..e4b6d51
--- /dev/null
+++ b/node_modules/mortice/dist/test/cluster.test.d.ts
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=cluster.test.d.ts.map
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/cluster.test.d.ts.map b/node_modules/mortice/dist/test/cluster.test.d.ts.map
new file mode 100644
index 0000000..a257f2b
--- /dev/null
+++ b/node_modules/mortice/dist/test/cluster.test.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"cluster.test.d.ts","sourceRoot":"","sources":["../../test/cluster.test.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/cluster.test.js b/node_modules/mortice/dist/test/cluster.test.js
new file mode 100644
index 0000000..ff39f6f
--- /dev/null
+++ b/node_modules/mortice/dist/test/cluster.test.js
@@ -0,0 +1,65 @@
+import { expect } from 'aegir/chai';
+import { isNode, isElectronMain } from 'wherearewe';
+describe('cluster', () => {
+    if (!isNode && !isElectronMain) {
+        return it.skip('cluster tests only run on node');
+    }
+    let exec;
+    before(async () => {
+        const { execa } = await import('execa');
+        exec = execa;
+    });
+    it('executes locks in correct order across a cluster', async () => {
+        const output = await exec('node', ['dist/test/fixtures/cluster.js'], {
+            stderr: process.stderr
+        });
+        const result = JSON.parse(output.stdout);
+        expect(result).to.deep.equal([
+            'write 1 waiting',
+            'read 1 waiting',
+            'read 2 waiting',
+            'read 3 waiting',
+            'write 2 waiting',
+            'read 4 waiting',
+            'write 1 start',
+            'write 1 complete',
+            'read 1 start',
+            'read 1 complete',
+            'read 2 start',
+            'read 2 complete',
+            'read 3 start',
+            'read 3 complete',
+            'write 2 start',
+            'write 2 complete',
+            'read 4 start',
+            'read 4 complete'
+        ]);
+    });
+    it('executes locks in correct order across a cluster in a single process', async () => {
+        const output = await exec('node', ['dist/test/fixtures/cluster-single-thread.js'], {
+            stderr: process.stderr
+        });
+        const result = JSON.parse(output.stdout);
+        expect(result).to.deep.equal([
+            'write 1 waiting',
+            'read 1 waiting',
+            'read 2 waiting',
+            'read 3 waiting',
+            'write 2 waiting',
+            'read 4 waiting',
+            'write 1 start',
+            'write 1 complete',
+            'read 1 start',
+            'read 1 complete',
+            'read 2 start',
+            'read 2 complete',
+            'read 3 start',
+            'read 3 complete',
+            'write 2 start',
+            'write 2 complete',
+            'read 4 start',
+            'read 4 complete'
+        ]);
+    });
+});
+//# sourceMappingURL=cluster.test.js.map
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/cluster.test.js.map b/node_modules/mortice/dist/test/cluster.test.js.map
new file mode 100644
index 0000000..34f66eb
--- /dev/null
+++ b/node_modules/mortice/dist/test/cluster.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"cluster.test.js","sourceRoot":"","sources":["../../test/cluster.test.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,MAAM,YAAY,CAAA;AACnC,OAAO,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,YAAY,CAAA;AAEnD,QAAQ,CAAC,SAAS,EAAE,GAAG,EAAE;IACvB,IAAI,CAAC,MAAM,IAAI,CAAC,cAAc,EAAE,CAAC;QAC/B,OAAO,EAAE,CAAC,IAAI,CAAC,gCAAgC,CAAC,CAAA;IAClD,CAAC;IAED,IAAI,IAAS,CAAA;IAEb,MAAM,CAAC,KAAK,IAAI,EAAE;QAChB,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,MAAM,CAAC,OAAO,CAAC,CAAA;QACvC,IAAI,GAAG,KAAK,CAAA;IACd,CAAC,CAAC,CAAA;IAEF,EAAE,CAAC,kDAAkD,EAAE,KAAK,IAAI,EAAE;QAChE,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,MAAM,EAAE,CAAC,+BAA+B,CAAC,EAAE;YACnE,MAAM,EAAE,OAAO,CAAC,MAAM;SACvB,CAAC,CAAA;QACF,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,CAAA;QAExC,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC;YAC3B,iBAAiB;YACjB,gBAAgB;YAChB,gBAAgB;YAChB,gBAAgB;YAChB,iBAAiB;YACjB,gBAAgB;YAChB,eAAe;YACf,kBAAkB;YAClB,cAAc;YACd,iBAAiB;YACjB,cAAc;YACd,iBAAiB;YACjB,cAAc;YACd,iBAAiB;YACjB,eAAe;YACf,kBAAkB;YAClB,cAAc;YACd,iBAAiB;SAClB,CAAC,CAAA;IACJ,CAAC,CAAC,CAAA;IAEF,EAAE,CAAC,sEAAsE,EAAE,KAAK,IAAI,EAAE;QACpF,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,MAAM,EAAE,CAAC,6CAA6C,CAAC,EAAE;YACjF,MAAM,EAAE,OAAO,CAAC,MAAM;SACvB,CAAC,CAAA;QACF,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,CAAA;QAExC,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC;YAC3B,iBAAiB;YACjB,gBAAgB;YAChB,gBAAgB;YAChB,gBAAgB;YAChB,iBAAiB;YACjB,gBAAgB;YAChB,eAAe;YACf,kBAAkB;YAClB,cAAc;YACd,iBAAiB;YACjB,cAAc;YACd,iBAAiB;YACjB,cAAc;YACd,iBAAiB;YACjB,eAAe;YACf,kBAAkB;YAClB,cAAc;YACd,iBAAiB;SAClB,CAAC,CAAA;IACJ,CAAC,CAAC,CAAA;AACJ,CAAC,CAAC,CAAA"}
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/fixtures/cluster-single-thread.d.ts b/node_modules/mortice/dist/test/fixtures/cluster-single-thread.d.ts
new file mode 100644
index 0000000..fbe2596
--- /dev/null
+++ b/node_modules/mortice/dist/test/fixtures/cluster-single-thread.d.ts
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=cluster-single-thread.d.ts.map
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/fixtures/cluster-single-thread.d.ts.map b/node_modules/mortice/dist/test/fixtures/cluster-single-thread.d.ts.map
new file mode 100644
index 0000000..a0cf944
--- /dev/null
+++ b/node_modules/mortice/dist/test/fixtures/cluster-single-thread.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"cluster-single-thread.d.ts","sourceRoot":"","sources":["../../../test/fixtures/cluster-single-thread.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/fixtures/cluster-single-thread.js b/node_modules/mortice/dist/test/fixtures/cluster-single-thread.js
new file mode 100644
index 0000000..5813b6e
--- /dev/null
+++ b/node_modules/mortice/dist/test/fixtures/cluster-single-thread.js
@@ -0,0 +1,35 @@
+import cluster from 'cluster';
+import mortice from '../../src/index.js';
+import { lock } from './lock.js';
+async function run() {
+    const mutex = mortice({
+        singleProcess: true
+    });
+    const counts = {
+        read: 0,
+        write: 0
+    };
+    const result = [];
+    if (cluster.isPrimary) {
+        cluster.on('message', (worker, message) => {
+            if (message.type === 'done') {
+                worker.kill();
+                console.info(JSON.stringify(message.result)); // eslint-disable-line no-console
+            }
+        });
+        cluster.fork();
+    }
+    else {
+        // queue up read/write requests, the third read should block the second write
+        void lock('write', mutex, counts, result);
+        void lock('read', mutex, counts, result);
+        void lock('read', mutex, counts, result);
+        void lock('read', mutex, counts, result, 500);
+        void lock('write', mutex, counts, result);
+        await lock('read', mutex, counts, result);
+        // @ts-expect-error only available in worker threads
+        process.send({ type: 'done', result });
+    }
+}
+void run();
+//# sourceMappingURL=cluster-single-thread.js.map
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/fixtures/cluster-single-thread.js.map b/node_modules/mortice/dist/test/fixtures/cluster-single-thread.js.map
new file mode 100644
index 0000000..8e4b3b5
--- /dev/null
+++ b/node_modules/mortice/dist/test/fixtures/cluster-single-thread.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"cluster-single-thread.js","sourceRoot":"","sources":["../../../test/fixtures/cluster-single-thread.ts"],"names":[],"mappings":"AAAA,OAAO,OAAO,MAAM,SAAS,CAAA;AAC7B,OAAO,OAAO,MAAM,oBAAoB,CAAA;AACxC,OAAO,EAAE,IAAI,EAAE,MAAM,WAAW,CAAA;AAEhC,KAAK,UAAU,GAAG;IAChB,MAAM,KAAK,GAAG,OAAO,CAAC;QACpB,aAAa,EAAE,IAAI;KACpB,CAAC,CAAA;IACF,MAAM,MAAM,GAAG;QACb,IAAI,EAAE,CAAC;QACP,KAAK,EAAE,CAAC;KACT,CAAA;IACD,MAAM,MAAM,GAAa,EAAE,CAAA;IAE3B,IAAI,OAAO,CAAC,SAAS,EAAE,CAAC;QACtB,OAAO,CAAC,EAAE,CAAC,SAAS,EAAE,CAAC,MAAM,EAAE,OAAO,EAAE,EAAE;YACxC,IAAI,OAAO,CAAC,IAAI,KAAK,MAAM,EAAE,CAAC;gBAC5B,MAAM,CAAC,IAAI,EAAE,CAAA;gBACb,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAA,CAAC,iCAAiC;YAChF,CAAC;QACH,CAAC,CAAC,CAAA;QAEF,OAAO,CAAC,IAAI,EAAE,CAAA;IAChB,CAAC;SAAM,CAAC;QACN,6EAA6E;QAC7E,KAAK,IAAI,CAAC,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC,CAAA;QACzC,KAAK,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC,CAAA;QACxC,KAAK,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC,CAAA;QACxC,KAAK,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,GAAG,CAAC,CAAA;QAC7C,KAAK,IAAI,CAAC,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC,CAAA;QACzC,MAAM,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC,CAAA;QAEzC,oDAAoD;QACpD,OAAO,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC,CAAA;IACxC,CAAC;AACH,CAAC;AAED,KAAK,GAAG,EAAE,CAAA"}
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/fixtures/cluster.d.ts b/node_modules/mortice/dist/test/fixtures/cluster.d.ts
new file mode 100644
index 0000000..738bd92
--- /dev/null
+++ b/node_modules/mortice/dist/test/fixtures/cluster.d.ts
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=cluster.d.ts.map
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/fixtures/cluster.d.ts.map b/node_modules/mortice/dist/test/fixtures/cluster.d.ts.map
new file mode 100644
index 0000000..5391254
--- /dev/null
+++ b/node_modules/mortice/dist/test/fixtures/cluster.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"cluster.d.ts","sourceRoot":"","sources":["../../../test/fixtures/cluster.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/fixtures/cluster.js b/node_modules/mortice/dist/test/fixtures/cluster.js
new file mode 100644
index 0000000..7803b48
--- /dev/null
+++ b/node_modules/mortice/dist/test/fixtures/cluster.js
@@ -0,0 +1,33 @@
+import cluster from 'cluster';
+import mortice from '../../src/index.js';
+import { lock } from './lock.js';
+async function run() {
+    const mutex = mortice();
+    const counts = {
+        read: 0,
+        write: 0
+    };
+    const result = [];
+    if (cluster.isPrimary) {
+        cluster.on('message', (worker, message) => {
+            if (message.type === 'done') {
+                worker.kill();
+                console.info(JSON.stringify(message.result)); // eslint-disable-line no-console
+            }
+        });
+        cluster.fork();
+    }
+    else {
+        // queue up read/write requests, the third read should block the second write
+        void lock('write', mutex, counts, result);
+        void lock('read', mutex, counts, result);
+        void lock('read', mutex, counts, result);
+        void lock('read', mutex, counts, result, 500);
+        void lock('write', mutex, counts, result);
+        await lock('read', mutex, counts, result);
+        // @ts-expect-error only available in worker threads
+        process.send({ type: 'done', result });
+    }
+}
+void run();
+//# sourceMappingURL=cluster.js.map
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/fixtures/cluster.js.map b/node_modules/mortice/dist/test/fixtures/cluster.js.map
new file mode 100644
index 0000000..35b5736
--- /dev/null
+++ b/node_modules/mortice/dist/test/fixtures/cluster.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"cluster.js","sourceRoot":"","sources":["../../../test/fixtures/cluster.ts"],"names":[],"mappings":"AAAA,OAAO,OAAO,MAAM,SAAS,CAAA;AAC7B,OAAO,OAAO,MAAM,oBAAoB,CAAA;AACxC,OAAO,EAAE,IAAI,EAAE,MAAM,WAAW,CAAA;AAEhC,KAAK,UAAU,GAAG;IAChB,MAAM,KAAK,GAAG,OAAO,EAAE,CAAA;IACvB,MAAM,MAAM,GAAG;QACb,IAAI,EAAE,CAAC;QACP,KAAK,EAAE,CAAC;KACT,CAAA;IACD,MAAM,MAAM,GAAa,EAAE,CAAA;IAE3B,IAAI,OAAO,CAAC,SAAS,EAAE,CAAC;QACtB,OAAO,CAAC,EAAE,CAAC,SAAS,EAAE,CAAC,MAAM,EAAE,OAAO,EAAE,EAAE;YACxC,IAAI,OAAO,CAAC,IAAI,KAAK,MAAM,EAAE,CAAC;gBAC5B,MAAM,CAAC,IAAI,EAAE,CAAA;gBACb,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAA,CAAC,iCAAiC;YAChF,CAAC;QACH,CAAC,CAAC,CAAA;QAEF,OAAO,CAAC,IAAI,EAAE,CAAA;IAChB,CAAC;SAAM,CAAC;QACN,6EAA6E;QAC7E,KAAK,IAAI,CAAC,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC,CAAA;QACzC,KAAK,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC,CAAA;QACxC,KAAK,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC,CAAA;QACxC,KAAK,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,GAAG,CAAC,CAAA;QAC7C,KAAK,IAAI,CAAC,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC,CAAA;QACzC,MAAM,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC,CAAA;QAEzC,oDAAoD;QACpD,OAAO,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC,CAAA;IACxC,CAAC;AACH,CAAC;AAED,KAAK,GAAG,EAAE,CAAA"}
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/fixtures/lock.d.ts b/node_modules/mortice/dist/test/fixtures/lock.d.ts
new file mode 100644
index 0000000..cd965c2
--- /dev/null
+++ b/node_modules/mortice/dist/test/fixtures/lock.d.ts
@@ -0,0 +1,7 @@
+import type { Mortice } from '../../src/index.js';
+export interface Counts {
+    read: number;
+    write: number;
+}
+export declare function lock(type: 'read' | 'write', mutex: Mortice, counts: Counts, result: string[], timeout?: number, signal?: AbortSignal): Promise<void>;
+//# sourceMappingURL=lock.d.ts.map
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/fixtures/lock.d.ts.map b/node_modules/mortice/dist/test/fixtures/lock.d.ts.map
new file mode 100644
index 0000000..d5c01e6
--- /dev/null
+++ b/node_modules/mortice/dist/test/fixtures/lock.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"lock.d.ts","sourceRoot":"","sources":["../../../test/fixtures/lock.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,OAAO,EAAE,MAAM,oBAAoB,CAAA;AAEjD,MAAM,WAAW,MAAM;IACrB,IAAI,EAAE,MAAM,CAAA;IACZ,KAAK,EAAE,MAAM,CAAA;CACd;AAED,wBAAsB,IAAI,CAAE,IAAI,EAAE,MAAM,GAAG,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,EAAE,OAAO,SAAI,EAAE,MAAM,CAAC,EAAE,WAAW,GAAG,OAAO,CAAC,IAAI,CAAC,CAmBtJ"}
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/fixtures/lock.js b/node_modules/mortice/dist/test/fixtures/lock.js
new file mode 100644
index 0000000..7a37a21
--- /dev/null
+++ b/node_modules/mortice/dist/test/fixtures/lock.js
@@ -0,0 +1,16 @@
+import delay from 'delay';
+export async function lock(type, mutex, counts, result, timeout = 0, signal) {
+    counts[type]++;
+    const index = counts[type];
+    result.push(`${type} ${index} waiting`);
+    const release = await mutex[`${type}Lock`]({
+        signal
+    });
+    result.push(`${type} ${index} start`);
+    if (timeout > 0) {
+        await delay(timeout);
+    }
+    result.push(`${type} ${index} complete`);
+    release();
+}
+//# sourceMappingURL=lock.js.map
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/fixtures/lock.js.map b/node_modules/mortice/dist/test/fixtures/lock.js.map
new file mode 100644
index 0000000..5963f18
--- /dev/null
+++ b/node_modules/mortice/dist/test/fixtures/lock.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"lock.js","sourceRoot":"","sources":["../../../test/fixtures/lock.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,MAAM,OAAO,CAAA;AAQzB,MAAM,CAAC,KAAK,UAAU,IAAI,CAAE,IAAsB,EAAE,KAAc,EAAE,MAAc,EAAE,MAAgB,EAAE,OAAO,GAAG,CAAC,EAAE,MAAoB;IACrI,MAAM,CAAC,IAAI,CAAC,EAAE,CAAA;IACd,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,CAAA;IAE1B,MAAM,CAAC,IAAI,CAAC,GAAG,IAAI,IAAI,KAAK,UAAU,CAAC,CAAA;IAEvC,MAAM,OAAO,GAAG,MAAM,KAAK,CAAC,GAAG,IAAI,MAAM,CAAC,CAAC;QACzC,MAAM;KACP,CAAC,CAAA;IAEF,MAAM,CAAC,IAAI,CAAC,GAAG,IAAI,IAAI,KAAK,QAAQ,CAAC,CAAA;IAErC,IAAI,OAAO,GAAG,CAAC,EAAE,CAAC;QAChB,MAAM,KAAK,CAAC,OAAO,CAAC,CAAA;IACtB,CAAC;IAED,MAAM,CAAC,IAAI,CAAC,GAAG,IAAI,IAAI,KAAK,WAAW,CAAC,CAAA;IAExC,OAAO,EAAE,CAAA;AACX,CAAC"}
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/fixtures/worker-single-thread.d.ts b/node_modules/mortice/dist/test/fixtures/worker-single-thread.d.ts
new file mode 100644
index 0000000..6d8556b
--- /dev/null
+++ b/node_modules/mortice/dist/test/fixtures/worker-single-thread.d.ts
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=worker-single-thread.d.ts.map
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/fixtures/worker-single-thread.d.ts.map b/node_modules/mortice/dist/test/fixtures/worker-single-thread.d.ts.map
new file mode 100644
index 0000000..1850660
--- /dev/null
+++ b/node_modules/mortice/dist/test/fixtures/worker-single-thread.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"worker-single-thread.d.ts","sourceRoot":"","sources":["../../../test/fixtures/worker-single-thread.ts"],"names":[],"mappings":"AAsCA,OAAO,EAAE,CAAA"}
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/fixtures/worker-single-thread.js b/node_modules/mortice/dist/test/fixtures/worker-single-thread.js
new file mode 100644
index 0000000..f3c19c7
--- /dev/null
+++ b/node_modules/mortice/dist/test/fixtures/worker-single-thread.js
@@ -0,0 +1,35 @@
+import mortice from '../../src/index.js';
+import { lock } from './lock.js';
+async function run() {
+    const mutex = mortice({
+        singleProcess: true
+    });
+    const counts = {
+        read: 0,
+        write: 0
+    };
+    const result = [];
+    void lock('write', mutex, counts, result);
+    void lock('read', mutex, counts, result);
+    void lock('read', mutex, counts, result);
+    void lock('read', mutex, counts, result, 500);
+    void lock('write', mutex, counts, result);
+    await lock('read', mutex, counts, result);
+    return result;
+}
+run().then((result = []) => {
+    globalThis.postMessage({
+        type: 'done',
+        result
+    });
+}, err => {
+    globalThis.postMessage({
+        type: 'error',
+        error: {
+            message: err.message,
+            stack: err.stack
+        }
+    });
+});
+export {};
+//# sourceMappingURL=worker-single-thread.js.map
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/fixtures/worker-single-thread.js.map b/node_modules/mortice/dist/test/fixtures/worker-single-thread.js.map
new file mode 100644
index 0000000..ad92742
--- /dev/null
+++ b/node_modules/mortice/dist/test/fixtures/worker-single-thread.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"worker-single-thread.js","sourceRoot":"","sources":["../../../test/fixtures/worker-single-thread.ts"],"names":[],"mappings":"AAAA,OAAO,OAAO,MAAM,oBAAoB,CAAA;AACxC,OAAO,EAAE,IAAI,EAAE,MAAM,WAAW,CAAA;AAEhC,KAAK,UAAU,GAAG;IAChB,MAAM,KAAK,GAAG,OAAO,CAAC;QACpB,aAAa,EAAE,IAAI;KACpB,CAAC,CAAA;IACF,MAAM,MAAM,GAAG;QACb,IAAI,EAAE,CAAC;QACP,KAAK,EAAE,CAAC;KACT,CAAA;IACD,MAAM,MAAM,GAAa,EAAE,CAAA;IAE3B,KAAK,IAAI,CAAC,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC,CAAA;IACzC,KAAK,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC,CAAA;IACxC,KAAK,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC,CAAA;IACxC,KAAK,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,GAAG,CAAC,CAAA;IAC7C,KAAK,IAAI,CAAC,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC,CAAA;IACzC,MAAM,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC,CAAA;IAEzC,OAAO,MAAM,CAAA;AACf,CAAC;AAED,GAAG,EAAE,CAAC,IAAI,CAAC,CAAC,SAAmB,EAAE,EAAE,EAAE;IACnC,UAAU,CAAC,WAAW,CAAC;QACrB,IAAI,EAAE,MAAM;QACZ,MAAM;KACP,CAAC,CAAA;AACJ,CAAC,EAAE,GAAG,CAAC,EAAE;IACP,UAAU,CAAC,WAAW,CAAC;QACrB,IAAI,EAAE,OAAO;QACb,KAAK,EAAE;YACL,OAAO,EAAE,GAAG,CAAC,OAAO;YACpB,KAAK,EAAE,GAAG,CAAC,KAAK;SACjB;KACF,CAAC,CAAA;AACJ,CAAC,CAAC,CAAA;AAEF,OAAO,EAAE,CAAA"}
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/fixtures/worker.d.ts b/node_modules/mortice/dist/test/fixtures/worker.d.ts
new file mode 100644
index 0000000..9ea2676
--- /dev/null
+++ b/node_modules/mortice/dist/test/fixtures/worker.d.ts
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=worker.d.ts.map
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/fixtures/worker.d.ts.map b/node_modules/mortice/dist/test/fixtures/worker.d.ts.map
new file mode 100644
index 0000000..0c24ee5
--- /dev/null
+++ b/node_modules/mortice/dist/test/fixtures/worker.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"worker.d.ts","sourceRoot":"","sources":["../../../test/fixtures/worker.ts"],"names":[],"mappings":"AAoCA,OAAO,EAAE,CAAA"}
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/fixtures/worker.js b/node_modules/mortice/dist/test/fixtures/worker.js
new file mode 100644
index 0000000..b99c3ab
--- /dev/null
+++ b/node_modules/mortice/dist/test/fixtures/worker.js
@@ -0,0 +1,33 @@
+import mortice from '../../src/index.js';
+import { lock } from './lock.js';
+async function run() {
+    const mutex = mortice();
+    const counts = {
+        read: 0,
+        write: 0
+    };
+    const result = [];
+    void lock('write', mutex, counts, result);
+    void lock('read', mutex, counts, result);
+    void lock('read', mutex, counts, result);
+    void lock('read', mutex, counts, result, 500);
+    void lock('write', mutex, counts, result);
+    await lock('read', mutex, counts, result);
+    return result;
+}
+run().then((result = []) => {
+    globalThis.postMessage({
+        type: 'done',
+        result
+    });
+}, err => {
+    globalThis.postMessage({
+        type: 'error',
+        error: {
+            message: err.message,
+            stack: err.stack
+        }
+    });
+});
+export {};
+//# sourceMappingURL=worker.js.map
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/fixtures/worker.js.map b/node_modules/mortice/dist/test/fixtures/worker.js.map
new file mode 100644
index 0000000..bf9effb
--- /dev/null
+++ b/node_modules/mortice/dist/test/fixtures/worker.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"worker.js","sourceRoot":"","sources":["../../../test/fixtures/worker.ts"],"names":[],"mappings":"AAAA,OAAO,OAAO,MAAM,oBAAoB,CAAA;AACxC,OAAO,EAAE,IAAI,EAAE,MAAM,WAAW,CAAA;AAEhC,KAAK,UAAU,GAAG;IAChB,MAAM,KAAK,GAAG,OAAO,EAAE,CAAA;IACvB,MAAM,MAAM,GAAG;QACb,IAAI,EAAE,CAAC;QACP,KAAK,EAAE,CAAC;KACT,CAAA;IACD,MAAM,MAAM,GAAa,EAAE,CAAA;IAE3B,KAAK,IAAI,CAAC,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC,CAAA;IACzC,KAAK,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC,CAAA;IACxC,KAAK,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC,CAAA;IACxC,KAAK,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,GAAG,CAAC,CAAA;IAC7C,KAAK,IAAI,CAAC,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC,CAAA;IACzC,MAAM,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC,CAAA;IAEzC,OAAO,MAAM,CAAA;AACf,CAAC;AAED,GAAG,EAAE,CAAC,IAAI,CAAC,CAAC,SAAmB,EAAE,EAAE,EAAE;IACnC,UAAU,CAAC,WAAW,CAAC;QACrB,IAAI,EAAE,MAAM;QACZ,MAAM;KACP,CAAC,CAAA;AACJ,CAAC,EAAE,GAAG,CAAC,EAAE;IACP,UAAU,CAAC,WAAW,CAAC;QACrB,IAAI,EAAE,OAAO;QACb,KAAK,EAAE;YACL,OAAO,EAAE,GAAG,CAAC,OAAO;YACpB,KAAK,EAAE,GAAG,CAAC,KAAK;SACjB;KACF,CAAC,CAAA;AACJ,CAAC,CAAC,CAAA;AAEF,OAAO,EAAE,CAAA"}
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/index.test.d.ts b/node_modules/mortice/dist/test/index.test.d.ts
new file mode 100644
index 0000000..121d59b
--- /dev/null
+++ b/node_modules/mortice/dist/test/index.test.d.ts
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=index.test.d.ts.map
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/index.test.d.ts.map b/node_modules/mortice/dist/test/index.test.d.ts.map
new file mode 100644
index 0000000..3f75274
--- /dev/null
+++ b/node_modules/mortice/dist/test/index.test.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"index.test.d.ts","sourceRoot":"","sources":["../../test/index.test.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/index.test.js b/node_modules/mortice/dist/test/index.test.js
new file mode 100644
index 0000000..89c3e25
--- /dev/null
+++ b/node_modules/mortice/dist/test/index.test.js
@@ -0,0 +1,190 @@
+import { expect } from 'aegir/chai';
+import delay from 'delay';
+import mortice from '../src/index.js';
+import { lock } from './fixtures/lock.js';
+describe('mortice', () => {
+    it('executes write', async () => {
+        const mutex = mortice();
+        const result = [];
+        const counts = {
+            read: 0,
+            write: 0
+        };
+        await lock('write', mutex, counts, result);
+        expect(result).to.deep.equal([
+            'write 1 waiting',
+            'write 1 start',
+            'write 1 complete'
+        ]);
+    });
+    it('executes read', async () => {
+        const mutex = mortice();
+        const result = [];
+        const counts = {
+            read: 0,
+            write: 0
+        };
+        await lock('read', mutex, counts, result);
+        expect(result).to.deep.equal([
+            'read 1 waiting',
+            'read 1 start',
+            'read 1 complete'
+        ]);
+    });
+    it('executes locks in correct order', async () => {
+        const mutex = mortice();
+        const result = [];
+        const counts = {
+            read: 0,
+            write: 0
+        };
+        // queue up read/write requests, the third read should block the second write
+        void lock('write', mutex, counts, result);
+        void lock('read', mutex, counts, result);
+        void lock('read', mutex, counts, result);
+        void lock('read', mutex, counts, result, 500);
+        void lock('write', mutex, counts, result);
+        await lock('read', mutex, counts, result);
+        expect(result).to.deep.equal([
+            'write 1 waiting',
+            'read 1 waiting',
+            'read 2 waiting',
+            'read 3 waiting',
+            'write 2 waiting',
+            'read 4 waiting',
+            'write 1 start',
+            'write 1 complete',
+            'read 1 start',
+            'read 1 complete',
+            'read 2 start',
+            'read 2 complete',
+            'read 3 start',
+            'read 3 complete',
+            'write 2 start',
+            'write 2 complete',
+            'read 4 start',
+            'read 4 complete'
+        ]);
+    });
+    it('executes read then waits to start write', async () => {
+        const mutex = mortice();
+        const result = [];
+        const counts = {
+            read: 0,
+            write: 0
+        };
+        // read should complete before write starts
+        void lock('read', mutex, counts, result, 500);
+        await lock('write', mutex, counts, result);
+        expect(result).to.deep.equal([
+            'read 1 waiting',
+            'write 1 waiting',
+            'read 1 start',
+            'read 1 complete',
+            'write 1 start',
+            'write 1 complete'
+        ]);
+    });
+    it('continues processing after error', async () => {
+        const mutex = mortice();
+        const result = [];
+        async function read(muxex) {
+            const release = await muxex.readLock();
+            try {
+                result.push('read 1');
+                throw new Error('err');
+            }
+            finally {
+                release();
+            }
+        }
+        async function write(muxex) {
+            const release = await muxex.writeLock();
+            await new Promise((resolve) => {
+                result.push('write 1');
+                resolve();
+            });
+            release();
+        }
+        // read should complete before write
+        void read(mutex).catch(() => { });
+        await write(mutex);
+        expect(result).to.deep.equal([
+            'read 1',
+            'write 1'
+        ]);
+    });
+    it('times out acquiring a read lock', async () => {
+        const mutex = mortice({
+            name: 'timeout-read'
+        });
+        void Promise.resolve().then(async () => {
+            const release = await mutex.writeLock();
+            try {
+                await new Promise(() => { });
+            }
+            finally {
+                release();
+            }
+        });
+        await delay(10);
+        await expect(mutex.readLock({
+            signal: AbortSignal.timeout(100)
+        })).to.eventually.be.rejected
+            .with.property('name', 'AbortError');
+    });
+    it('times out acquiring a write lock', async () => {
+        const mutex = mortice({
+            name: 'timeout-write'
+        });
+        void Promise.resolve().then(async () => {
+            const release = await mutex.readLock();
+            try {
+                await new Promise(() => { });
+            }
+            finally {
+                release();
+            }
+        });
+        await delay(10);
+        await expect(mutex.writeLock({
+            signal: AbortSignal.timeout(100)
+        })).to.eventually.be.rejected
+            .with.property('name', 'AbortError');
+    });
+    it('removes aborted lock requests that are queued', async () => {
+        const mutex = mortice({
+            name: 'remove-lock-request'
+        });
+        const result = [];
+        const counts = {
+            read: 0,
+            write: 0
+        };
+        const controller = new AbortController();
+        void lock('write', mutex, counts, result, 500);
+        void lock('write', mutex, counts, result, 500, controller.signal).catch(() => { });
+        void lock('write', mutex, counts, result, 500);
+        expect(mutex.queue?.size).to.equal(3);
+        controller.abort();
+        // not long enough for the first lock to be released
+        await delay(10);
+        expect(mutex.queue?.size).to.equal(2);
+    });
+    it('removes mutex from the global state', () => {
+        const name = 'clean-up-mutex';
+        const mutex1 = mortice({
+            name
+        });
+        const mutex2 = mortice({
+            name
+        });
+        expect(mutex1).to.equal(mutex2);
+        mutex1.cleanUp();
+        const mutex3 = mortice({
+            name
+        });
+        expect(mutex1).to.not.equal(mutex3);
+    });
+});
+//# sourceMappingURL=index.test.js.map
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/index.test.js.map b/node_modules/mortice/dist/test/index.test.js.map
new file mode 100644
index 0000000..fe7c769
--- /dev/null
+++ b/node_modules/mortice/dist/test/index.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"index.test.js","sourceRoot":"","sources":["../../test/index.test.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/node.d.ts b/node_modules/mortice/dist/test/node.d.ts
new file mode 100644
index 0000000..5b73d2f
--- /dev/null
+++ b/node_modules/mortice/dist/test/node.d.ts
@@ -0,0 +1,3 @@
+import './index.test.js';
+import './cluster.test.js';
+//# sourceMappingURL=node.d.ts.map
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/node.d.ts.map b/node_modules/mortice/dist/test/node.d.ts.map
new file mode 100644
index 0000000..474f03b
--- /dev/null
+++ b/node_modules/mortice/dist/test/node.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"node.d.ts","sourceRoot":"","sources":["../../test/node.ts"],"names":[],"mappings":"AAAA,OAAO,iBAAiB,CAAA;AACxB,OAAO,mBAAmB,CAAA"}
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/node.js b/node_modules/mortice/dist/test/node.js
new file mode 100644
index 0000000..e8af962
--- /dev/null
+++ b/node_modules/mortice/dist/test/node.js
@@ -0,0 +1,3 @@
+import './index.test.js';
+import './cluster.test.js';
+//# sourceMappingURL=node.js.map
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/node.js.map b/node_modules/mortice/dist/test/node.js.map
new file mode 100644
index 0000000..9861c4d
--- /dev/null
+++ b/node_modules/mortice/dist/test/node.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"node.js","sourceRoot":"","sources":["../../test/node.ts"],"names":[],"mappings":"AAAA,OAAO,iBAAiB,CAAA;AACxB,OAAO,mBAAmB,CAAA"}
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/webworkers.test.d.ts b/node_modules/mortice/dist/test/webworkers.test.d.ts
new file mode 100644
index 0000000..566e12e
--- /dev/null
+++ b/node_modules/mortice/dist/test/webworkers.test.d.ts
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=webworkers.test.d.ts.map
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/webworkers.test.d.ts.map b/node_modules/mortice/dist/test/webworkers.test.d.ts.map
new file mode 100644
index 0000000..15ed3b6
--- /dev/null
+++ b/node_modules/mortice/dist/test/webworkers.test.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"webworkers.test.d.ts","sourceRoot":"","sources":["../../test/webworkers.test.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/webworkers.test.js b/node_modules/mortice/dist/test/webworkers.test.js
new file mode 100644
index 0000000..c66b085
--- /dev/null
+++ b/node_modules/mortice/dist/test/webworkers.test.js
@@ -0,0 +1,76 @@
+import { expect } from 'aegir/chai';
+import observe from 'observable-webworkers';
+async function runWorker(path) {
+    return new Promise((resolve, reject) => {
+        const worker = new Worker(path, {
+            type: 'module'
+        });
+        observe(worker);
+        const messageListener = (worker, event) => {
+            if (event.data.type === 'log') {
+                console.info(event.data.message); // eslint-disable-line no-console
+            }
+            if (event.data.type === 'error') {
+                worker.terminate();
+                const err = new Error(event.data.error.message);
+                err.stack = event.data.error.stack;
+                reject(err);
+            }
+            if (event.data.type === 'done') {
+                worker.terminate();
+                resolve(event.data.result);
+            }
+        };
+        observe.addEventListener('message', messageListener);
+    });
+}
+describe('webworkers', function () {
+    if (globalThis.Worker == null) {
+        return it.skip('No worker support in environment');
+    }
+    it('execute locks in correct order', async () => {
+        await expect(runWorker('dist/worker.js')).to.eventually.deep.equal([
+            'write 1 waiting',
+            'read 1 waiting',
+            'read 2 waiting',
+            'read 3 waiting',
+            'write 2 waiting',
+            'read 4 waiting',
+            'write 1 start',
+            'write 1 complete',
+            'read 1 start',
+            'read 1 complete',
+            'read 2 start',
+            'read 2 complete',
+            'read 3 start',
+            'read 3 complete',
+            'write 2 start',
+            'write 2 complete',
+            'read 4 start',
+            'read 4 complete'
+        ]);
+    });
+    it('execute locks in correct order in a single thread', async () => {
+        await expect(runWorker('dist/worker.js')).to.eventually.deep.equal([
+            'write 1 waiting',
+            'read 1 waiting',
+            'read 2 waiting',
+            'read 3 waiting',
+            'write 2 waiting',
+            'read 4 waiting',
+            'write 1 start',
+            'write 1 complete',
+            'read 1 start',
+            'read 1 complete',
+            'read 2 start',
+            'read 2 complete',
+            'read 3 start',
+            'read 3 complete',
+            'write 2 start',
+            'write 2 complete',
+            'read 4 start',
+            'read 4 complete'
+        ]);
+    });
+});
+//# sourceMappingURL=webworkers.test.js.map
\ No newline at end of file
diff --git a/node_modules/mortice/dist/test/webworkers.test.js.map b/node_modules/mortice/dist/test/webworkers.test.js.map
new file mode 100644
index 0000000..2ecfffe
--- /dev/null
+++ b/node_modules/mortice/dist/test/webworkers.test.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"webworkers.test.js","sourceRoot":"","sources":["../../test/webworkers.test.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,MAAM,YAAY,CAAA;AACnC,OAAO,OAAO,MAAM,uBAAuB,CAAA;AAoB3C,KAAK,UAAU,SAAS,CAAE,IAAY;IACpC,OAAO,IAAI,OAAO,CAAW,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QAC/C,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,EAAE;YAC9B,IAAI,EAAE,QAAQ;SACf,CAAC,CAAA;QACF,OAAO,CAAC,MAAM,CAAC,CAAA;QAEf,MAAM,eAAe,GAAwC,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;YAC7E,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI,KAAK,KAAK,EAAE,CAAC;gBAC9B,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA,CAAC,iCAAiC;YACpE,CAAC;YAED,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE,CAAC;gBAChC,MAAM,CAAC,SAAS,EAAE,CAAA;gBAElB,MAAM,GAAG,GAAG,IAAI,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAA;gBAC/C,GAAG,CAAC,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAA;gBAElC,MAAM,CAAC,GAAG,CAAC,CAAA;YACb,CAAC;YAED,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI,KAAK,MAAM,EAAE,CAAC;gBAC/B,MAAM,CAAC,SAAS,EAAE,CAAA;gBAElB,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;YAC5B,CAAC;QACH,CAAC,CAAA;QAED,OAAO,CAAC,gBAAgB,CAAC,SAAS,EAAE,eAAe,CAAC,CAAA;IACtD,CAAC,CAAC,CAAA;AACJ,CAAC;AAED,QAAQ,CAAC,YAAY,EAAE;IACrB,IAAI,UAAU,CAAC,MAAM,IAAI,IAAI,EAAE,CAAC;QAC9B,OAAO,EAAE,CAAC,IAAI,CAAC,kCAAkC,CAAC,CAAA;IACpD,CAAC;IAED,EAAE,CAAC,gCAAgC,EAAE,KAAK,IAAI,EAAE;QAC9C,MAAM,MAAM,CAAC,SAAS,CAAC,gBAAgB,CAAC,CAAC,CAAC,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC;YACjE,iBAAiB;YACjB,gBAAgB;YAChB,gBAAgB;YAChB,gBAAgB;YAChB,iBAAiB;YACjB,gBAAgB;YAChB,eAAe;YACf,kBAAkB;YAClB,cAAc;YACd,iBAAiB;YACjB,cAAc;YACd,iBAAiB;YACjB,cAAc;YACd,iBAAiB;YACjB,eAAe;YACf,kBAAkB;YAClB,cAAc;YACd,iBAAiB;SAClB,CAAC,CAAA;IACJ,CAAC,CAAC,CAAA;IAEF,EAAE,CAAC,mDAAmD,EAAE,KAAK,IAAI,EAAE;QACjE,MAAM,MAAM,CAAC,SAAS,CAAC,gBAAgB,CAAC,CAAC,CAAC,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC;YACjE,iBAAiB;YACjB,gBAAgB;YAChB,gBAAgB;YAChB,gBAAgB;YAChB,iBAAiB;YACjB,gBAAgB;YAChB,eAAe;YACf,kBAAkB;YAClB,cAAc;YACd,iBAAiB;YACjB,cAAc;YACd,iBAAiB;YACjB,cAAc;YACd,iBAAiB;YACjB,eAAe;YACf,kBAAkB;YAClB,cAAc;YACd,iBAAiB;SAClB,CAAC,CAAA;IACJ,CAAC,CAAC,CAAA;AACJ,CAAC,CAAC,CAAA"}
\ No newline at end of file
diff --git a/node_modules/mortice/dist/tsconfig.tsbuildinfo b/node_modules/mortice/dist/tsconfig.tsbuildinfo
new file mode 100644
index 0000000..dcd3ee3
--- /dev/null
+++ b/node_modules/mortice/dist/tsconfig.tsbuildinfo
@@ -0,0 +1 @@
+{"fileNames":["../node_modules/typescript/lib/lib.es5.d.ts","../node_modules/typescript/lib/lib.es2015.d.ts","../node_modules/typescript/lib/lib.es2016.d.ts","../node_modules/typescript/lib/lib.es2017.d.ts","../node_modules/typescript/lib/lib.es2018.d.ts","../node_modules/typescript/lib/lib.es2019.d.ts","../node_modules/typescript/lib/lib.es2020.d.ts","../node_modules/typescript/lib/lib.es2021.d.ts","../node_modules/typescript/lib/lib.es2022.d.ts","../node_modules/typescript/lib/lib.es2023.d.ts","../node_modules/typescript/lib/lib.es2024.d.ts","../node_modules/typescript/lib/lib.dom.d.ts","../node_modules/typescript/lib/lib.dom.iterable.d.ts","../node_modules/typescript/lib/lib.webworker.d.ts","../node_modules/typescript/lib/lib.es2015.core.d.ts","../node_modules/typescript/lib/lib.es2015.collection.d.ts","../node_modules/typescript/lib/lib.es2015.generator.d.ts","../node_modules/typescript/lib/lib.es2015.iterable.d.ts","../node_modules/typescript/lib/lib.es2015.promise.d.ts","../node_modules/typescript/lib/lib.es2015.proxy.d.ts","../node_modules/typescript/lib/lib.es2015.reflect.d.ts","../node_modules/typescript/lib/lib.es2015.symbol.d.ts","../node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts","../node_modules/typescript/lib/lib.es2016.array.include.d.ts","../node_modules/typescript/lib/lib.es2016.intl.d.ts","../node_modules/typescript/lib/lib.es2017.arraybuffer.d.ts","../node_modules/typescript/lib/lib.es2017.date.d.ts","../node_modules/typescript/lib/lib.es2017.object.d.ts","../node_modules/typescript/lib/lib.es2017.sharedmemory.d.ts","../node_modules/typescript/lib/lib.es2017.string.d.ts","../node_modules/typescript/lib/lib.es2017.intl.d.ts","../node_modules/typescript/lib/lib.es2017.typedarrays.d.ts","../node_modules/typescript/lib/lib.es2018.asyncgenerator.d.ts","../node_modules/typescript/lib/lib.es2018.asynciterable.d.ts","../node_modules/typescript/lib/lib.es2018.intl.d.ts","../node_modules/typescript/lib/lib.es2018.promise.d.ts","../node_modules/typescript/lib/lib.es2018.regexp.d.ts","../node_modules/typescript/lib/lib.es2019.array.d.ts","../node_modules/typescript/lib/lib.es2019.object.d.ts","../node_modules/typescript/lib/lib.es2019.string.d.ts","../node_modules/typescript/lib/lib.es2019.symbol.d.ts","../node_modules/typescript/lib/lib.es2019.intl.d.ts","../node_modules/typescript/lib/lib.es2020.bigint.d.ts","../node_modules/typescript/lib/lib.es2020.date.d.ts","../node_modules/typescript/lib/lib.es2020.promise.d.ts","../node_modules/typescript/lib/lib.es2020.sharedmemory.d.ts","../node_modules/typescript/lib/lib.es2020.string.d.ts","../node_modules/typescript/lib/lib.es2020.symbol.wellknown.d.ts","../node_modules/typescript/lib/lib.es2020.intl.d.ts","../node_modules/typescript/lib/lib.es2020.number.d.ts","../node_modules/typescript/lib/lib.es2021.promise.d.ts","../node_modules/typescript/lib/lib.es2021.string.d.ts","../node_modules/typescript/lib/lib.es2021.weakref.d.ts","../node_modules/typescript/lib/lib.es2021.intl.d.ts","../node_modules/typescript/lib/lib.es2022.array.d.ts","../node_modules/typescript/lib/lib.es2022.error.d.ts","../node_modules/typescript/lib/lib.es2022.intl.d.ts","../node_modules/typescript/lib/lib.es2022.object.d.ts","../node_modules/typescript/lib/lib.es2022.string.d.ts","../node_modules/typescript/lib/lib.es2022.regexp.d.ts","../node_modules/typescript/lib/lib.es2023.array.d.ts","../node_modules/typescript/lib/lib.es2023.collection.d.ts","../node_modules/typescript/lib/lib.es2023.intl.d.ts","../node_modules/typescript/lib/lib.es2024.arraybuffer.d.ts","../node_modules/typescript/lib/lib.es2024.collection.d.ts","../node_modules/typescript/lib/lib.es2024.object.d.ts","../node_modules/typescript/lib/lib.es2024.promise.d.ts","../node_modules/typescript/lib/lib.es2024.regexp.d.ts","../node_modules/typescript/lib/lib.es2024.sharedmemory.d.ts","../node_modules/typescript/lib/lib.es2024.string.d.ts","../node_modules/typescript/lib/lib.decorators.d.ts","../node_modules/typescript/lib/lib.decorators.legacy.d.ts","../node_modules/abort-error/dist/src/index.d.ts","../node_modules/observable-webworkers/dist/src/index.d.ts","../src/constants.ts","../src/utils.ts","../node_modules/main-event/dist/src/events.d.ts","../node_modules/main-event/dist/src/index.d.ts","../node_modules/it-queue/dist/src/recipient.d.ts","../node_modules/it-queue/dist/src/job.d.ts","../node_modules/it-queue/dist/src/index.d.ts","../src/interface.ts","../src/node.ts","../src/index.ts","../src/browser.ts","../node_modules/@types/chai/index.d.ts","../node_modules/@types/chai-as-promised/index.d.ts","../node_modules/chai-parentheses/index.d.ts","../node_modules/@types/chai-subset/index.d.ts","../node_modules/chai-bites/index.d.ts","../node_modules/@types/chai-string/index.d.ts","../node_modules/aegir/dist/utils/chai.d.ts","../node_modules/delay/index.d.ts","../test/fixtures/lock.ts","../test/index.test.ts","../test/webworkers.test.ts","../test/browser.ts","../node_modules/wherearewe/dist/src/index.d.ts","../node_modules/execa/types/utils.d.ts","../node_modules/execa/types/transform/normalize.d.ts","../node_modules/execa/types/stdio/type.d.ts","../node_modules/execa/types/ipc.d.ts","../node_modules/execa/types/arguments/fd-options.d.ts","../node_modules/execa/types/arguments/specific.d.ts","../node_modules/execa/types/return/final-error.d.ts","../node_modules/execa/types/stdio/array.d.ts","../node_modules/execa/types/stdio/option.d.ts","../node_modules/execa/types/transform/object-mode.d.ts","../node_modules/execa/types/stdio/direction.d.ts","../node_modules/execa/types/return/ignore.d.ts","../node_modules/execa/types/arguments/encoding-option.d.ts","../node_modules/execa/types/return/result-stdout.d.ts","../node_modules/execa/types/return/result-all.d.ts","../node_modules/execa/types/return/result-stdio.d.ts","../node_modules/execa/types/return/result-ipc.d.ts","../node_modules/execa/types/return/result.d.ts","../node_modules/execa/types/verbose.d.ts","../node_modules/execa/types/arguments/options.d.ts","../node_modules/execa/types/methods/template.d.ts","../node_modules/execa/types/pipe.d.ts","../node_modules/execa/types/convert.d.ts","../node_modules/execa/types/subprocess/stdout.d.ts","../node_modules/execa/types/subprocess/stdio.d.ts","../node_modules/execa/types/subprocess/all.d.ts","../node_modules/execa/types/subprocess/subprocess.d.ts","../node_modules/execa/types/methods/main-async.d.ts","../node_modules/execa/types/methods/main-sync.d.ts","../node_modules/execa/types/methods/command.d.ts","../node_modules/execa/types/methods/script.d.ts","../node_modules/execa/types/methods/node.d.ts","../node_modules/execa/index.d.ts","../test/cluster.test.ts","../test/node.ts","../test/fixtures/cluster-single-thread.ts","../test/fixtures/cluster.ts","../test/fixtures/worker-single-thread.ts","../test/fixtures/worker.ts","../node_modules/@types/ms/index.d.ts","../node_modules/@types/debug/index.d.ts","../node_modules/@types/estree/index.d.ts","../node_modules/@types/unist/index.d.ts","../node_modules/@types/hast/index.d.ts","../node_modules/@types/http-cache-semantics/index.d.ts","../node_modules/@types/istanbul-lib-coverage/index.d.ts","../node_modules/@types/json-schema/index.d.ts","../node_modules/@types/json5/index.d.ts","../node_modules/@types/mdast/index.d.ts","../node_modules/@types/minimatch/index.d.ts","../node_modules/@types/minimist/index.d.ts","../node_modules/@types/mocha/index.d.ts","../node_modules/@types/node/compatibility/disposable.d.ts","../node_modules/@types/node/compatibility/indexable.d.ts","../node_modules/@types/node/compatibility/iterators.d.ts","../node_modules/@types/node/compatibility/index.d.ts","../node_modules/@types/node/globals.typedarray.d.ts","../node_modules/@types/node/buffer.buffer.d.ts","../node_modules/buffer/index.d.ts","../node_modules/undici-types/header.d.ts","../node_modules/undici-types/readable.d.ts","../node_modules/undici-types/file.d.ts","../node_modules/undici-types/fetch.d.ts","../node_modules/undici-types/formdata.d.ts","../node_modules/undici-types/connector.d.ts","../node_modules/undici-types/client.d.ts","../node_modules/undici-types/errors.d.ts","../node_modules/undici-types/dispatcher.d.ts","../node_modules/undici-types/global-dispatcher.d.ts","../node_modules/undici-types/global-origin.d.ts","../node_modules/undici-types/pool-stats.d.ts","../node_modules/undici-types/pool.d.ts","../node_modules/undici-types/handlers.d.ts","../node_modules/undici-types/balanced-pool.d.ts","../node_modules/undici-types/agent.d.ts","../node_modules/undici-types/mock-interceptor.d.ts","../node_modules/undici-types/mock-agent.d.ts","../node_modules/undici-types/mock-client.d.ts","../node_modules/undici-types/mock-pool.d.ts","../node_modules/undici-types/mock-errors.d.ts","../node_modules/undici-types/proxy-agent.d.ts","../node_modules/undici-types/env-http-proxy-agent.d.ts","../node_modules/undici-types/retry-handler.d.ts","../node_modules/undici-types/retry-agent.d.ts","../node_modules/undici-types/api.d.ts","../node_modules/undici-types/interceptors.d.ts","../node_modules/undici-types/util.d.ts","../node_modules/undici-types/cookies.d.ts","../node_modules/undici-types/patch.d.ts","../node_modules/undici-types/websocket.d.ts","../node_modules/undici-types/eventsource.d.ts","../node_modules/undici-types/filereader.d.ts","../node_modules/undici-types/diagnostics-channel.d.ts","../node_modules/undici-types/content-type.d.ts","../node_modules/undici-types/cache.d.ts","../node_modules/undici-types/index.d.ts","../node_modules/@types/node/globals.d.ts","../node_modules/@types/node/assert.d.ts","../node_modules/@types/node/assert/strict.d.ts","../node_modules/@types/node/async_hooks.d.ts","../node_modules/@types/node/buffer.d.ts","../node_modules/@types/node/child_process.d.ts","../node_modules/@types/node/cluster.d.ts","../node_modules/@types/node/console.d.ts","../node_modules/@types/node/constants.d.ts","../node_modules/@types/node/crypto.d.ts","../node_modules/@types/node/dgram.d.ts","../node_modules/@types/node/diagnostics_channel.d.ts","../node_modules/@types/node/dns.d.ts","../node_modules/@types/node/dns/promises.d.ts","../node_modules/@types/node/domain.d.ts","../node_modules/@types/node/dom-events.d.ts","../node_modules/@types/node/events.d.ts","../node_modules/@types/node/fs.d.ts","../node_modules/@types/node/fs/promises.d.ts","../node_modules/@types/node/http.d.ts","../node_modules/@types/node/http2.d.ts","../node_modules/@types/node/https.d.ts","../node_modules/@types/node/inspector.d.ts","../node_modules/@types/node/module.d.ts","../node_modules/@types/node/net.d.ts","../node_modules/@types/node/os.d.ts","../node_modules/@types/node/path.d.ts","../node_modules/@types/node/perf_hooks.d.ts","../node_modules/@types/node/process.d.ts","../node_modules/@types/node/punycode.d.ts","../node_modules/@types/node/querystring.d.ts","../node_modules/@types/node/readline.d.ts","../node_modules/@types/node/readline/promises.d.ts","../node_modules/@types/node/repl.d.ts","../node_modules/@types/node/sea.d.ts","../node_modules/@types/node/sqlite.d.ts","../node_modules/@types/node/stream.d.ts","../node_modules/@types/node/stream/promises.d.ts","../node_modules/@types/node/stream/consumers.d.ts","../node_modules/@types/node/stream/web.d.ts","../node_modules/@types/node/string_decoder.d.ts","../node_modules/@types/node/test.d.ts","../node_modules/@types/node/timers.d.ts","../node_modules/@types/node/timers/promises.d.ts","../node_modules/@types/node/tls.d.ts","../node_modules/@types/node/trace_events.d.ts","../node_modules/@types/node/tty.d.ts","../node_modules/@types/node/url.d.ts","../node_modules/@types/node/util.d.ts","../node_modules/@types/node/v8.d.ts","../node_modules/@types/node/vm.d.ts","../node_modules/@types/node/wasi.d.ts","../node_modules/@types/node/worker_threads.d.ts","../node_modules/@types/node/zlib.d.ts","../node_modules/@types/node/index.d.ts","../node_modules/@types/normalize-package-data/index.d.ts","../node_modules/@types/parse-json/index.d.ts","../node_modules/@types/retry/index.d.ts","../node_modules/@types/strip-bom/index.d.ts","../node_modules/@types/strip-json-comments/index.d.ts","../node_modules/@types/yauzl/index.d.ts"],"fileIdsList":[[86,156,199],[156,199],[138,156,199],[141,156,199],[156,196,199],[156,198,199],[199],[156,199,204,234],[156,199,200,205,211,212,219,231,242],[156,199,200,201,211,219],[151,152,153,156,199],[156,199,202,243],[156,199,203,204,212,220],[156,199,204,231,239],[156,199,205,207,211,219],[156,198,199,206],[156,199,207,208],[156,199,211],[156,199,209,211],[156,198,199,211],[156,199,211,212,213,231,242],[156,199,211,212,213,226,231,234],[156,194,199,247],[156,194,199,207,211,214,219,231,242],[156,199,211,212,214,215,219,231,239,242],[156,199,214,216,231,239,242],[154,155,156,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248],[156,199,211,217],[156,199,218,242],[156,199,207,211,219,231],[156,199,220],[156,199,221],[156,198,199,222],[156,196,197,198,199,200,201,202,203,204,205,206,207,208,209,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248],[156,199,224],[156,199,225],[156,199,211,226,227],[156,199,226,228,243,245],[156,199,211,231,232,234],[156,199,233,234],[156,199,231,232],[156,199,234],[156,199,235],[156,196,199,231],[156,199,211,237,238],[156,199,237,238],[156,199,204,219,231,239],[156,199,240],[156,199,219,241],[156,199,214,225,242],[156,199,204,243],[156,199,231,244],[156,199,218,245],[156,199,246],[156,199,204,211,213,222,231,242,245,247],[156,199,231,248],[156,199,211,231,249],[86,87,88,89,90,91,156,199],[86,87,156,199],[101,102,105,116,117,118,119,125,126,127,128,129,130,156,199],[99,101,102,104,111,117,156,199,220,231],[103,156,199],[103,111,118,156,199],[118,156,199],[116,118,119,125,156,199],[118,119,125,156,199],[116,118,119,156,199],[116,156,199],[103,116,118,119,125,156,199],[116,118,156,199],[101,104,107,109,118,156,199],[104,108,110,112,118,156,199],[102,104,118,156,199],[106,112,118,156,199],[104,108,110,111,118,156,199],[99,105,112,113,114,115,118,156,199,220],[101,118,156,199],[99,101,107,118,156,199],[101,106,118,156,199],[99,100,156,199,231,234],[110,118,156,199,231],[106,118,122,156,199],[109,110,118,156,199,231],[102,116,118,120,121,122,123,124,156,199,200,220,231],[99,156,199,231,234],[100,101,107,118,156,199],[104,116,118,156,199],[73,78,79,80,156,199],[73,79,81,156,199],[77,156,199],[156,166,170,199,242],[156,166,199,231,242],[156,161,199],[156,163,166,199,239,242],[156,199,219,239],[156,199,249],[156,161,199,249],[156,163,166,199,219,242],[156,158,159,162,165,199,211,231,242],[156,166,173,199],[156,158,164,199],[156,166,187,188,199],[156,162,166,199,234,242,249],[156,187,199,249],[156,160,161,199,249],[156,166,199],[156,160,161,162,163,164,165,166,167,168,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,188,189,190,191,192,193,199],[156,166,181,199],[156,166,173,174,199],[156,164,166,174,175,199],[156,165,199],[156,158,161,166,199],[156,166,170,174,175,199],[156,170,199],[156,164,166,169,199,242],[156,158,163,166,173,199],[156,199,231],[156,161,166,187,199,247,249],[73,74,75,76,82,84,156,199],[73,81,83,156,199],[84,156,199],[73,75,76,82,84,156,199,201],[95,96,156,199],[92,98,131,156,199],[84,94,156,199,201],[84,93,156,199],[84,94,156,199],[84,92,93,94,156,199],[95,132,156,199],[74,92,156,199]],"fileInfos":[{"version":"69684132aeb9b5642cbcd9e22dff7818ff0ee1aa831728af0ecf97d3364d5546","affectsGlobalScope":true,"impliedFormat":1},{"version":"45b7ab580deca34ae9729e97c13cfd999df04416a79116c3bfb483804f85ded4","impliedFormat":1},{"version":"3facaf05f0c5fc569c5649dd359892c98a85557e3e0c847964caeb67076f4d75","impliedFormat":1},{"version":"e44bb8bbac7f10ecc786703fe0a6a4b952189f908707980ba8f3c8975a760962","impliedFormat":1},{"version":"5e1c4c362065a6b95ff952c0eab010f04dcd2c3494e813b493ecfd4fcb9fc0d8","impliedFormat":1},{"version":"68d73b4a11549f9c0b7d352d10e91e5dca8faa3322bfb77b661839c42b1ddec7","impliedFormat":1},{"version":"5efce4fc3c29ea84e8928f97adec086e3dc876365e0982cc8479a07954a3efd4","impliedFormat":1},{"version":"feecb1be483ed332fad555aff858affd90a48ab19ba7272ee084704eb7167569","impliedFormat":1},{"version":"ee7bad0c15b58988daa84371e0b89d313b762ab83cb5b31b8a2d1162e8eb41c2","impliedFormat":1},{"version":"27bdc30a0e32783366a5abeda841bc22757c1797de8681bbe81fbc735eeb1c10","impliedFormat":1},{"version":"8fd575e12870e9944c7e1d62e1f5a73fcf23dd8d3a321f2a2c74c20d022283fe","impliedFormat":1},{"version":"092c2bfe125ce69dbb1223c85d68d4d2397d7d8411867b5cc03cec902c233763","affectsGlobalScope":true,"impliedFormat":1},{"version":"07f073f19d67f74d732b1adea08e1dc66b1b58d77cb5b43931dee3d798a2fd53","affectsGlobalScope":true,"impliedFormat":1},{"version":"8ea22b76493fc658fe9b76a84e64c9618823608076ecee5ed3f93f7f0dde904e","affectsGlobalScope":true,"impliedFormat":1},{"version":"c57796738e7f83dbc4b8e65132f11a377649c00dd3eee333f672b8f0a6bea671","affectsGlobalScope":true,"impliedFormat":1},{"version":"dc2df20b1bcdc8c2d34af4926e2c3ab15ffe1160a63e58b7e09833f616efff44","affectsGlobalScope":true,"impliedFormat":1},{"version":"515d0b7b9bea2e31ea4ec968e9edd2c39d3eebf4a2d5cbd04e88639819ae3b71","affectsGlobalScope":true,"impliedFormat":1},{"version":"0559b1f683ac7505ae451f9a96ce4c3c92bdc71411651ca6ddb0e88baaaad6a3","affectsGlobalScope":true,"impliedFormat":1},{"version":"0dc1e7ceda9b8b9b455c3a2d67b0412feab00bd2f66656cd8850e8831b08b537","affectsGlobalScope":true,"impliedFormat":1},{"version":"ce691fb9e5c64efb9547083e4a34091bcbe5bdb41027e310ebba8f7d96a98671","affectsGlobalScope":true,"impliedFormat":1},{"version":"8d697a2a929a5fcb38b7a65594020fcef05ec1630804a33748829c5ff53640d0","affectsGlobalScope":true,"impliedFormat":1},{"version":"4ff2a353abf8a80ee399af572debb8faab2d33ad38c4b4474cff7f26e7653b8d","affectsGlobalScope":true,"impliedFormat":1},{"version":"936e80ad36a2ee83fc3caf008e7c4c5afe45b3cf3d5c24408f039c1d47bdc1df","affectsGlobalScope":true,"impliedFormat":1},{"version":"d15bea3d62cbbdb9797079416b8ac375ae99162a7fba5de2c6c505446486ac0a","affectsGlobalScope":true,"impliedFormat":1},{"version":"68d18b664c9d32a7336a70235958b8997ebc1c3b8505f4f1ae2b7e7753b87618","affectsGlobalScope":true,"impliedFormat":1},{"version":"eb3d66c8327153d8fa7dd03f9c58d351107fe824c79e9b56b462935176cdf12a","affectsGlobalScope":true,"impliedFormat":1},{"version":"38f0219c9e23c915ef9790ab1d680440d95419ad264816fa15009a8851e79119","affectsGlobalScope":true,"impliedFormat":1},{"version":"69ab18c3b76cd9b1be3d188eaf8bba06112ebbe2f47f6c322b5105a6fbc45a2e","affectsGlobalScope":true,"impliedFormat":1},{"version":"fef8cfad2e2dc5f5b3d97a6f4f2e92848eb1b88e897bb7318cef0e2820bceaab","affectsGlobalScope":true,"impliedFormat":1},{"version":"2f11ff796926e0832f9ae148008138ad583bd181899ab7dd768a2666700b1893","affectsGlobalScope":true,"impliedFormat":1},{"version":"4de680d5bb41c17f7f68e0419412ca23c98d5749dcaaea1896172f06435891fc","affectsGlobalScope":true,"impliedFormat":1},{"version":"954296b30da6d508a104a3a0b5d96b76495c709785c1d11610908e63481ee667","affectsGlobalScope":true,"impliedFormat":1},{"version":"ac9538681b19688c8eae65811b329d3744af679e0bdfa5d842d0e32524c73e1c","affectsGlobalScope":true,"impliedFormat":1},{"version":"0a969edff4bd52585473d24995c5ef223f6652d6ef46193309b3921d65dd4376","affectsGlobalScope":true,"impliedFormat":1},{"version":"9e9fbd7030c440b33d021da145d3232984c8bb7916f277e8ffd3dc2e3eae2bdb","affectsGlobalScope":true,"impliedFormat":1},{"version":"811ec78f7fefcabbda4bfa93b3eb67d9ae166ef95f9bff989d964061cbf81a0c","affectsGlobalScope":true,"impliedFormat":1},{"version":"717937616a17072082152a2ef351cb51f98802fb4b2fdabd32399843875974ca","affectsGlobalScope":true,"impliedFormat":1},{"version":"d7e7d9b7b50e5f22c915b525acc5a49a7a6584cf8f62d0569e557c5cfc4b2ac2","affectsGlobalScope":true,"impliedFormat":1},{"version":"71c37f4c9543f31dfced6c7840e068c5a5aacb7b89111a4364b1d5276b852557","affectsGlobalScope":true,"impliedFormat":1},{"version":"576711e016cf4f1804676043e6a0a5414252560eb57de9faceee34d79798c850","affectsGlobalScope":true,"impliedFormat":1},{"version":"89c1b1281ba7b8a96efc676b11b264de7a8374c5ea1e6617f11880a13fc56dc6","affectsGlobalScope":true,"impliedFormat":1},{"version":"74f7fa2d027d5b33eb0471c8e82a6c87216223181ec31247c357a3e8e2fddc5b","affectsGlobalScope":true,"impliedFormat":1},{"version":"d6d7ae4d1f1f3772e2a3cde568ed08991a8ae34a080ff1151af28b7f798e22ca","affectsGlobalScope":true,"impliedFormat":1},{"version":"063600664504610fe3e99b717a1223f8b1900087fab0b4cad1496a114744f8df","affectsGlobalScope":true,"impliedFormat":1},{"version":"934019d7e3c81950f9a8426d093458b65d5aff2c7c1511233c0fd5b941e608ab","affectsGlobalScope":true,"impliedFormat":1},{"version":"52ada8e0b6e0482b728070b7639ee42e83a9b1c22d205992756fe020fd9f4a47","affectsGlobalScope":true,"impliedFormat":1},{"version":"3bdefe1bfd4d6dee0e26f928f93ccc128f1b64d5d501ff4a8cf3c6371200e5e6","affectsGlobalScope":true,"impliedFormat":1},{"version":"59fb2c069260b4ba00b5643b907ef5d5341b167e7d1dbf58dfd895658bda2867","affectsGlobalScope":true,"impliedFormat":1},{"version":"639e512c0dfc3fad96a84caad71b8834d66329a1f28dc95e3946c9b58176c73a","affectsGlobalScope":true,"impliedFormat":1},{"version":"368af93f74c9c932edd84c58883e736c9e3d53cec1fe24c0b0ff451f529ceab1","affectsGlobalScope":true,"impliedFormat":1},{"version":"af3dd424cf267428f30ccfc376f47a2c0114546b55c44d8c0f1d57d841e28d74","affectsGlobalScope":true,"impliedFormat":1},{"version":"995c005ab91a498455ea8dfb63aa9f83fa2ea793c3d8aa344be4a1678d06d399","affectsGlobalScope":true,"impliedFormat":1},{"version":"959d36cddf5e7d572a65045b876f2956c973a586da58e5d26cde519184fd9b8a","affectsGlobalScope":true,"impliedFormat":1},{"version":"965f36eae237dd74e6cca203a43e9ca801ce38824ead814728a2807b1910117d","affectsGlobalScope":true,"impliedFormat":1},{"version":"3925a6c820dcb1a06506c90b1577db1fdbf7705d65b62b99dce4be75c637e26b","affectsGlobalScope":true,"impliedFormat":1},{"version":"0a3d63ef2b853447ec4f749d3f368ce642264246e02911fcb1590d8c161b8005","affectsGlobalScope":true,"impliedFormat":1},{"version":"b5ce7a470bc3628408429040c4e3a53a27755022a32fd05e2cb694e7015386c7","affectsGlobalScope":true,"impliedFormat":1},{"version":"8444af78980e3b20b49324f4a16ba35024fef3ee069a0eb67616ea6ca821c47a","affectsGlobalScope":true,"impliedFormat":1},{"version":"3287d9d085fbd618c3971944b65b4be57859f5415f495b33a6adc994edd2f004","affectsGlobalScope":true,"impliedFormat":1},{"version":"b4b67b1a91182421f5df999988c690f14d813b9850b40acd06ed44691f6727ad","affectsGlobalScope":true,"impliedFormat":1},{"version":"df83c2a6c73228b625b0beb6669c7ee2a09c914637e2d35170723ad49c0f5cd4","affectsGlobalScope":true,"impliedFormat":1},{"version":"436aaf437562f276ec2ddbee2f2cdedac7664c1e4c1d2c36839ddd582eeb3d0a","affectsGlobalScope":true,"impliedFormat":1},{"version":"8e3c06ea092138bf9fa5e874a1fdbc9d54805d074bee1de31b99a11e2fec239d","affectsGlobalScope":true,"impliedFormat":1},{"version":"87dc0f382502f5bbce5129bdc0aea21e19a3abbc19259e0b43ae038a9fc4e326","affectsGlobalScope":true,"impliedFormat":1},{"version":"b1cb28af0c891c8c96b2d6b7be76bd394fddcfdb4709a20ba05a7c1605eea0f9","affectsGlobalScope":true,"impliedFormat":1},{"version":"2fef54945a13095fdb9b84f705f2b5994597640c46afeb2ce78352fab4cb3279","affectsGlobalScope":true,"impliedFormat":1},{"version":"ac77cb3e8c6d3565793eb90a8373ee8033146315a3dbead3bde8db5eaf5e5ec6","affectsGlobalScope":true,"impliedFormat":1},{"version":"56e4ed5aab5f5920980066a9409bfaf53e6d21d3f8d020c17e4de584d29600ad","affectsGlobalScope":true,"impliedFormat":1},{"version":"4ece9f17b3866cc077099c73f4983bddbcb1dc7ddb943227f1ec070f529dedd1","affectsGlobalScope":true,"impliedFormat":1},{"version":"0a6282c8827e4b9a95f4bf4f5c205673ada31b982f50572d27103df8ceb8013c","affectsGlobalScope":true,"impliedFormat":1},{"version":"8e7f8264d0fb4c5339605a15daadb037bf238c10b654bb3eee14208f860a32ea","affectsGlobalScope":true,"impliedFormat":1},{"version":"782dec38049b92d4e85c1585fbea5474a219c6984a35b004963b00beb1aab538","affectsGlobalScope":true,"impliedFormat":1},{"version":"7caa8e0cc96a2167b4bd632883b58319f6bb3e4e28a39cd771099ff9d78ae37e","impliedFormat":99},{"version":"9080ab3f8eada7c749280a63025b5864c8a8dc3fc1c25b19c9e084ec63813ef5","impliedFormat":99},{"version":"3e935b3e11015a5620abf0745ab7fb0a4fe74012bc4059c067a31d503a587b4f","signature":"6eb6c96cf0658caf121f173bdb26ed816ec4a982323068440227cbadccf8716f","impliedFormat":99},{"version":"b7f33fe144dc641f1bdec3bff5de2f36e831696f4a6d04b8c119b64c2c6f10b2","signature":"f19c53da5dbff4c39d561ab9870602eee32f776b3ed53e1d1cacfc769aa61045","impliedFormat":99},{"version":"6a99ac72e356885b8aab17cc8b50e63583447a1b39cd77db49916d37bd61fca2","impliedFormat":99},{"version":"c6e7aee1999b183a1881d705ff8eb05d86c0a3dbddcd1eee9d96a85bcf160840","impliedFormat":99},{"version":"96683d5c95cf00988e5a8c8de55f452ed5b3cb3949459312e03c4710c4787a70","impliedFormat":99},{"version":"bb9e44f4e2699a7803bf7329c777b57441d131e74b7da7d5e100ca4b81725db2","impliedFormat":99},{"version":"83cdfbf7e7630bd7e7979517f375a07534abef8826fafc872b53f60cba643dff","impliedFormat":99},{"version":"fcb4e10232a134abe2fc0742f9aa73cd6a8d858214dba553488a99b110a823ef","signature":"13e988cee866aea803a169d4df1de5b3c02f5aa81dffb77db8740758766eac59","impliedFormat":99},{"version":"bd683d3b674676541b0cad66f4269b5c038012bcb29cb4c524fe2c7b51a90007","signature":"8dc0ae69963c1ce191831d165bd63f2a8e63e8a2425628de8da6b6738f6e7545","impliedFormat":99},{"version":"11b14d875180f9a89623312edecb59012674ac99fa86343cc3254ddc43bde626","signature":"23ff3184d03bce870c41e59339eebe5886a456123d11af0c4b0d3314160465bb","impliedFormat":99},{"version":"a374051a95373bb92d1a674851f9baae3fdf9a38047cfc08de352d27b236309d","signature":"b06a49c2ce11d540e45320a19f01206827cc778fd0c14cc433aca3bd564ece7c","impliedFormat":99},{"version":"eef204f061321360559bd19235ea32a9d55b3ec22a362cc78d14ef50d4db4490","affectsGlobalScope":true,"impliedFormat":1},{"version":"86e56d97b13ef0a58bc9c59aee782ae7d47d63802b5b32129ec5e5d62c20dbfa","affectsGlobalScope":true,"impliedFormat":1},{"version":"c1f79c6d85cd84518fd7349588b3c61bdc189f58e3866f925cbf4631c81e31f9","affectsGlobalScope":true,"impliedFormat":1},{"version":"54db406753da16e177f094aa66da79840f447de6d87ddd1543a80c9418c52545","affectsGlobalScope":true,"impliedFormat":1},{"version":"42f28f4cfca4a70bd89c1d55d76c7978275030b894f6793f36890265c11a83a4","affectsGlobalScope":true,"impliedFormat":1},{"version":"7cf1027da9599f056355b46bbea31dbf7f715f797dffb9cbb3402d4490c503e5","affectsGlobalScope":true,"impliedFormat":1},{"version":"96dbd0787b57ae02981d26d5f2441f0f8444fb46d7578c56527eab89cff13a7d","impliedFormat":99},{"version":"27573b15894c6311146838fa3b45786bacc013a4bca6c84adc1b11a4e7c8a4c0","impliedFormat":99},{"version":"6cf8a054ec3c638051ce75209b20630fe3a44c36c3f85a3520c270b34a1c80ba","signature":"d3befda5730c053979ac478dcfb132b27c1beacf25f953c9cc8939393e1da605","impliedFormat":99},{"version":"f5b43e9da994dd44110378dfd21aa76c0673d99623095a2e0312490859aea197","signature":"8e609bb71c20b858c77f0e9f90bb1319db8477b13f9f965f1a1e18524bf50881","impliedFormat":99},{"version":"ce885190b05f7c380cc95a8f54276cb50d7bb9a868ae39b696a9ea0866fb294f","signature":"8e609bb71c20b858c77f0e9f90bb1319db8477b13f9f965f1a1e18524bf50881","impliedFormat":99},{"version":"ba9b92ca1a7f21f9dd15a2451fe099ddefe9d7f590160a757b7b0d871facfd3a","signature":"1ec295ba7424375e258572aa01f3cdf480a1b96789a78c8046a15d1e6446b04c","impliedFormat":99},{"version":"00cd454fa42dca69cdea08d4cb9698e679ba9a31762c23d905e45ba92269ac3a","impliedFormat":99},{"version":"6b1d838981b5606f4c958d98800e318314e71f0dd1d087196350d189362b69c9","impliedFormat":99},{"version":"eecab4c87fadc3a8c5fa35f659a4f5c480208ab80f0f36d9761c2bb427908fcb","impliedFormat":99},{"version":"b8dd1d513057d0320e4d5473be58c7161fb50ca2d5ad5c0e6e81b417aad36f61","impliedFormat":99},{"version":"73465f19e61e23f551639909f94147b4211e1331d3699bce6fcc972203423b20","impliedFormat":99},{"version":"929746f886d166cee5d20d109e816f527c709a00cc90c8fd7c52c66e72e31805","impliedFormat":99},{"version":"9ffa740c1a384e68eca1c3e530ee6911ed42fbc0010570d2effb375eaaa4dceb","impliedFormat":99},{"version":"6f2cc41dae1386fc57a4980d3aba6115e879479821ea78a2d4e3a3c2fd5cb786","impliedFormat":99},{"version":"bd236ec30223eaced7fed2c84ffc5933ad23061314c4b9874d4d7c88f2d841f4","impliedFormat":99},{"version":"97adcdc3cd8c7fbcaf7e1f60a4ea05972da21b0e0b1ef71ab96c20c9c65ffe88","impliedFormat":99},{"version":"3dcf393cb7c87561367ae539f1462b15b48af0bac86cb6892bbf6c617e9e1872","impliedFormat":99},{"version":"86413ef25968db827f5d8ca68a3ae8a7fd91f8cbe4f654053ff32454b3f6e2e8","impliedFormat":99},{"version":"3ef8337f4df30d8d6978651ae95632bb7dd229ac4dfa7006c2aa4e2006ea6453","impliedFormat":99},{"version":"09e0d46e3d2fcc6c5d7a2afbd1a22809dafd50f1f3f8b1d2e327ed21c7c6fa5f","impliedFormat":99},{"version":"ac5b06a39925ae9c5344c84e2e24d7b61c22b4176fcbb96de5f8e45986f2331e","impliedFormat":99},{"version":"d829826b1dc3a0d84174e03b009afe4677e36a84904863f6318b7243c3644b44","impliedFormat":99},{"version":"c61e4cede8cf73fb4dbff3cad8fd57902eab1ebc62f20d9aeb105c3257f5a906","impliedFormat":99},{"version":"ebdf90aea74d99b9fc1a639433c3458604b5db3571b7954b8317dd1a1fa71bdd","impliedFormat":99},{"version":"9c1de355ef73132bba24da0e616cb67867e4b7f85689bd95b9638395cbb81a6d","impliedFormat":99},{"version":"46c4ec0878833d2ae63e24e2389a8145babdcab72297e18581af97d7e62c0511","impliedFormat":99},{"version":"df92b0948e17e54e60e2b7bbc525d06b35d404a1a3c1ea48e4071262002f7d3d","impliedFormat":99},{"version":"7c9e187838a0e665cac719dc03b215dfc29da9caa30af79a78531e7256a1d6d2","impliedFormat":99},{"version":"1eb292fabe901c9fa80732c87cf7b42b5f790f5af48bc36d8371272fa80427f2","impliedFormat":99},{"version":"c34decddf18283ad1811981c06a07208aaef29010c55a7b810ba5c96e3d89a6b","impliedFormat":99},{"version":"694adea51eea8d8981ce771b52c5e5a2d524886e6397fc9431424325ecf42eb1","impliedFormat":99},{"version":"15036d0d6ec1d21354542a670696edea4a344baeed6718cb553aa8fe619e8069","impliedFormat":99},{"version":"3c6ce563b69aa0a196f2373c5ee96472ca1aeb232a9611981bdff9b3bc48e02a","impliedFormat":99},{"version":"45a6de331708ab2a4f98fbb5d68d0a91b887802d277b37573a26ecb0036f1e7e","impliedFormat":99},{"version":"8743f6147ba8d5e9cff0076f0a016d183df75a0796c25e096ee3fa19d06acfc5","impliedFormat":99},{"version":"812651dab7b19c7fe9cfea34fdb7a059093aff0c1cfa5dbfe979b57e7d7627ab","impliedFormat":99},{"version":"e329923a93fce350f89d04facf9053fa20b789cae18fe3340527ccd9a61275ed","impliedFormat":99},{"version":"a008ee16379994ecad644e0e543bcd0ec790fc51e9ee2632008f241872cbcfce","impliedFormat":99},{"version":"3cf28c9c5653662986136d2ffb17e5e1ea6d933aaee20ec64de184b19284ffda","impliedFormat":99},{"version":"3d25e4112b03e9a3549ab85ff56e3f2d7264f74dcf5308549c81609c31ab2aa3","impliedFormat":99},{"version":"6e4a3eafe7e24a1c13f606c9bbdc9c66d95f4f19615a672a01c00414e0dfbc47","signature":"8e609bb71c20b858c77f0e9f90bb1319db8477b13f9f965f1a1e18524bf50881","impliedFormat":99},{"version":"3b02864e78dd4183ca2f58a09f7ea983835a368b2773315a937921d01bf3e23a","signature":"fe2a0f607ddc6a47fabde94c46582750497c403183d0f3c6b1b13a8c364d92b3","impliedFormat":99},{"version":"1614b3ebd38e036e9abe5267176f4130a3f8f7d054ac4747f76eb6b7bb2ec996","signature":"8e609bb71c20b858c77f0e9f90bb1319db8477b13f9f965f1a1e18524bf50881","impliedFormat":99},{"version":"6ac417d4399174a5c8f73bdd0a395b469b264491adfda2652d4dea58ec76bf0a","signature":"8e609bb71c20b858c77f0e9f90bb1319db8477b13f9f965f1a1e18524bf50881","impliedFormat":99},{"version":"7b3c8a806c1587364724568791f745773ff63e5cbdd85855089f5c7a54533a99","signature":"8e609bb71c20b858c77f0e9f90bb1319db8477b13f9f965f1a1e18524bf50881","impliedFormat":99},{"version":"6289d8cf6d32a357da4af82933fe514fee1c82c0fe92780303cecf1c586c9057","signature":"8e609bb71c20b858c77f0e9f90bb1319db8477b13f9f965f1a1e18524bf50881","impliedFormat":99},{"version":"fb893a0dfc3c9fb0f9ca93d0648694dd95f33cbad2c0f2c629f842981dfd4e2e","impliedFormat":1},{"version":"3eb11dbf3489064a47a2e1cf9d261b1f100ef0b3b50ffca6c44dd99d6dd81ac1","impliedFormat":1},{"version":"e2b48abff5a8adc6bb1cd13a702b9ef05e6045a98e7cfa95a8779b53b6d0e69d","impliedFormat":1},{"version":"89121c1bf2990f5219bfd802a3e7fc557de447c62058d6af68d6b6348d64499a","impliedFormat":1},{"version":"79b4369233a12c6fa4a07301ecb7085802c98f3a77cf9ab97eee27e1656f82e6","impliedFormat":1},{"version":"d7dbe0ad36bdca8a6ecf143422a48e72cc8927bab7b23a1a2485c2f78a7022c6","impliedFormat":1},{"version":"035a5df183489c2e22f3cf59fc1ed2b043d27f357eecc0eb8d8e840059d44245","impliedFormat":1},{"version":"f3d8c757e148ad968f0d98697987db363070abada5f503da3c06aefd9d4248c1","impliedFormat":1},{"version":"96d14f21b7652903852eef49379d04dbda28c16ed36468f8c9fa08f7c14c9538","impliedFormat":1},{"version":"d4a22007b481fe2a2e6bfd3a42c00cd62d41edb36d30fc4697df2692e9891fc8","impliedFormat":1},{"version":"8841e2aa774b89bd23302dede20663306dc1b9902431ac64b24be8b8d0e3f649","impliedFormat":1},{"version":"fbca5ffaebf282ec3cdac47b0d1d4a138a8b0bb32105251a38acb235087d3318","impliedFormat":1},{"version":"29f72ec1289ae3aeda78bf14b38086d3d803262ac13904b400422941a26a3636","affectsGlobalScope":true,"impliedFormat":1},{"version":"70521b6ab0dcba37539e5303104f29b721bfb2940b2776da4cc818c07e1fefc1","affectsGlobalScope":true,"impliedFormat":1},{"version":"030e350db2525514580ed054f712ffb22d273e6bc7eddc1bb7eda1e0ba5d395e","affectsGlobalScope":true,"impliedFormat":1},{"version":"d153a11543fd884b596587ccd97aebbeed950b26933ee000f94009f1ab142848","affectsGlobalScope":true,"impliedFormat":1},{"version":"21d819c173c0cf7cc3ce57c3276e77fd9a8a01d35a06ad87158781515c9a438a","impliedFormat":1},{"version":"a79e62f1e20467e11a904399b8b18b18c0c6eea6b50c1168bf215356d5bebfaf","affectsGlobalScope":true,"impliedFormat":1},{"version":"d802f0e6b5188646d307f070d83512e8eb94651858de8a82d1e47f60fb6da4e2","affectsGlobalScope":true,"impliedFormat":1},{"version":"4967529644e391115ca5592184d4b63980569adf60ee685f968fd59ab1557188","impliedFormat":1},{"version":"5929864ce17fba74232584d90cb721a89b7ad277220627cc97054ba15a98ea8f","impliedFormat":1},{"version":"763fe0f42b3d79b440a9b6e51e9ba3f3f91352469c1e4b3b67bfa4ff6352f3f4","impliedFormat":1},{"version":"25c8056edf4314820382a5fdb4bb7816999acdcb929c8f75e3f39473b87e85bc","impliedFormat":1},{"version":"c464d66b20788266e5353b48dc4aa6bc0dc4a707276df1e7152ab0c9ae21fad8","impliedFormat":1},{"version":"78d0d27c130d35c60b5e5566c9f1e5be77caf39804636bc1a40133919a949f21","impliedFormat":1},{"version":"c6fd2c5a395f2432786c9cb8deb870b9b0e8ff7e22c029954fabdd692bff6195","impliedFormat":1},{"version":"1d6e127068ea8e104a912e42fc0a110e2aa5a66a356a917a163e8cf9a65e4a75","impliedFormat":1},{"version":"5ded6427296cdf3b9542de4471d2aa8d3983671d4cac0f4bf9c637208d1ced43","impliedFormat":1},{"version":"7f182617db458e98fc18dfb272d40aa2fff3a353c44a89b2c0ccb3937709bfb5","impliedFormat":1},{"version":"cadc8aced301244057c4e7e73fbcae534b0f5b12a37b150d80e5a45aa4bebcbd","impliedFormat":1},{"version":"385aab901643aa54e1c36f5ef3107913b10d1b5bb8cbcd933d4263b80a0d7f20","impliedFormat":1},{"version":"9670d44354bab9d9982eca21945686b5c24a3f893db73c0dae0fd74217a4c219","impliedFormat":1},{"version":"0b8a9268adaf4da35e7fa830c8981cfa22adbbe5b3f6f5ab91f6658899e657a7","impliedFormat":1},{"version":"11396ed8a44c02ab9798b7dca436009f866e8dae3c9c25e8c1fbc396880bf1bb","impliedFormat":1},{"version":"ba7bc87d01492633cb5a0e5da8a4a42a1c86270e7b3d2dea5d156828a84e4882","impliedFormat":1},{"version":"4893a895ea92c85345017a04ed427cbd6a1710453338df26881a6019432febdd","impliedFormat":1},{"version":"c21dc52e277bcfc75fac0436ccb75c204f9e1b3fa5e12729670910639f27343e","impliedFormat":1},{"version":"13f6f39e12b1518c6650bbb220c8985999020fe0f21d818e28f512b7771d00f9","impliedFormat":1},{"version":"9b5369969f6e7175740bf51223112ff209f94ba43ecd3bb09eefff9fd675624a","impliedFormat":1},{"version":"4fe9e626e7164748e8769bbf74b538e09607f07ed17c2f20af8d680ee49fc1da","impliedFormat":1},{"version":"24515859bc0b836719105bb6cc3d68255042a9f02a6022b3187948b204946bd2","impliedFormat":1},{"version":"ea0148f897b45a76544ae179784c95af1bd6721b8610af9ffa467a518a086a43","impliedFormat":1},{"version":"24c6a117721e606c9984335f71711877293a9651e44f59f3d21c1ea0856f9cc9","impliedFormat":1},{"version":"dd3273ead9fbde62a72949c97dbec2247ea08e0c6952e701a483d74ef92d6a17","impliedFormat":1},{"version":"405822be75ad3e4d162e07439bac80c6bcc6dbae1929e179cf467ec0b9ee4e2e","impliedFormat":1},{"version":"0db18c6e78ea846316c012478888f33c11ffadab9efd1cc8bcc12daded7a60b6","impliedFormat":1},{"version":"e61be3f894b41b7baa1fbd6a66893f2579bfad01d208b4ff61daef21493ef0a8","impliedFormat":1},{"version":"bd0532fd6556073727d28da0edfd1736417a3f9f394877b6d5ef6ad88fba1d1a","impliedFormat":1},{"version":"89167d696a849fce5ca508032aabfe901c0868f833a8625d5a9c6e861ef935d2","impliedFormat":1},{"version":"615ba88d0128ed16bf83ef8ccbb6aff05c3ee2db1cc0f89ab50a4939bfc1943f","impliedFormat":1},{"version":"a4d551dbf8746780194d550c88f26cf937caf8d56f102969a110cfaed4b06656","impliedFormat":1},{"version":"8bd86b8e8f6a6aa6c49b71e14c4ffe1211a0e97c80f08d2c8cc98838006e4b88","impliedFormat":1},{"version":"317e63deeb21ac07f3992f5b50cdca8338f10acd4fbb7257ebf56735bf52ab00","impliedFormat":1},{"version":"4732aec92b20fb28c5fe9ad99521fb59974289ed1e45aecb282616202184064f","impliedFormat":1},{"version":"2e85db9e6fd73cfa3d7f28e0ab6b55417ea18931423bd47b409a96e4a169e8e6","impliedFormat":1},{"version":"c46e079fe54c76f95c67fb89081b3e399da2c7d109e7dca8e4b58d83e332e605","impliedFormat":1},{"version":"bf67d53d168abc1298888693338cb82854bdb2e69ef83f8a0092093c2d562107","impliedFormat":1},{"version":"88d9a77d2abc23a7d26625dd6dae5b57199a8693b85c9819355651c9d9bab90f","affectsGlobalScope":true,"impliedFormat":1},{"version":"a38efe83ff77c34e0f418a806a01ca3910c02ee7d64212a59d59bca6c2c38fa1","impliedFormat":1},{"version":"7394959e5a741b185456e1ef5d64599c36c60a323207450991e7a42e08911419","impliedFormat":1},{"version":"3fe4022ba1e738034e38ad9afacbf0f1f16b458ed516326f5bf9e4a31e9be1dc","impliedFormat":1},{"version":"a957197054b074bcdf5555d26286e8461680c7c878040d0f4e2d5509a7524944","affectsGlobalScope":true,"impliedFormat":1},{"version":"4314c7a11517e221f7296b46547dbc4df047115b182f544d072bdccffa57fc72","impliedFormat":1},{"version":"e9b97d69510658d2f4199b7d384326b7c4053b9e6645f5c19e1c2a54ede427fc","impliedFormat":1},{"version":"c2510f124c0293ab80b1777c44d80f812b75612f297b9857406468c0f4dafe29","affectsGlobalScope":true,"impliedFormat":1},{"version":"5524481e56c48ff486f42926778c0a3cce1cc85dc46683b92b1271865bcf015a","impliedFormat":1},{"version":"f478f6f5902dc144c0d6d7bdc919c5177cac4d17a8ca8653c2daf6d7dc94317f","affectsGlobalScope":true,"impliedFormat":1},{"version":"19d5f8d3930e9f99aa2c36258bf95abbe5adf7e889e6181872d1cdba7c9a7dd5","impliedFormat":1},{"version":"b200675fd112ffef97c166d0341fb33f6e29e9f27660adde7868e95c5bc98beb","impliedFormat":1},{"version":"a6bf63d17324010ca1fbf0389cab83f93389bb0b9a01dc8a346d092f65b3605f","impliedFormat":1},{"version":"e009777bef4b023a999b2e5b9a136ff2cde37dc3f77c744a02840f05b18be8ff","impliedFormat":1},{"version":"1e0d1f8b0adfa0b0330e028c7941b5a98c08b600efe7f14d2d2a00854fb2f393","impliedFormat":1},{"version":"ee1ee365d88c4c6c0c0a5a5701d66ebc27ccd0bcfcfaa482c6e2e7fe7b98edf7","affectsGlobalScope":true,"impliedFormat":1},{"version":"88bc59b32d0d5b4e5d9632ac38edea23454057e643684c3c0b94511296f2998c","affectsGlobalScope":true,"impliedFormat":1},{"version":"a0a1dda070290b92da5a50113b73ecc4dd6bcbffad66e3c86503d483eafbadcf","impliedFormat":1},{"version":"59dcad36c4549175a25998f6a8b33c1df8e18df9c12ebad1dfb25af13fd4b1ce","impliedFormat":1},{"version":"206a70e72af3e24688397b81304358526ce70d020e4c2606c4acfd1fa1e81fb2","impliedFormat":1},{"version":"3f3edb8e44e3b9df3b7ca3219ab539710b6a7f4fe16bd884d441af207e03cd57","impliedFormat":1},{"version":"528b62e4272e3ddfb50e8eed9e359dedea0a4d171c3eb8f337f4892aac37b24b","impliedFormat":1},{"version":"d71535813e39c23baa113bc4a29a0e187b87d1105ccc8c5a6ebaca38d9a9bff2","impliedFormat":1},{"version":"8cf7e92bdb2862c2d28ba4535c43dc599cfbc0025db5ed9973d9b708dcbe3d98","affectsGlobalScope":true,"impliedFormat":1},{"version":"f72bc8fe16da67e4e3268599295797b202b95e54bd215a03f97e925dd1502a36","impliedFormat":1},{"version":"b1b6ee0d012aeebe11d776a155d8979730440082797695fc8e2a5c326285678f","impliedFormat":1},{"version":"45875bcae57270aeb3ebc73a5e3fb4c7b9d91d6b045f107c1d8513c28ece71c0","impliedFormat":1},{"version":"1dc73f8854e5c4506131c4d95b3a6c24d0c80336d3758e95110f4c7b5cb16397","affectsGlobalScope":true,"impliedFormat":1},{"version":"636302a00dfd1f9fe6e8e91e4e9350c6518dcc8d51a474e4fc3a9ba07135100b","affectsGlobalScope":true,"impliedFormat":1},{"version":"3f16a7e4deafa527ed9995a772bb380eb7d3c2c0fd4ae178c5263ed18394db2c","impliedFormat":1},{"version":"933921f0bb0ec12ef45d1062a1fc0f27635318f4d294e4d99de9a5493e618ca2","impliedFormat":1},{"version":"71a0f3ad612c123b57239a7749770017ecfe6b66411488000aba83e4546fde25","impliedFormat":1},{"version":"8145e07aad6da5f23f2fcd8c8e4c5c13fb26ee986a79d03b0829b8fce152d8b2","impliedFormat":1},{"version":"e1120271ebbc9952fdc7b2dd3e145560e52e06956345e6fdf91d70ca4886464f","impliedFormat":1},{"version":"814118df420c4e38fe5ae1b9a3bafb6e9c2aa40838e528cde908381867be6466","impliedFormat":1},{"version":"e1ce1d622f1e561f6cdf246372ead3bbc07ce0342024d0e9c7caf3136f712698","impliedFormat":1},{"version":"c878f74b6d10b267f6075c51ac1d8becd15b4aa6a58f79c0cfe3b24908357f60","impliedFormat":1},{"version":"37ba7b45141a45ce6e80e66f2a96c8a5ab1bcef0fc2d0f56bb58df96ec67e972","impliedFormat":1},{"version":"125d792ec6c0c0f657d758055c494301cc5fdb327d9d9d5960b3f129aff76093","impliedFormat":1},{"version":"27e4532aaaa1665d0dd19023321e4dc12a35a741d6b8e1ca3517fcc2544e0efe","affectsGlobalScope":true,"impliedFormat":1},{"version":"2754d8221d77c7b382096651925eb476f1066b3348da4b73fe71ced7801edada","impliedFormat":1},{"version":"8c2ad42d5d1a2e8e6112625767f8794d9537f1247907378543106f7ba6c7df90","affectsGlobalScope":true,"impliedFormat":1},{"version":"f0be1b8078cd549d91f37c30c222c2a187ac1cf981d994fb476a1adc61387b14","affectsGlobalScope":true,"impliedFormat":1},{"version":"0aaed1d72199b01234152f7a60046bc947f1f37d78d182e9ae09c4289e06a592","impliedFormat":1},{"version":"98ffdf93dfdd206516971d28e3e473f417a5cfd41172e46b4ce45008f640588e","impliedFormat":1},{"version":"66ba1b2c3e3a3644a1011cd530fb444a96b1b2dfe2f5e837a002d41a1a799e60","impliedFormat":1},{"version":"7e514f5b852fdbc166b539fdd1f4e9114f29911592a5eb10a94bb3a13ccac3c4","impliedFormat":1},{"version":"7d6ff413e198d25639f9f01f16673e7df4e4bd2875a42455afd4ecc02ef156da","affectsGlobalScope":true,"impliedFormat":1},{"version":"12e8ce658dd17662d82fb0509d2057afc5e6ee30369a2e9e0957eff725b1f11d","affectsGlobalScope":true,"impliedFormat":1},{"version":"74736930d108365d7bbe740c7154706ccfb1b2a3855a897963ab3e5c07ecbf19","impliedFormat":1},{"version":"858f999b3e4a45a4e74766d43030941466460bf8768361d254234d5870480a53","impliedFormat":1},{"version":"ac5ed35e649cdd8143131964336ab9076937fa91802ec760b3ea63b59175c10a","impliedFormat":1},{"version":"63b05afa6121657f25e99e1519596b0826cda026f09372c9100dfe21417f4bd6","affectsGlobalScope":true,"impliedFormat":1},{"version":"3797dd6f4ea3dc15f356f8cdd3128bfa18122213b38a80d6c1f05d8e13cbdad8","impliedFormat":1},{"version":"ad90122e1cb599b3bc06a11710eb5489101be678f2920f2322b0ac3e195af78d","impliedFormat":1},{"version":"22293bd6fa12747929f8dfca3ec1684a3fe08638aa18023dd286ab337e88a592","impliedFormat":1},{"version":"916be7d770b0ae0406be9486ac12eb9825f21514961dd050594c4b250617d5a8","impliedFormat":1},{"version":"510616459e6edd01acbce333fb256e06bdffdad43ca233a9090164bf8bb83912","impliedFormat":1},{"version":"4006c872e38a2c4e09c593bc0cdd32b7b4f5c4843910bea0def631c483fff6c5","impliedFormat":1},{"version":"ab6aa3a65d473871ee093e3b7b71ed0f9c69e07d1d4295f45c9efd91a771241d","impliedFormat":1},{"version":"74d5a87c3616cd5d8691059d531504403aa857e09cbaecb1c64dfb9ace0db185","impliedFormat":1}],"root":[75,76,[82,85],[94,97],[132,137]],"options":{"allowJs":true,"checkJs":true,"composite":true,"declaration":true,"declarationMap":true,"emitDeclarationOnly":false,"esModuleInterop":true,"module":101,"noEmitOnError":true,"outDir":"./","removeComments":false,"rewriteRelativeImportExtensions":true,"skipLibCheck":true,"sourceMap":true,"strict":true,"stripInternal":true,"target":11,"verbatimModuleSyntax":true},"referencedMap":[[87,1],[91,1],[89,1],[86,2],[139,3],[140,2],[142,4],[143,2],[144,2],[145,2],[146,2],[147,4],[148,2],[149,2],[150,2],[138,2],[196,5],[197,5],[198,6],[156,7],[199,8],[200,9],[201,10],[151,2],[154,11],[152,2],[153,2],[202,12],[203,13],[204,14],[205,15],[206,16],[207,17],[208,17],[210,18],[209,19],[211,20],[212,21],[213,22],[195,23],[155,2],[214,24],[215,25],[216,26],[249,27],[217,28],[218,29],[219,30],[220,31],[221,32],[222,33],[223,34],[224,35],[225,36],[226,37],[227,37],[228,38],[229,2],[230,2],[231,39],[233,40],[232,41],[234,42],[235,43],[236,44],[237,45],[238,46],[239,47],[240,48],[241,49],[242,50],[243,51],[244,52],[245,53],[246,54],[247,55],[248,56],[250,2],[251,2],[252,2],[253,2],[254,2],[141,2],[255,57],[73,2],[92,58],[157,2],[90,1],[88,59],[93,2],[131,60],[111,2],[103,2],[118,61],[104,62],[121,63],[102,64],[128,65],[126,66],[127,67],[130,66],[129,65],[119,68],[120,69],[105,70],[110,71],[113,72],[115,73],[114,74],[112,75],[116,76],[106,77],[109,78],[107,79],[101,80],[124,81],[123,82],[122,83],[125,84],[100,85],[108,86],[99,2],[117,87],[81,88],[80,89],[79,2],[77,18],[78,90],[74,2],[71,2],[72,2],[12,2],[13,2],[16,2],[15,2],[2,2],[17,2],[18,2],[19,2],[20,2],[21,2],[22,2],[23,2],[24,2],[3,2],[25,2],[26,2],[4,2],[27,2],[31,2],[28,2],[29,2],[30,2],[32,2],[33,2],[34,2],[5,2],[35,2],[36,2],[37,2],[38,2],[6,2],[42,2],[39,2],[40,2],[41,2],[43,2],[7,2],[44,2],[49,2],[50,2],[45,2],[46,2],[47,2],[48,2],[8,2],[54,2],[51,2],[52,2],[53,2],[55,2],[9,2],[56,2],[57,2],[58,2],[60,2],[59,2],[61,2],[62,2],[10,2],[63,2],[64,2],[65,2],[11,2],[66,2],[67,2],[68,2],[69,2],[70,2],[1,2],[14,2],[173,91],[183,92],[172,91],[193,93],[164,94],[163,95],[192,96],[186,97],[191,98],[166,99],[180,100],[165,101],[189,102],[161,103],[160,96],[190,104],[162,105],[167,106],[168,2],[171,106],[158,2],[194,107],[184,108],[175,109],[176,110],[178,111],[174,112],[177,113],[187,96],[169,114],[170,115],[179,116],[159,117],[182,108],[181,106],[185,2],[188,118],[98,2],[85,119],[75,2],[84,120],[82,121],[83,122],[76,2],[97,123],[132,124],[134,125],[135,125],[94,126],[136,127],[137,127],[95,128],[133,129],[96,130]],"latestChangedDtsFile":"./src/index.d.ts","version":"5.8.3"}
\ No newline at end of file
diff --git a/node_modules/mortice/dist/worker-single-thread.js b/node_modules/mortice/dist/worker-single-thread.js
index 057a3e7..afaa514 100644
--- a/node_modules/mortice/dist/worker-single-thread.js
+++ b/node_modules/mortice/dist/worker-single-thread.js
@@ -1,683 +1,806 @@
 "use strict";
 (() => {
-  var __create = Object.create;
-  var __defProp = Object.defineProperty;
-  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
-  var __getOwnPropNames = Object.getOwnPropertyNames;
-  var __getProtoOf = Object.getPrototypeOf;
-  var __hasOwnProp = Object.prototype.hasOwnProperty;
-  var __commonJS = (cb, mod) => function __require() {
-    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
-  };
-  var __copyProps = (to, from, except, desc) => {
-    if (from && typeof from === "object" || typeof from === "function") {
-      for (let key of __getOwnPropNames(from))
-        if (!__hasOwnProp.call(to, key) && key !== except)
-          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
+  // node_modules/abort-error/dist/src/index.js
+  var AbortError = class extends Error {
+    static name = "AbortError";
+    name = "AbortError";
+    constructor(message = "The operation was aborted", ...rest) {
+      super(message, ...rest);
     }
-    return to;
   };
-  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
-    // If the importer is in node compatibility mode or this is not an ESM
-    // file that has been converted to a CommonJS file using a Babel-
-    // compatible transform (i.e. "__esModule" has not been set), then set
-    // "default" to the CommonJS "module.exports" for node compatibility.
-    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
-    mod
-  ));
 
-  // node_modules/eventemitter3/index.js
-  var require_eventemitter3 = __commonJS({
-    "node_modules/eventemitter3/index.js"(exports, module) {
-      "use strict";
-      var has = Object.prototype.hasOwnProperty;
-      var prefix = "~";
-      function Events() {
+  // node_modules/p-defer/index.js
+  function pDefer() {
+    const deferred = {};
+    deferred.promise = new Promise((resolve, reject) => {
+      deferred.resolve = resolve;
+      deferred.reject = reject;
+    });
+    return deferred;
+  }
+
+  // node_modules/it-pushable/dist/src/fifo.js
+  var FixedFIFO = class {
+    buffer;
+    mask;
+    top;
+    btm;
+    next;
+    constructor(hwm) {
+      if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) {
+        throw new Error("Max size for a FixedFIFO should be a power of two");
       }
-      if (Object.create) {
-        Events.prototype = /* @__PURE__ */ Object.create(null);
-        if (!new Events().__proto__) prefix = false;
+      this.buffer = new Array(hwm);
+      this.mask = hwm - 1;
+      this.top = 0;
+      this.btm = 0;
+      this.next = null;
+    }
+    push(data) {
+      if (this.buffer[this.top] !== void 0) {
+        return false;
       }
-      function EE(fn, context, once) {
-        this.fn = fn;
-        this.context = context;
-        this.once = once || false;
+      this.buffer[this.top] = data;
+      this.top = this.top + 1 & this.mask;
+      return true;
+    }
+    shift() {
+      const last = this.buffer[this.btm];
+      if (last === void 0) {
+        return void 0;
       }
-      function addListener(emitter, event, fn, context, once) {
-        if (typeof fn !== "function") {
-          throw new TypeError("The listener must be a function");
-        }
-        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
-        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
-        else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
-        else emitter._events[evt] = [emitter._events[evt], listener];
-        return emitter;
+      this.buffer[this.btm] = void 0;
+      this.btm = this.btm + 1 & this.mask;
+      return last;
+    }
+    isEmpty() {
+      return this.buffer[this.btm] === void 0;
+    }
+  };
+  var FIFO = class {
+    size;
+    hwm;
+    head;
+    tail;
+    constructor(options = {}) {
+      this.hwm = options.splitLimit ?? 16;
+      this.head = new FixedFIFO(this.hwm);
+      this.tail = this.head;
+      this.size = 0;
+    }
+    calculateSize(obj) {
+      if (obj?.byteLength != null) {
+        return obj.byteLength;
       }
-      function clearEvent(emitter, evt) {
-        if (--emitter._eventsCount === 0) emitter._events = new Events();
-        else delete emitter._events[evt];
+      return 1;
+    }
+    push(val) {
+      if (val?.value != null) {
+        this.size += this.calculateSize(val.value);
       }
-      function EventEmitter2() {
-        this._events = new Events();
-        this._eventsCount = 0;
+      if (!this.head.push(val)) {
+        const prev = this.head;
+        this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
+        this.head.push(val);
       }
-      EventEmitter2.prototype.eventNames = function eventNames() {
-        var names = [], events2, name;
-        if (this._eventsCount === 0) return names;
-        for (name in events2 = this._events) {
-          if (has.call(events2, name)) names.push(prefix ? name.slice(1) : name);
-        }
-        if (Object.getOwnPropertySymbols) {
-          return names.concat(Object.getOwnPropertySymbols(events2));
-        }
-        return names;
+    }
+    shift() {
+      let val = this.tail.shift();
+      if (val === void 0 && this.tail.next != null) {
+        const next = this.tail.next;
+        this.tail.next = null;
+        this.tail = next;
+        val = this.tail.shift();
+      }
+      if (val?.value != null) {
+        this.size -= this.calculateSize(val.value);
+      }
+      return val;
+    }
+    isEmpty() {
+      return this.head.isEmpty();
+    }
+  };
+
+  // node_modules/it-pushable/dist/src/index.js
+  var AbortError2 = class extends Error {
+    type;
+    code;
+    constructor(message, code) {
+      super(message ?? "The operation was aborted");
+      this.type = "aborted";
+      this.code = code ?? "ABORT_ERR";
+    }
+  };
+  function pushable(options = {}) {
+    const getNext = (buffer) => {
+      const next = buffer.shift();
+      if (next == null) {
+        return { done: true };
+      }
+      if (next.error != null) {
+        throw next.error;
+      }
+      return {
+        done: next.done === true,
+        // @ts-expect-error if done is false, value will be present
+        value: next.value
       };
-      EventEmitter2.prototype.listeners = function listeners(event) {
-        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
-        if (!handlers) return [];
-        if (handlers.fn) return [handlers.fn];
-        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
-          ee[i] = handlers[i].fn;
+    };
+    return _pushable(getNext, options);
+  }
+  function _pushable(getNext, options) {
+    options = options ?? {};
+    let onEnd = options.onEnd;
+    let buffer = new FIFO();
+    let pushable2;
+    let onNext;
+    let ended;
+    let drain = pDefer();
+    const waitNext = async () => {
+      try {
+        if (!buffer.isEmpty()) {
+          return getNext(buffer);
         }
-        return ee;
-      };
-      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
-        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
-        if (!listeners) return 0;
-        if (listeners.fn) return 1;
-        return listeners.length;
-      };
-      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
-        var evt = prefix ? prefix + event : event;
-        if (!this._events[evt]) return false;
-        var listeners = this._events[evt], len = arguments.length, args, i;
-        if (listeners.fn) {
-          if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
-          switch (len) {
-            case 1:
-              return listeners.fn.call(listeners.context), true;
-            case 2:
-              return listeners.fn.call(listeners.context, a1), true;
-            case 3:
-              return listeners.fn.call(listeners.context, a1, a2), true;
-            case 4:
-              return listeners.fn.call(listeners.context, a1, a2, a3), true;
-            case 5:
-              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
-            case 6:
-              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
-          }
-          for (i = 1, args = new Array(len - 1); i < len; i++) {
-            args[i - 1] = arguments[i];
-          }
-          listeners.fn.apply(listeners.context, args);
-        } else {
-          var length = listeners.length, j;
-          for (i = 0; i < length; i++) {
-            if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
-            switch (len) {
-              case 1:
-                listeners[i].fn.call(listeners[i].context);
-                break;
-              case 2:
-                listeners[i].fn.call(listeners[i].context, a1);
-                break;
-              case 3:
-                listeners[i].fn.call(listeners[i].context, a1, a2);
-                break;
-              case 4:
-                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
-                break;
-              default:
-                if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
-                  args[j - 1] = arguments[j];
-                }
-                listeners[i].fn.apply(listeners[i].context, args);
+        if (ended) {
+          return { done: true };
+        }
+        return await new Promise((resolve, reject) => {
+          onNext = (next) => {
+            onNext = null;
+            buffer.push(next);
+            try {
+              resolve(getNext(buffer));
+            } catch (err) {
+              reject(err);
             }
-          }
+            return pushable2;
+          };
+        });
+      } finally {
+        if (buffer.isEmpty()) {
+          queueMicrotask(() => {
+            drain.resolve();
+            drain = pDefer();
+          });
         }
-        return true;
-      };
-      EventEmitter2.prototype.on = function on(event, fn, context) {
-        return addListener(this, event, fn, context, false);
-      };
-      EventEmitter2.prototype.once = function once(event, fn, context) {
-        return addListener(this, event, fn, context, true);
-      };
-      EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
-        var evt = prefix ? prefix + event : event;
-        if (!this._events[evt]) return this;
-        if (!fn) {
-          clearEvent(this, evt);
-          return this;
+      }
+    };
+    const bufferNext = (next) => {
+      if (onNext != null) {
+        return onNext(next);
+      }
+      buffer.push(next);
+      return pushable2;
+    };
+    const bufferError = (err) => {
+      buffer = new FIFO();
+      if (onNext != null) {
+        return onNext({ error: err });
+      }
+      buffer.push({ error: err });
+      return pushable2;
+    };
+    const push = (value) => {
+      if (ended) {
+        return pushable2;
+      }
+      if (options?.objectMode !== true && value?.byteLength == null) {
+        throw new Error("objectMode was not true but tried to push non-Uint8Array value");
+      }
+      return bufferNext({ done: false, value });
+    };
+    const end = (err) => {
+      if (ended)
+        return pushable2;
+      ended = true;
+      return err != null ? bufferError(err) : bufferNext({ done: true });
+    };
+    const _return = () => {
+      buffer = new FIFO();
+      end();
+      return { done: true };
+    };
+    const _throw = (err) => {
+      end(err);
+      return { done: true };
+    };
+    pushable2 = {
+      [Symbol.asyncIterator]() {
+        return this;
+      },
+      next: waitNext,
+      return: _return,
+      throw: _throw,
+      push,
+      end,
+      get readableLength() {
+        return buffer.size;
+      },
+      onEmpty: async (options2) => {
+        const signal = options2?.signal;
+        signal?.throwIfAborted();
+        if (buffer.isEmpty()) {
+          return;
         }
-        var listeners = this._events[evt];
-        if (listeners.fn) {
-          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
-            clearEvent(this, evt);
-          }
-        } else {
-          for (var i = 0, events2 = [], length = listeners.length; i < length; i++) {
-            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
-              events2.push(listeners[i]);
-            }
+        let cancel;
+        let listener;
+        if (signal != null) {
+          cancel = new Promise((resolve, reject) => {
+            listener = () => {
+              reject(new AbortError2());
+            };
+            signal.addEventListener("abort", listener);
+          });
+        }
+        try {
+          await Promise.race([
+            drain.promise,
+            cancel
+          ]);
+        } finally {
+          if (listener != null && signal != null) {
+            signal?.removeEventListener("abort", listener);
           }
-          if (events2.length) this._events[evt] = events2.length === 1 ? events2[0] : events2;
-          else clearEvent(this, evt);
         }
+      }
+    };
+    if (onEnd == null) {
+      return pushable2;
+    }
+    const _pushable2 = pushable2;
+    pushable2 = {
+      [Symbol.asyncIterator]() {
         return this;
-      };
-      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
-        var evt;
-        if (event) {
-          evt = prefix ? prefix + event : event;
-          if (this._events[evt]) clearEvent(this, evt);
-        } else {
-          this._events = new Events();
-          this._eventsCount = 0;
+      },
+      next() {
+        return _pushable2.next();
+      },
+      throw(err) {
+        _pushable2.throw(err);
+        if (onEnd != null) {
+          onEnd(err);
+          onEnd = void 0;
         }
-        return this;
-      };
-      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
-      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
-      EventEmitter2.prefixed = prefix;
-      EventEmitter2.EventEmitter = EventEmitter2;
-      if ("undefined" !== typeof module) {
-        module.exports = EventEmitter2;
+        return { done: true };
+      },
+      return() {
+        _pushable2.return();
+        if (onEnd != null) {
+          onEnd();
+          onEnd = void 0;
+        }
+        return { done: true };
+      },
+      push,
+      end(err) {
+        _pushable2.end(err);
+        if (onEnd != null) {
+          onEnd(err);
+          onEnd = void 0;
+        }
+        return pushable2;
+      },
+      get readableLength() {
+        return _pushable2.readableLength;
+      },
+      onEmpty: (opts) => {
+        return _pushable2.onEmpty(opts);
       }
-    }
-  });
-
-  // node_modules/abort-error/dist/src/index.js
-  var AbortError = class extends Error {
-    static name = "AbortError";
-    name = "AbortError";
-    constructor(message = "The operation was aborted", ...rest) {
-      super(message, ...rest);
-    }
-  };
+    };
+    return pushable2;
+  }
 
-  // node_modules/eventemitter3/index.mjs
-  var import_index = __toESM(require_eventemitter3(), 1);
+  // node_modules/main-event/dist/src/events.browser.js
+  function setMaxListeners() {
+  }
 
-  // node_modules/p-timeout/index.js
-  var TimeoutError = class extends Error {
-    constructor(message) {
-      super(message);
-      this.name = "TimeoutError";
+  // node_modules/main-event/dist/src/index.js
+  var TypedEventEmitter = class extends EventTarget {
+    #listeners = /* @__PURE__ */ new Map();
+    constructor() {
+      super();
+      setMaxListeners(Infinity, this);
+    }
+    listenerCount(type) {
+      const listeners = this.#listeners.get(type);
+      if (listeners == null) {
+        return 0;
+      }
+      return listeners.length;
+    }
+    addEventListener(type, listener, options) {
+      super.addEventListener(type, listener, options);
+      let list = this.#listeners.get(type);
+      if (list == null) {
+        list = [];
+        this.#listeners.set(type, list);
+      }
+      list.push({
+        callback: listener,
+        once: (options !== true && options !== false && options?.once) ?? false
+      });
+    }
+    removeEventListener(type, listener, options) {
+      super.removeEventListener(type.toString(), listener ?? null, options);
+      let list = this.#listeners.get(type);
+      if (list == null) {
+        return;
+      }
+      list = list.filter(({ callback }) => callback !== listener);
+      this.#listeners.set(type, list);
+    }
+    dispatchEvent(event) {
+      const result = super.dispatchEvent(event);
+      let list = this.#listeners.get(event.type);
+      if (list == null) {
+        return result;
+      }
+      list = list.filter(({ once }) => !once);
+      this.#listeners.set(event.type, list);
+      return result;
+    }
+    safeDispatchEvent(type, detail = {}) {
+      return this.dispatchEvent(new CustomEvent(type, detail));
     }
   };
-  var AbortError2 = class extends Error {
-    constructor(message) {
-      super();
+
+  // node_modules/race-event/dist/src/index.js
+  var AbortError3 = class extends Error {
+    type;
+    code;
+    constructor(message, code) {
+      super(message ?? "The operation was aborted");
+      this.type = "aborted";
       this.name = "AbortError";
-      this.message = message;
+      this.code = code ?? "ABORT_ERR";
     }
   };
-  var getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError2(errorMessage) : new DOMException(errorMessage);
-  var getAbortedReason = (signal) => {
-    const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
-    return reason instanceof Error ? reason : getDOMException(reason);
-  };
-  function pTimeout(promise, options) {
-    const {
-      milliseconds,
-      fallback,
-      message,
-      customTimers = { setTimeout, clearTimeout }
-    } = options;
-    let timer;
-    let abortHandler;
-    const wrappedPromise = new Promise((resolve, reject) => {
-      if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
-        throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
-      }
-      if (options.signal) {
-        const { signal } = options;
-        if (signal.aborted) {
-          reject(getAbortedReason(signal));
+  async function raceEvent(emitter, eventName, signal, opts) {
+    const error = new AbortError3(opts?.errorMessage, opts?.errorCode);
+    if (signal?.aborted === true) {
+      return Promise.reject(error);
+    }
+    return new Promise((resolve, reject) => {
+      function removeListeners() {
+        signal?.removeEventListener("abort", abortListener);
+        emitter.removeEventListener(eventName, eventListener);
+        if (opts?.errorEvent != null) {
+          emitter.removeEventListener(opts.errorEvent, errorEventListener);
         }
-        abortHandler = () => {
-          reject(getAbortedReason(signal));
-        };
-        signal.addEventListener("abort", abortHandler, { once: true });
-      }
-      if (milliseconds === Number.POSITIVE_INFINITY) {
-        promise.then(resolve, reject);
-        return;
       }
-      const timeoutError = new TimeoutError();
-      timer = customTimers.setTimeout.call(void 0, () => {
-        if (fallback) {
-          try {
-            resolve(fallback());
-          } catch (error) {
-            reject(error);
+      const eventListener = (evt) => {
+        try {
+          if (opts?.filter?.(evt) === false) {
+            return;
           }
+        } catch (err) {
+          removeListeners();
+          reject(err);
           return;
         }
-        if (typeof promise.cancel === "function") {
-          promise.cancel();
-        }
-        if (message === false) {
-          resolve();
-        } else if (message instanceof Error) {
-          reject(message);
-        } else {
-          timeoutError.message = message ?? `Promise timed out after ${milliseconds} milliseconds`;
-          reject(timeoutError);
-        }
-      }, milliseconds);
-      (async () => {
-        try {
-          resolve(await promise);
-        } catch (error) {
-          reject(error);
-        }
-      })();
-    });
-    const cancelablePromise = wrappedPromise.finally(() => {
-      cancelablePromise.clear();
-      if (abortHandler && options.signal) {
-        options.signal.removeEventListener("abort", abortHandler);
+        removeListeners();
+        resolve(evt);
+      };
+      const errorEventListener = (evt) => {
+        removeListeners();
+        reject(evt.detail);
+      };
+      const abortListener = () => {
+        removeListeners();
+        reject(error);
+      };
+      signal?.addEventListener("abort", abortListener);
+      emitter.addEventListener(eventName, eventListener);
+      if (opts?.errorEvent != null) {
+        emitter.addEventListener(opts.errorEvent, errorEventListener);
       }
     });
-    cancelablePromise.clear = () => {
-      customTimers.clearTimeout.call(void 0, timer);
-      timer = void 0;
-    };
-    return cancelablePromise;
   }
 
-  // node_modules/p-queue/dist/lower-bound.js
-  function lowerBound(array, value, comparator) {
-    let first = 0;
-    let count = array.length;
-    while (count > 0) {
-      const step = Math.trunc(count / 2);
-      let it = first + step;
-      if (comparator(array[it], value) <= 0) {
-        first = ++it;
-        count -= step + 1;
-      } else {
-        count = step;
-      }
+  // node_modules/it-queue/dist/src/errors.js
+  var QueueFullError = class extends Error {
+    static name = "QueueFullError";
+    constructor(message = "The queue was full") {
+      super(message);
+      this.name = "QueueFullError";
     }
-    return first;
-  }
+  };
 
-  // node_modules/p-queue/dist/priority-queue.js
-  var PriorityQueue = class {
-    #queue = [];
-    enqueue(run2, options) {
-      options = {
-        priority: 0,
-        ...options
-      };
-      const element = {
-        priority: options.priority,
-        id: options.id,
-        run: run2
-      };
-      if (this.size === 0 || this.#queue[this.size - 1].priority >= options.priority) {
-        this.#queue.push(element);
-        return;
-      }
-      const index = lowerBound(this.#queue, element, (a, b) => b.priority - a.priority);
-      this.#queue.splice(index, 0, element);
+  // node_modules/race-signal/dist/src/index.js
+  var AbortError4 = class extends Error {
+    type;
+    code;
+    constructor(message, code, name) {
+      super(message ?? "The operation was aborted");
+      this.type = "aborted";
+      this.name = name ?? "AbortError";
+      this.code = code ?? "ABORT_ERR";
+    }
+  };
+  async function raceSignal(promise, signal, opts) {
+    if (signal == null) {
+      return promise;
+    }
+    if (signal.aborted) {
+      promise.catch(() => {
+      });
+      return Promise.reject(new AbortError4(opts?.errorMessage, opts?.errorCode, opts?.errorName));
     }
-    setPriority(id, priority) {
-      const index = this.#queue.findIndex((element) => element.id === id);
-      if (index === -1) {
-        throw new ReferenceError(`No promise function with the id "${id}" exists in the queue.`);
+    let listener;
+    const error = new AbortError4(opts?.errorMessage, opts?.errorCode, opts?.errorName);
+    try {
+      return await Promise.race([
+        promise,
+        new Promise((resolve, reject) => {
+          listener = () => {
+            reject(error);
+          };
+          signal.addEventListener("abort", listener);
+        })
+      ]);
+    } finally {
+      if (listener != null) {
+        signal.removeEventListener("abort", listener);
       }
-      const [item] = this.#queue.splice(index, 1);
-      this.enqueue(item.run, { priority, id });
     }
-    dequeue() {
-      const item = this.#queue.shift();
-      return item?.run;
+  }
+
+  // node_modules/it-queue/dist/src/recipient.js
+  var JobRecipient = class {
+    deferred;
+    signal;
+    constructor(signal) {
+      this.signal = signal;
+      this.deferred = Promise.withResolvers();
+      this.onAbort = this.onAbort.bind(this);
+      this.signal?.addEventListener("abort", this.onAbort);
     }
-    filter(options) {
-      return this.#queue.filter((element) => element.priority === options.priority).map((element) => element.run);
+    onAbort() {
+      this.deferred.reject(this.signal?.reason ?? new AbortError());
     }
-    get size() {
-      return this.#queue.length;
+    cleanup() {
+      this.signal?.removeEventListener("abort", this.onAbort);
     }
   };
 
-  // node_modules/p-queue/dist/index.js
-  var PQueue = class extends import_index.default {
-    #carryoverConcurrencyCount;
-    #isIntervalIgnored;
-    #intervalCount = 0;
-    #intervalCap;
-    #interval;
-    #intervalEnd = 0;
-    #intervalId;
-    #timeoutId;
-    #queue;
-    #queueClass;
-    #pending = 0;
-    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194
-    #concurrency;
-    #isPaused;
-    #throwOnTimeout;
-    // Use to assign a unique identifier to a promise function, if not explicitly specified
-    #idAssigner = 1n;
-    /**
-        Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.
-    
-        Applies to each future operation.
-        */
-    timeout;
-    // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`
-    constructor(options) {
-      super();
-      options = {
-        carryoverConcurrencyCount: false,
-        intervalCap: Number.POSITIVE_INFINITY,
-        interval: 0,
-        concurrency: Number.POSITIVE_INFINITY,
-        autoStart: true,
-        queueClass: PriorityQueue,
-        ...options
+  // node_modules/it-queue/dist/src/job.js
+  function randomId() {
+    return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
+  }
+  var Job = class {
+    id;
+    fn;
+    options;
+    recipients;
+    status;
+    timeline;
+    controller;
+    constructor(fn, options) {
+      this.id = randomId();
+      this.status = "queued";
+      this.fn = fn;
+      this.options = options;
+      this.recipients = [];
+      this.timeline = {
+        created: Date.now()
       };
-      if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
-        throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${options.intervalCap?.toString() ?? ""}\` (${typeof options.intervalCap})`);
+      this.controller = new AbortController();
+      setMaxListeners(Infinity, this.controller.signal);
+      this.onAbort = this.onAbort.bind(this);
+    }
+    abort(err) {
+      this.controller.abort(err);
+    }
+    onAbort() {
+      const allAborted = this.recipients.reduce((acc, curr) => {
+        return acc && curr.signal?.aborted === true;
+      }, true);
+      if (allAborted) {
+        this.controller.abort(new AbortError());
+        this.cleanup();
       }
-      if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
-        throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${options.interval?.toString() ?? ""}\` (${typeof options.interval})`);
+    }
+    async join(options = {}) {
+      const recipient = new JobRecipient(options.signal);
+      this.recipients.push(recipient);
+      options.signal?.addEventListener("abort", this.onAbort);
+      return recipient.deferred.promise;
+    }
+    async run() {
+      this.status = "running";
+      this.timeline.started = Date.now();
+      try {
+        this.controller.signal.throwIfAborted();
+        const result = await raceSignal(this.fn({
+          ...this.options ?? {},
+          signal: this.controller.signal
+        }), this.controller.signal);
+        this.recipients.forEach((recipient) => {
+          recipient.deferred.resolve(result);
+        });
+        this.status = "complete";
+      } catch (err) {
+        this.recipients.forEach((recipient) => {
+          recipient.deferred.reject(err);
+        });
+        this.status = "errored";
+      } finally {
+        this.timeline.finished = Date.now();
+        this.cleanup();
       }
-      this.#carryoverConcurrencyCount = options.carryoverConcurrencyCount;
-      this.#isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;
-      this.#intervalCap = options.intervalCap;
-      this.#interval = options.interval;
-      this.#queue = new options.queueClass();
-      this.#queueClass = options.queueClass;
-      this.concurrency = options.concurrency;
-      this.timeout = options.timeout;
-      this.#throwOnTimeout = options.throwOnTimeout === true;
-      this.#isPaused = options.autoStart === false;
     }
-    get #doesIntervalAllowAnother() {
-      return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;
+    cleanup() {
+      this.recipients.forEach((recipient) => {
+        recipient.cleanup();
+        recipient.signal?.removeEventListener("abort", this.onAbort);
+      });
     }
-    get #doesConcurrentAllowAnother() {
-      return this.#pending < this.#concurrency;
+  };
+
+  // node_modules/it-queue/dist/src/utils.js
+  function debounce(func, wait) {
+    let timeout;
+    const output = function() {
+      const later = function() {
+        timeout = void 0;
+        void func();
+      };
+      clearTimeout(timeout);
+      timeout = setTimeout(later, wait);
+    };
+    output.start = () => {
+    };
+    output.stop = () => {
+      clearTimeout(timeout);
+    };
+    return output;
+  }
+
+  // node_modules/it-queue/dist/src/index.js
+  var Queue = class extends TypedEventEmitter {
+    concurrency;
+    maxSize;
+    queue;
+    pending;
+    sort;
+    autoStart;
+    constructor(init = {}) {
+      super();
+      this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY;
+      this.maxSize = init.maxSize ?? Number.POSITIVE_INFINITY;
+      this.pending = 0;
+      this.autoStart = init.autoStart ?? true;
+      this.sort = init.sort;
+      this.queue = [];
+      this.emitEmpty = debounce(this.emitEmpty.bind(this), 1);
+      this.emitIdle = debounce(this.emitIdle.bind(this), 1);
     }
-    #next() {
-      this.#pending--;
-      this.#tryToStartAnother();
-      this.emit("next");
+    [Symbol.asyncIterator]() {
+      return this.toGenerator();
     }
-    #onResumeInterval() {
-      this.#onInterval();
-      this.#initializeIntervalIfNeeded();
-      this.#timeoutId = void 0;
+    emitEmpty() {
+      if (this.size !== 0) {
+        return;
+      }
+      this.safeDispatchEvent("empty");
     }
-    get #isIntervalPaused() {
-      const now = Date.now();
-      if (this.#intervalId === void 0) {
-        const delay2 = this.#intervalEnd - now;
-        if (delay2 < 0) {
-          this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;
-        } else {
-          if (this.#timeoutId === void 0) {
-            this.#timeoutId = setTimeout(() => {
-              this.#onResumeInterval();
-            }, delay2);
-          }
-          return true;
-        }
+    emitIdle() {
+      if (this.running !== 0) {
+        return;
       }
-      return false;
+      this.safeDispatchEvent("idle");
     }
-    #tryToStartAnother() {
-      if (this.#queue.size === 0) {
-        if (this.#intervalId) {
-          clearInterval(this.#intervalId);
-        }
-        this.#intervalId = void 0;
-        this.emit("empty");
-        if (this.#pending === 0) {
-          this.emit("idle");
+    tryToStartAnother() {
+      if (this.size === 0) {
+        this.emitEmpty();
+        if (this.running === 0) {
+          this.emitIdle();
         }
         return false;
       }
-      if (!this.#isPaused) {
-        const canInitializeInterval = !this.#isIntervalPaused;
-        if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {
-          const job = this.#queue.dequeue();
-          if (!job) {
-            return false;
+      if (this.pending < this.concurrency) {
+        let job;
+        for (const j of this.queue) {
+          if (j.status === "queued") {
+            job = j;
+            break;
           }
-          this.emit("active");
-          job();
-          if (canInitializeInterval) {
-            this.#initializeIntervalIfNeeded();
-          }
-          return true;
         }
+        if (job == null) {
+          return false;
+        }
+        this.safeDispatchEvent("active");
+        this.pending++;
+        void job.run().finally(() => {
+          for (let i = 0; i < this.queue.length; i++) {
+            if (this.queue[i] === job) {
+              this.queue.splice(i, 1);
+              break;
+            }
+          }
+          this.pending--;
+          this.tryToStartAnother();
+          this.safeDispatchEvent("next");
+        });
+        return true;
       }
       return false;
     }
-    #initializeIntervalIfNeeded() {
-      if (this.#isIntervalIgnored || this.#intervalId !== void 0) {
-        return;
+    enqueue(job) {
+      this.queue.push(job);
+      if (this.sort != null) {
+        this.queue.sort(this.sort);
       }
-      this.#intervalId = setInterval(() => {
-        this.#onInterval();
-      }, this.#interval);
-      this.#intervalEnd = Date.now() + this.#interval;
     }
-    #onInterval() {
-      if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {
-        clearInterval(this.#intervalId);
-        this.#intervalId = void 0;
+    /**
+     * Start the queue. If the `autoStart` parameter passed to the constructor was
+     * not `false` this is a no-op
+     */
+    start() {
+      if (this.autoStart !== false) {
+        return;
       }
-      this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;
-      this.#processQueue();
+      this.autoStart = true;
+      this.tryToStartAnother();
     }
     /**
-    Executes all queued functions until it reaches the limit.
-    */
-    #processQueue() {
-      while (this.#tryToStartAnother()) {
+     * Adds a sync or async task to the queue. Always returns a promise.
+     */
+    async add(fn, options) {
+      options?.signal?.throwIfAborted();
+      if (this.size === this.maxSize) {
+        throw new QueueFullError();
       }
-    }
-    get concurrency() {
-      return this.#concurrency;
-    }
-    set concurrency(newConcurrency) {
-      if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
-        throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
+      const job = new Job(fn, options);
+      this.enqueue(job);
+      this.safeDispatchEvent("add");
+      if (this.autoStart) {
+        this.tryToStartAnother();
       }
-      this.#concurrency = newConcurrency;
-      this.#processQueue();
-    }
-    async #throwOnAbort(signal) {
-      return new Promise((_resolve, reject) => {
-        signal.addEventListener("abort", () => {
-          reject(signal.reason);
-        }, { once: true });
-      });
-    }
-    /**
-        Updates the priority of a promise function by its id, affecting its execution order. Requires a defined concurrency limit to take effect.
-    
-        For example, this can be used to prioritize a promise function to run earlier.
-    
-        ```js
-        import PQueue from 'p-queue';
-    
-        const queue = new PQueue({concurrency: 1});
-    
-        queue.add(async () => '', {priority: 1});
-        queue.add(async () => '', {priority: 0, id: ''});
-        queue.add(async () => '', {priority: 1});
-        queue.add(async () => '', {priority: 1});
-    
-        queue.setPriority('', 2);
-        ```
-    
-        In this case, the promise function with `id: ''` runs second.
-    
-        You can also deprioritize a promise function to delay its execution:
-    
-        ```js
-        import PQueue from 'p-queue';
-    
-        const queue = new PQueue({concurrency: 1});
-    
-        queue.add(async () => '', {priority: 1});
-        queue.add(async () => '', {priority: 1, id: ''});
-        queue.add(async () => '');
-        queue.add(async () => '', {priority: 0});
-    
-        queue.setPriority('', -1);
-        ```
-        Here, the promise function with `id: ''` executes last.
-        */
-    setPriority(id, priority) {
-      this.#queue.setPriority(id, priority);
-    }
-    async add(function_, options = {}) {
-      options.id ??= (this.#idAssigner++).toString();
-      options = {
-        timeout: this.timeout,
-        throwOnTimeout: this.#throwOnTimeout,
-        ...options
-      };
-      return new Promise((resolve, reject) => {
-        this.#queue.enqueue(async () => {
-          this.#pending++;
-          this.#intervalCount++;
-          try {
-            options.signal?.throwIfAborted();
-            let operation = function_({ signal: options.signal });
-            if (options.timeout) {
-              operation = pTimeout(Promise.resolve(operation), { milliseconds: options.timeout });
-            }
-            if (options.signal) {
-              operation = Promise.race([operation, this.#throwOnAbort(options.signal)]);
-            }
-            const result = await operation;
-            resolve(result);
-            this.emit("completed", result);
-          } catch (error) {
-            if (error instanceof TimeoutError && !options.throwOnTimeout) {
-              resolve();
-              return;
+      return job.join(options).then((result) => {
+        this.safeDispatchEvent("success", { detail: { job, result } });
+        return result;
+      }).catch((err) => {
+        if (job.status === "queued") {
+          for (let i = 0; i < this.queue.length; i++) {
+            if (this.queue[i] === job) {
+              this.queue.splice(i, 1);
+              break;
             }
-            reject(error);
-            this.emit("error", error);
-          } finally {
-            this.#next();
           }
-        }, options);
-        this.emit("add");
-        this.#tryToStartAnother();
+        }
+        this.safeDispatchEvent("failure", { detail: { job, error: err } });
+        throw err;
       });
     }
-    async addAll(functions, options) {
-      return Promise.all(functions.map(async (function_) => this.add(function_, options)));
-    }
-    /**
-    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
-    */
-    start() {
-      if (!this.#isPaused) {
-        return this;
-      }
-      this.#isPaused = false;
-      this.#processQueue();
-      return this;
-    }
     /**
-    Put queue execution on hold.
-    */
-    pause() {
-      this.#isPaused = true;
+     * Clear the queue
+     */
+    clear() {
+      this.queue.splice(0, this.queue.length);
     }
     /**
-    Clear the queue.
-    */
-    clear() {
-      this.#queue = new this.#queueClass();
+     * Abort all jobs in the queue and clear it
+     */
+    abort() {
+      this.queue.forEach((job) => {
+        job.abort(new AbortError());
+      });
+      this.clear();
     }
     /**
-        Can be called multiple times. Useful if you for example add additional items at a later time.
-    
-        @returns A promise that settles when the queue becomes empty.
-        */
-    async onEmpty() {
-      if (this.#queue.size === 0) {
+     * Can be called multiple times. Useful if you for example add additional items at a later time.
+     *
+     * @returns A promise that settles when the queue becomes empty.
+     */
+    async onEmpty(options) {
+      if (this.size === 0) {
         return;
       }
-      await this.#onEvent("empty");
+      await raceEvent(this, "empty", options?.signal);
     }
     /**
-        @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
-    
-        If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
-    
-        Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
-        */
-    async onSizeLessThan(limit) {
-      if (this.#queue.size < limit) {
+     * @returns A promise that settles when the queue size is less than the given
+     * limit: `queue.size < limit`.
+     *
+     * If you want to avoid having the queue grow beyond a certain size you can
+     * `await queue.onSizeLessThan()` before adding a new item.
+     *
+     * Note that this only limits the number of items waiting to start. There
+     * could still be up to `concurrency` jobs already running that this call does
+     * not include in its calculation.
+     */
+    async onSizeLessThan(limit, options) {
+      if (this.size < limit) {
         return;
       }
-      await this.#onEvent("next", () => this.#queue.size < limit);
+      await raceEvent(this, "next", options?.signal, {
+        filter: () => this.size < limit
+      });
     }
     /**
-        The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
-    
-        @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
-        */
-    async onIdle() {
-      if (this.#pending === 0 && this.#queue.size === 0) {
+     * The difference with `.onEmpty` is that `.onIdle` guarantees that all work
+     * from the queue has finished. `.onEmpty` merely signals that the queue is
+     * empty, but it could mean that some promises haven't completed yet.
+     *
+     * @returns A promise that settles when the queue becomes empty, and all
+     * promises have completed; `queue.size === 0 && queue.pending === 0`.
+     */
+    async onIdle(options) {
+      if (this.pending === 0 && this.size === 0) {
         return;
       }
-      await this.#onEvent("idle");
-    }
-    async #onEvent(event, filter) {
-      return new Promise((resolve) => {
-        const listener = () => {
-          if (filter && !filter()) {
-            return;
-          }
-          this.off(event, listener);
-          resolve();
-        };
-        this.on(event, listener);
-      });
+      await raceEvent(this, "idle", options?.signal);
     }
     /**
-    Size of the queue, the number of queued items waiting to run.
-    */
+     * Size of the queue including running items
+     */
     get size() {
-      return this.#queue.size;
+      return this.queue.length;
     }
     /**
-        Size of the queue, filtered by the given options.
-    
-        For example, this can be used to find the number of items remaining in the queue with a specific priority level.
-        */
-    sizeBy(options) {
-      return this.#queue.filter(options).length;
+     * The number of queued items waiting to run.
+     */
+    get queued() {
+      return this.queue.length - this.pending;
     }
     /**
-    Number of running items (no longer in the queue).
-    */
-    get pending() {
-      return this.#pending;
+     * The number of items currently running.
+     */
+    get running() {
+      return this.pending;
     }
     /**
-    Whether the queue is currently paused.
-    */
-    get isPaused() {
-      return this.#isPaused;
+     * Returns an async generator that makes it easy to iterate over the results
+     * of jobs added to the queue.
+     *
+     * The generator will end when the queue becomes idle, that is there are no
+     * jobs running and no jobs that have yet to run.
+     *
+     * If you need to keep the queue open indefinitely, consider using it-pushable
+     * instead.
+     */
+    async *toGenerator(options) {
+      options?.signal?.throwIfAborted();
+      const stream = pushable({
+        objectMode: true
+      });
+      const cleanup = (err) => {
+        if (err != null) {
+          this.abort();
+        } else {
+          this.clear();
+        }
+        stream.end(err);
+      };
+      const onQueueJobComplete = (evt) => {
+        if (evt.detail != null) {
+          stream.push(evt.detail.result);
+        }
+      };
+      const onQueueError = (evt) => {
+        cleanup(evt.detail.error);
+      };
+      const onQueueIdle = () => {
+        cleanup();
+      };
+      const onSignalAbort = () => {
+        cleanup(new AbortError("Queue aborted"));
+      };
+      this.addEventListener("success", onQueueJobComplete);
+      this.addEventListener("failure", onQueueError);
+      this.addEventListener("idle", onQueueIdle);
+      options?.signal?.addEventListener("abort", onSignalAbort);
+      try {
+        yield* stream;
+      } finally {
+        this.removeEventListener("success", onQueueJobComplete);
+        this.removeEventListener("failure", onQueueError);
+        this.removeEventListener("idle", onQueueIdle);
+        options?.signal?.removeEventListener("abort", onSignalAbort);
+        cleanup();
+      }
     }
   };
 
@@ -882,17 +1005,21 @@
     if (implementation.isWorker === true) {
       return {
         readLock: implementation.readLock(name, options),
-        writeLock: implementation.writeLock(name, options)
+        writeLock: implementation.writeLock(name, options),
+        cleanUp: () => {
+        }
       };
     }
-    const masterQueue = new PQueue({ concurrency: 1 });
+    const masterQueue = new Queue({
+      concurrency: 1
+    });
     let readQueue;
     return {
       async readLock(opts) {
         if (readQueue != null) {
           return createReleaseable(readQueue, opts);
         }
-        readQueue = new PQueue({
+        readQueue = new Queue({
           concurrency: options.concurrency,
           autoStart: false
         });
@@ -911,7 +1038,11 @@
       async writeLock(opts) {
         readQueue = null;
         return createReleaseable(masterQueue, opts);
-      }
+      },
+      cleanUp: () => {
+        delete mutexes[name];
+      },
+      queue: masterQueue
     };
   };
   var defaultOptions2 = {
@@ -1026,11 +1157,13 @@
   var delay_default = delay;
 
   // test/fixtures/lock.ts
-  async function lock(type, muxex, counts, result, timeout = 0) {
+  async function lock(type, mutex, counts, result, timeout = 0, signal) {
     counts[type]++;
     const index = counts[type];
     result.push(`${type} ${index} waiting`);
-    const release = await muxex[`${type}Lock`]();
+    const release = await mutex[`${type}Lock`]({
+      signal
+    });
     result.push(`${type} ${index} start`);
     if (timeout > 0) {
       await delay_default(timeout);
diff --git a/node_modules/mortice/dist/worker.js b/node_modules/mortice/dist/worker.js
index 8bf98e0..caf62f5 100644
--- a/node_modules/mortice/dist/worker.js
+++ b/node_modules/mortice/dist/worker.js
@@ -1,683 +1,806 @@
 "use strict";
 (() => {
-  var __create = Object.create;
-  var __defProp = Object.defineProperty;
-  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
-  var __getOwnPropNames = Object.getOwnPropertyNames;
-  var __getProtoOf = Object.getPrototypeOf;
-  var __hasOwnProp = Object.prototype.hasOwnProperty;
-  var __commonJS = (cb, mod) => function __require() {
-    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
-  };
-  var __copyProps = (to, from, except, desc) => {
-    if (from && typeof from === "object" || typeof from === "function") {
-      for (let key of __getOwnPropNames(from))
-        if (!__hasOwnProp.call(to, key) && key !== except)
-          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
+  // node_modules/abort-error/dist/src/index.js
+  var AbortError = class extends Error {
+    static name = "AbortError";
+    name = "AbortError";
+    constructor(message = "The operation was aborted", ...rest) {
+      super(message, ...rest);
     }
-    return to;
   };
-  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
-    // If the importer is in node compatibility mode or this is not an ESM
-    // file that has been converted to a CommonJS file using a Babel-
-    // compatible transform (i.e. "__esModule" has not been set), then set
-    // "default" to the CommonJS "module.exports" for node compatibility.
-    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
-    mod
-  ));
 
-  // node_modules/eventemitter3/index.js
-  var require_eventemitter3 = __commonJS({
-    "node_modules/eventemitter3/index.js"(exports, module) {
-      "use strict";
-      var has = Object.prototype.hasOwnProperty;
-      var prefix = "~";
-      function Events() {
+  // node_modules/p-defer/index.js
+  function pDefer() {
+    const deferred = {};
+    deferred.promise = new Promise((resolve, reject) => {
+      deferred.resolve = resolve;
+      deferred.reject = reject;
+    });
+    return deferred;
+  }
+
+  // node_modules/it-pushable/dist/src/fifo.js
+  var FixedFIFO = class {
+    buffer;
+    mask;
+    top;
+    btm;
+    next;
+    constructor(hwm) {
+      if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) {
+        throw new Error("Max size for a FixedFIFO should be a power of two");
       }
-      if (Object.create) {
-        Events.prototype = /* @__PURE__ */ Object.create(null);
-        if (!new Events().__proto__) prefix = false;
+      this.buffer = new Array(hwm);
+      this.mask = hwm - 1;
+      this.top = 0;
+      this.btm = 0;
+      this.next = null;
+    }
+    push(data) {
+      if (this.buffer[this.top] !== void 0) {
+        return false;
       }
-      function EE(fn, context, once) {
-        this.fn = fn;
-        this.context = context;
-        this.once = once || false;
+      this.buffer[this.top] = data;
+      this.top = this.top + 1 & this.mask;
+      return true;
+    }
+    shift() {
+      const last = this.buffer[this.btm];
+      if (last === void 0) {
+        return void 0;
       }
-      function addListener(emitter, event, fn, context, once) {
-        if (typeof fn !== "function") {
-          throw new TypeError("The listener must be a function");
-        }
-        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
-        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
-        else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
-        else emitter._events[evt] = [emitter._events[evt], listener];
-        return emitter;
+      this.buffer[this.btm] = void 0;
+      this.btm = this.btm + 1 & this.mask;
+      return last;
+    }
+    isEmpty() {
+      return this.buffer[this.btm] === void 0;
+    }
+  };
+  var FIFO = class {
+    size;
+    hwm;
+    head;
+    tail;
+    constructor(options = {}) {
+      this.hwm = options.splitLimit ?? 16;
+      this.head = new FixedFIFO(this.hwm);
+      this.tail = this.head;
+      this.size = 0;
+    }
+    calculateSize(obj) {
+      if (obj?.byteLength != null) {
+        return obj.byteLength;
       }
-      function clearEvent(emitter, evt) {
-        if (--emitter._eventsCount === 0) emitter._events = new Events();
-        else delete emitter._events[evt];
+      return 1;
+    }
+    push(val) {
+      if (val?.value != null) {
+        this.size += this.calculateSize(val.value);
       }
-      function EventEmitter2() {
-        this._events = new Events();
-        this._eventsCount = 0;
+      if (!this.head.push(val)) {
+        const prev = this.head;
+        this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
+        this.head.push(val);
       }
-      EventEmitter2.prototype.eventNames = function eventNames() {
-        var names = [], events2, name;
-        if (this._eventsCount === 0) return names;
-        for (name in events2 = this._events) {
-          if (has.call(events2, name)) names.push(prefix ? name.slice(1) : name);
-        }
-        if (Object.getOwnPropertySymbols) {
-          return names.concat(Object.getOwnPropertySymbols(events2));
-        }
-        return names;
+    }
+    shift() {
+      let val = this.tail.shift();
+      if (val === void 0 && this.tail.next != null) {
+        const next = this.tail.next;
+        this.tail.next = null;
+        this.tail = next;
+        val = this.tail.shift();
+      }
+      if (val?.value != null) {
+        this.size -= this.calculateSize(val.value);
+      }
+      return val;
+    }
+    isEmpty() {
+      return this.head.isEmpty();
+    }
+  };
+
+  // node_modules/it-pushable/dist/src/index.js
+  var AbortError2 = class extends Error {
+    type;
+    code;
+    constructor(message, code) {
+      super(message ?? "The operation was aborted");
+      this.type = "aborted";
+      this.code = code ?? "ABORT_ERR";
+    }
+  };
+  function pushable(options = {}) {
+    const getNext = (buffer) => {
+      const next = buffer.shift();
+      if (next == null) {
+        return { done: true };
+      }
+      if (next.error != null) {
+        throw next.error;
+      }
+      return {
+        done: next.done === true,
+        // @ts-expect-error if done is false, value will be present
+        value: next.value
       };
-      EventEmitter2.prototype.listeners = function listeners(event) {
-        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
-        if (!handlers) return [];
-        if (handlers.fn) return [handlers.fn];
-        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
-          ee[i] = handlers[i].fn;
+    };
+    return _pushable(getNext, options);
+  }
+  function _pushable(getNext, options) {
+    options = options ?? {};
+    let onEnd = options.onEnd;
+    let buffer = new FIFO();
+    let pushable2;
+    let onNext;
+    let ended;
+    let drain = pDefer();
+    const waitNext = async () => {
+      try {
+        if (!buffer.isEmpty()) {
+          return getNext(buffer);
         }
-        return ee;
-      };
-      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
-        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
-        if (!listeners) return 0;
-        if (listeners.fn) return 1;
-        return listeners.length;
-      };
-      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
-        var evt = prefix ? prefix + event : event;
-        if (!this._events[evt]) return false;
-        var listeners = this._events[evt], len = arguments.length, args, i;
-        if (listeners.fn) {
-          if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
-          switch (len) {
-            case 1:
-              return listeners.fn.call(listeners.context), true;
-            case 2:
-              return listeners.fn.call(listeners.context, a1), true;
-            case 3:
-              return listeners.fn.call(listeners.context, a1, a2), true;
-            case 4:
-              return listeners.fn.call(listeners.context, a1, a2, a3), true;
-            case 5:
-              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
-            case 6:
-              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
-          }
-          for (i = 1, args = new Array(len - 1); i < len; i++) {
-            args[i - 1] = arguments[i];
-          }
-          listeners.fn.apply(listeners.context, args);
-        } else {
-          var length = listeners.length, j;
-          for (i = 0; i < length; i++) {
-            if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
-            switch (len) {
-              case 1:
-                listeners[i].fn.call(listeners[i].context);
-                break;
-              case 2:
-                listeners[i].fn.call(listeners[i].context, a1);
-                break;
-              case 3:
-                listeners[i].fn.call(listeners[i].context, a1, a2);
-                break;
-              case 4:
-                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
-                break;
-              default:
-                if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
-                  args[j - 1] = arguments[j];
-                }
-                listeners[i].fn.apply(listeners[i].context, args);
+        if (ended) {
+          return { done: true };
+        }
+        return await new Promise((resolve, reject) => {
+          onNext = (next) => {
+            onNext = null;
+            buffer.push(next);
+            try {
+              resolve(getNext(buffer));
+            } catch (err) {
+              reject(err);
             }
-          }
+            return pushable2;
+          };
+        });
+      } finally {
+        if (buffer.isEmpty()) {
+          queueMicrotask(() => {
+            drain.resolve();
+            drain = pDefer();
+          });
         }
-        return true;
-      };
-      EventEmitter2.prototype.on = function on(event, fn, context) {
-        return addListener(this, event, fn, context, false);
-      };
-      EventEmitter2.prototype.once = function once(event, fn, context) {
-        return addListener(this, event, fn, context, true);
-      };
-      EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
-        var evt = prefix ? prefix + event : event;
-        if (!this._events[evt]) return this;
-        if (!fn) {
-          clearEvent(this, evt);
-          return this;
+      }
+    };
+    const bufferNext = (next) => {
+      if (onNext != null) {
+        return onNext(next);
+      }
+      buffer.push(next);
+      return pushable2;
+    };
+    const bufferError = (err) => {
+      buffer = new FIFO();
+      if (onNext != null) {
+        return onNext({ error: err });
+      }
+      buffer.push({ error: err });
+      return pushable2;
+    };
+    const push = (value) => {
+      if (ended) {
+        return pushable2;
+      }
+      if (options?.objectMode !== true && value?.byteLength == null) {
+        throw new Error("objectMode was not true but tried to push non-Uint8Array value");
+      }
+      return bufferNext({ done: false, value });
+    };
+    const end = (err) => {
+      if (ended)
+        return pushable2;
+      ended = true;
+      return err != null ? bufferError(err) : bufferNext({ done: true });
+    };
+    const _return = () => {
+      buffer = new FIFO();
+      end();
+      return { done: true };
+    };
+    const _throw = (err) => {
+      end(err);
+      return { done: true };
+    };
+    pushable2 = {
+      [Symbol.asyncIterator]() {
+        return this;
+      },
+      next: waitNext,
+      return: _return,
+      throw: _throw,
+      push,
+      end,
+      get readableLength() {
+        return buffer.size;
+      },
+      onEmpty: async (options2) => {
+        const signal = options2?.signal;
+        signal?.throwIfAborted();
+        if (buffer.isEmpty()) {
+          return;
         }
-        var listeners = this._events[evt];
-        if (listeners.fn) {
-          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
-            clearEvent(this, evt);
-          }
-        } else {
-          for (var i = 0, events2 = [], length = listeners.length; i < length; i++) {
-            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
-              events2.push(listeners[i]);
-            }
+        let cancel;
+        let listener;
+        if (signal != null) {
+          cancel = new Promise((resolve, reject) => {
+            listener = () => {
+              reject(new AbortError2());
+            };
+            signal.addEventListener("abort", listener);
+          });
+        }
+        try {
+          await Promise.race([
+            drain.promise,
+            cancel
+          ]);
+        } finally {
+          if (listener != null && signal != null) {
+            signal?.removeEventListener("abort", listener);
           }
-          if (events2.length) this._events[evt] = events2.length === 1 ? events2[0] : events2;
-          else clearEvent(this, evt);
         }
+      }
+    };
+    if (onEnd == null) {
+      return pushable2;
+    }
+    const _pushable2 = pushable2;
+    pushable2 = {
+      [Symbol.asyncIterator]() {
         return this;
-      };
-      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
-        var evt;
-        if (event) {
-          evt = prefix ? prefix + event : event;
-          if (this._events[evt]) clearEvent(this, evt);
-        } else {
-          this._events = new Events();
-          this._eventsCount = 0;
+      },
+      next() {
+        return _pushable2.next();
+      },
+      throw(err) {
+        _pushable2.throw(err);
+        if (onEnd != null) {
+          onEnd(err);
+          onEnd = void 0;
         }
-        return this;
-      };
-      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
-      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
-      EventEmitter2.prefixed = prefix;
-      EventEmitter2.EventEmitter = EventEmitter2;
-      if ("undefined" !== typeof module) {
-        module.exports = EventEmitter2;
+        return { done: true };
+      },
+      return() {
+        _pushable2.return();
+        if (onEnd != null) {
+          onEnd();
+          onEnd = void 0;
+        }
+        return { done: true };
+      },
+      push,
+      end(err) {
+        _pushable2.end(err);
+        if (onEnd != null) {
+          onEnd(err);
+          onEnd = void 0;
+        }
+        return pushable2;
+      },
+      get readableLength() {
+        return _pushable2.readableLength;
+      },
+      onEmpty: (opts) => {
+        return _pushable2.onEmpty(opts);
       }
-    }
-  });
-
-  // node_modules/abort-error/dist/src/index.js
-  var AbortError = class extends Error {
-    static name = "AbortError";
-    name = "AbortError";
-    constructor(message = "The operation was aborted", ...rest) {
-      super(message, ...rest);
-    }
-  };
+    };
+    return pushable2;
+  }
 
-  // node_modules/eventemitter3/index.mjs
-  var import_index = __toESM(require_eventemitter3(), 1);
+  // node_modules/main-event/dist/src/events.browser.js
+  function setMaxListeners() {
+  }
 
-  // node_modules/p-timeout/index.js
-  var TimeoutError = class extends Error {
-    constructor(message) {
-      super(message);
-      this.name = "TimeoutError";
+  // node_modules/main-event/dist/src/index.js
+  var TypedEventEmitter = class extends EventTarget {
+    #listeners = /* @__PURE__ */ new Map();
+    constructor() {
+      super();
+      setMaxListeners(Infinity, this);
+    }
+    listenerCount(type) {
+      const listeners = this.#listeners.get(type);
+      if (listeners == null) {
+        return 0;
+      }
+      return listeners.length;
+    }
+    addEventListener(type, listener, options) {
+      super.addEventListener(type, listener, options);
+      let list = this.#listeners.get(type);
+      if (list == null) {
+        list = [];
+        this.#listeners.set(type, list);
+      }
+      list.push({
+        callback: listener,
+        once: (options !== true && options !== false && options?.once) ?? false
+      });
+    }
+    removeEventListener(type, listener, options) {
+      super.removeEventListener(type.toString(), listener ?? null, options);
+      let list = this.#listeners.get(type);
+      if (list == null) {
+        return;
+      }
+      list = list.filter(({ callback }) => callback !== listener);
+      this.#listeners.set(type, list);
+    }
+    dispatchEvent(event) {
+      const result = super.dispatchEvent(event);
+      let list = this.#listeners.get(event.type);
+      if (list == null) {
+        return result;
+      }
+      list = list.filter(({ once }) => !once);
+      this.#listeners.set(event.type, list);
+      return result;
+    }
+    safeDispatchEvent(type, detail = {}) {
+      return this.dispatchEvent(new CustomEvent(type, detail));
     }
   };
-  var AbortError2 = class extends Error {
-    constructor(message) {
-      super();
+
+  // node_modules/race-event/dist/src/index.js
+  var AbortError3 = class extends Error {
+    type;
+    code;
+    constructor(message, code) {
+      super(message ?? "The operation was aborted");
+      this.type = "aborted";
       this.name = "AbortError";
-      this.message = message;
+      this.code = code ?? "ABORT_ERR";
     }
   };
-  var getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError2(errorMessage) : new DOMException(errorMessage);
-  var getAbortedReason = (signal) => {
-    const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
-    return reason instanceof Error ? reason : getDOMException(reason);
-  };
-  function pTimeout(promise, options) {
-    const {
-      milliseconds,
-      fallback,
-      message,
-      customTimers = { setTimeout, clearTimeout }
-    } = options;
-    let timer;
-    let abortHandler;
-    const wrappedPromise = new Promise((resolve, reject) => {
-      if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
-        throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
-      }
-      if (options.signal) {
-        const { signal } = options;
-        if (signal.aborted) {
-          reject(getAbortedReason(signal));
+  async function raceEvent(emitter, eventName, signal, opts) {
+    const error = new AbortError3(opts?.errorMessage, opts?.errorCode);
+    if (signal?.aborted === true) {
+      return Promise.reject(error);
+    }
+    return new Promise((resolve, reject) => {
+      function removeListeners() {
+        signal?.removeEventListener("abort", abortListener);
+        emitter.removeEventListener(eventName, eventListener);
+        if (opts?.errorEvent != null) {
+          emitter.removeEventListener(opts.errorEvent, errorEventListener);
         }
-        abortHandler = () => {
-          reject(getAbortedReason(signal));
-        };
-        signal.addEventListener("abort", abortHandler, { once: true });
-      }
-      if (milliseconds === Number.POSITIVE_INFINITY) {
-        promise.then(resolve, reject);
-        return;
       }
-      const timeoutError = new TimeoutError();
-      timer = customTimers.setTimeout.call(void 0, () => {
-        if (fallback) {
-          try {
-            resolve(fallback());
-          } catch (error) {
-            reject(error);
+      const eventListener = (evt) => {
+        try {
+          if (opts?.filter?.(evt) === false) {
+            return;
           }
+        } catch (err) {
+          removeListeners();
+          reject(err);
           return;
         }
-        if (typeof promise.cancel === "function") {
-          promise.cancel();
-        }
-        if (message === false) {
-          resolve();
-        } else if (message instanceof Error) {
-          reject(message);
-        } else {
-          timeoutError.message = message ?? `Promise timed out after ${milliseconds} milliseconds`;
-          reject(timeoutError);
-        }
-      }, milliseconds);
-      (async () => {
-        try {
-          resolve(await promise);
-        } catch (error) {
-          reject(error);
-        }
-      })();
-    });
-    const cancelablePromise = wrappedPromise.finally(() => {
-      cancelablePromise.clear();
-      if (abortHandler && options.signal) {
-        options.signal.removeEventListener("abort", abortHandler);
+        removeListeners();
+        resolve(evt);
+      };
+      const errorEventListener = (evt) => {
+        removeListeners();
+        reject(evt.detail);
+      };
+      const abortListener = () => {
+        removeListeners();
+        reject(error);
+      };
+      signal?.addEventListener("abort", abortListener);
+      emitter.addEventListener(eventName, eventListener);
+      if (opts?.errorEvent != null) {
+        emitter.addEventListener(opts.errorEvent, errorEventListener);
       }
     });
-    cancelablePromise.clear = () => {
-      customTimers.clearTimeout.call(void 0, timer);
-      timer = void 0;
-    };
-    return cancelablePromise;
   }
 
-  // node_modules/p-queue/dist/lower-bound.js
-  function lowerBound(array, value, comparator) {
-    let first = 0;
-    let count = array.length;
-    while (count > 0) {
-      const step = Math.trunc(count / 2);
-      let it = first + step;
-      if (comparator(array[it], value) <= 0) {
-        first = ++it;
-        count -= step + 1;
-      } else {
-        count = step;
-      }
+  // node_modules/it-queue/dist/src/errors.js
+  var QueueFullError = class extends Error {
+    static name = "QueueFullError";
+    constructor(message = "The queue was full") {
+      super(message);
+      this.name = "QueueFullError";
     }
-    return first;
-  }
+  };
 
-  // node_modules/p-queue/dist/priority-queue.js
-  var PriorityQueue = class {
-    #queue = [];
-    enqueue(run2, options) {
-      options = {
-        priority: 0,
-        ...options
-      };
-      const element = {
-        priority: options.priority,
-        id: options.id,
-        run: run2
-      };
-      if (this.size === 0 || this.#queue[this.size - 1].priority >= options.priority) {
-        this.#queue.push(element);
-        return;
-      }
-      const index = lowerBound(this.#queue, element, (a, b) => b.priority - a.priority);
-      this.#queue.splice(index, 0, element);
+  // node_modules/race-signal/dist/src/index.js
+  var AbortError4 = class extends Error {
+    type;
+    code;
+    constructor(message, code, name) {
+      super(message ?? "The operation was aborted");
+      this.type = "aborted";
+      this.name = name ?? "AbortError";
+      this.code = code ?? "ABORT_ERR";
+    }
+  };
+  async function raceSignal(promise, signal, opts) {
+    if (signal == null) {
+      return promise;
+    }
+    if (signal.aborted) {
+      promise.catch(() => {
+      });
+      return Promise.reject(new AbortError4(opts?.errorMessage, opts?.errorCode, opts?.errorName));
     }
-    setPriority(id, priority) {
-      const index = this.#queue.findIndex((element) => element.id === id);
-      if (index === -1) {
-        throw new ReferenceError(`No promise function with the id "${id}" exists in the queue.`);
+    let listener;
+    const error = new AbortError4(opts?.errorMessage, opts?.errorCode, opts?.errorName);
+    try {
+      return await Promise.race([
+        promise,
+        new Promise((resolve, reject) => {
+          listener = () => {
+            reject(error);
+          };
+          signal.addEventListener("abort", listener);
+        })
+      ]);
+    } finally {
+      if (listener != null) {
+        signal.removeEventListener("abort", listener);
       }
-      const [item] = this.#queue.splice(index, 1);
-      this.enqueue(item.run, { priority, id });
     }
-    dequeue() {
-      const item = this.#queue.shift();
-      return item?.run;
+  }
+
+  // node_modules/it-queue/dist/src/recipient.js
+  var JobRecipient = class {
+    deferred;
+    signal;
+    constructor(signal) {
+      this.signal = signal;
+      this.deferred = Promise.withResolvers();
+      this.onAbort = this.onAbort.bind(this);
+      this.signal?.addEventListener("abort", this.onAbort);
     }
-    filter(options) {
-      return this.#queue.filter((element) => element.priority === options.priority).map((element) => element.run);
+    onAbort() {
+      this.deferred.reject(this.signal?.reason ?? new AbortError());
     }
-    get size() {
-      return this.#queue.length;
+    cleanup() {
+      this.signal?.removeEventListener("abort", this.onAbort);
     }
   };
 
-  // node_modules/p-queue/dist/index.js
-  var PQueue = class extends import_index.default {
-    #carryoverConcurrencyCount;
-    #isIntervalIgnored;
-    #intervalCount = 0;
-    #intervalCap;
-    #interval;
-    #intervalEnd = 0;
-    #intervalId;
-    #timeoutId;
-    #queue;
-    #queueClass;
-    #pending = 0;
-    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194
-    #concurrency;
-    #isPaused;
-    #throwOnTimeout;
-    // Use to assign a unique identifier to a promise function, if not explicitly specified
-    #idAssigner = 1n;
-    /**
-        Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.
-    
-        Applies to each future operation.
-        */
-    timeout;
-    // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`
-    constructor(options) {
-      super();
-      options = {
-        carryoverConcurrencyCount: false,
-        intervalCap: Number.POSITIVE_INFINITY,
-        interval: 0,
-        concurrency: Number.POSITIVE_INFINITY,
-        autoStart: true,
-        queueClass: PriorityQueue,
-        ...options
+  // node_modules/it-queue/dist/src/job.js
+  function randomId() {
+    return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
+  }
+  var Job = class {
+    id;
+    fn;
+    options;
+    recipients;
+    status;
+    timeline;
+    controller;
+    constructor(fn, options) {
+      this.id = randomId();
+      this.status = "queued";
+      this.fn = fn;
+      this.options = options;
+      this.recipients = [];
+      this.timeline = {
+        created: Date.now()
       };
-      if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
-        throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${options.intervalCap?.toString() ?? ""}\` (${typeof options.intervalCap})`);
+      this.controller = new AbortController();
+      setMaxListeners(Infinity, this.controller.signal);
+      this.onAbort = this.onAbort.bind(this);
+    }
+    abort(err) {
+      this.controller.abort(err);
+    }
+    onAbort() {
+      const allAborted = this.recipients.reduce((acc, curr) => {
+        return acc && curr.signal?.aborted === true;
+      }, true);
+      if (allAborted) {
+        this.controller.abort(new AbortError());
+        this.cleanup();
       }
-      if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
-        throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${options.interval?.toString() ?? ""}\` (${typeof options.interval})`);
+    }
+    async join(options = {}) {
+      const recipient = new JobRecipient(options.signal);
+      this.recipients.push(recipient);
+      options.signal?.addEventListener("abort", this.onAbort);
+      return recipient.deferred.promise;
+    }
+    async run() {
+      this.status = "running";
+      this.timeline.started = Date.now();
+      try {
+        this.controller.signal.throwIfAborted();
+        const result = await raceSignal(this.fn({
+          ...this.options ?? {},
+          signal: this.controller.signal
+        }), this.controller.signal);
+        this.recipients.forEach((recipient) => {
+          recipient.deferred.resolve(result);
+        });
+        this.status = "complete";
+      } catch (err) {
+        this.recipients.forEach((recipient) => {
+          recipient.deferred.reject(err);
+        });
+        this.status = "errored";
+      } finally {
+        this.timeline.finished = Date.now();
+        this.cleanup();
       }
-      this.#carryoverConcurrencyCount = options.carryoverConcurrencyCount;
-      this.#isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;
-      this.#intervalCap = options.intervalCap;
-      this.#interval = options.interval;
-      this.#queue = new options.queueClass();
-      this.#queueClass = options.queueClass;
-      this.concurrency = options.concurrency;
-      this.timeout = options.timeout;
-      this.#throwOnTimeout = options.throwOnTimeout === true;
-      this.#isPaused = options.autoStart === false;
     }
-    get #doesIntervalAllowAnother() {
-      return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;
+    cleanup() {
+      this.recipients.forEach((recipient) => {
+        recipient.cleanup();
+        recipient.signal?.removeEventListener("abort", this.onAbort);
+      });
     }
-    get #doesConcurrentAllowAnother() {
-      return this.#pending < this.#concurrency;
+  };
+
+  // node_modules/it-queue/dist/src/utils.js
+  function debounce(func, wait) {
+    let timeout;
+    const output = function() {
+      const later = function() {
+        timeout = void 0;
+        void func();
+      };
+      clearTimeout(timeout);
+      timeout = setTimeout(later, wait);
+    };
+    output.start = () => {
+    };
+    output.stop = () => {
+      clearTimeout(timeout);
+    };
+    return output;
+  }
+
+  // node_modules/it-queue/dist/src/index.js
+  var Queue = class extends TypedEventEmitter {
+    concurrency;
+    maxSize;
+    queue;
+    pending;
+    sort;
+    autoStart;
+    constructor(init = {}) {
+      super();
+      this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY;
+      this.maxSize = init.maxSize ?? Number.POSITIVE_INFINITY;
+      this.pending = 0;
+      this.autoStart = init.autoStart ?? true;
+      this.sort = init.sort;
+      this.queue = [];
+      this.emitEmpty = debounce(this.emitEmpty.bind(this), 1);
+      this.emitIdle = debounce(this.emitIdle.bind(this), 1);
     }
-    #next() {
-      this.#pending--;
-      this.#tryToStartAnother();
-      this.emit("next");
+    [Symbol.asyncIterator]() {
+      return this.toGenerator();
     }
-    #onResumeInterval() {
-      this.#onInterval();
-      this.#initializeIntervalIfNeeded();
-      this.#timeoutId = void 0;
+    emitEmpty() {
+      if (this.size !== 0) {
+        return;
+      }
+      this.safeDispatchEvent("empty");
     }
-    get #isIntervalPaused() {
-      const now = Date.now();
-      if (this.#intervalId === void 0) {
-        const delay2 = this.#intervalEnd - now;
-        if (delay2 < 0) {
-          this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;
-        } else {
-          if (this.#timeoutId === void 0) {
-            this.#timeoutId = setTimeout(() => {
-              this.#onResumeInterval();
-            }, delay2);
-          }
-          return true;
-        }
+    emitIdle() {
+      if (this.running !== 0) {
+        return;
       }
-      return false;
+      this.safeDispatchEvent("idle");
     }
-    #tryToStartAnother() {
-      if (this.#queue.size === 0) {
-        if (this.#intervalId) {
-          clearInterval(this.#intervalId);
-        }
-        this.#intervalId = void 0;
-        this.emit("empty");
-        if (this.#pending === 0) {
-          this.emit("idle");
+    tryToStartAnother() {
+      if (this.size === 0) {
+        this.emitEmpty();
+        if (this.running === 0) {
+          this.emitIdle();
         }
         return false;
       }
-      if (!this.#isPaused) {
-        const canInitializeInterval = !this.#isIntervalPaused;
-        if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {
-          const job = this.#queue.dequeue();
-          if (!job) {
-            return false;
+      if (this.pending < this.concurrency) {
+        let job;
+        for (const j of this.queue) {
+          if (j.status === "queued") {
+            job = j;
+            break;
           }
-          this.emit("active");
-          job();
-          if (canInitializeInterval) {
-            this.#initializeIntervalIfNeeded();
-          }
-          return true;
         }
+        if (job == null) {
+          return false;
+        }
+        this.safeDispatchEvent("active");
+        this.pending++;
+        void job.run().finally(() => {
+          for (let i = 0; i < this.queue.length; i++) {
+            if (this.queue[i] === job) {
+              this.queue.splice(i, 1);
+              break;
+            }
+          }
+          this.pending--;
+          this.tryToStartAnother();
+          this.safeDispatchEvent("next");
+        });
+        return true;
       }
       return false;
     }
-    #initializeIntervalIfNeeded() {
-      if (this.#isIntervalIgnored || this.#intervalId !== void 0) {
-        return;
+    enqueue(job) {
+      this.queue.push(job);
+      if (this.sort != null) {
+        this.queue.sort(this.sort);
       }
-      this.#intervalId = setInterval(() => {
-        this.#onInterval();
-      }, this.#interval);
-      this.#intervalEnd = Date.now() + this.#interval;
     }
-    #onInterval() {
-      if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {
-        clearInterval(this.#intervalId);
-        this.#intervalId = void 0;
+    /**
+     * Start the queue. If the `autoStart` parameter passed to the constructor was
+     * not `false` this is a no-op
+     */
+    start() {
+      if (this.autoStart !== false) {
+        return;
       }
-      this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;
-      this.#processQueue();
+      this.autoStart = true;
+      this.tryToStartAnother();
     }
     /**
-    Executes all queued functions until it reaches the limit.
-    */
-    #processQueue() {
-      while (this.#tryToStartAnother()) {
+     * Adds a sync or async task to the queue. Always returns a promise.
+     */
+    async add(fn, options) {
+      options?.signal?.throwIfAborted();
+      if (this.size === this.maxSize) {
+        throw new QueueFullError();
       }
-    }
-    get concurrency() {
-      return this.#concurrency;
-    }
-    set concurrency(newConcurrency) {
-      if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
-        throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
+      const job = new Job(fn, options);
+      this.enqueue(job);
+      this.safeDispatchEvent("add");
+      if (this.autoStart) {
+        this.tryToStartAnother();
       }
-      this.#concurrency = newConcurrency;
-      this.#processQueue();
-    }
-    async #throwOnAbort(signal) {
-      return new Promise((_resolve, reject) => {
-        signal.addEventListener("abort", () => {
-          reject(signal.reason);
-        }, { once: true });
-      });
-    }
-    /**
-        Updates the priority of a promise function by its id, affecting its execution order. Requires a defined concurrency limit to take effect.
-    
-        For example, this can be used to prioritize a promise function to run earlier.
-    
-        ```js
-        import PQueue from 'p-queue';
-    
-        const queue = new PQueue({concurrency: 1});
-    
-        queue.add(async () => '', {priority: 1});
-        queue.add(async () => '', {priority: 0, id: ''});
-        queue.add(async () => '', {priority: 1});
-        queue.add(async () => '', {priority: 1});
-    
-        queue.setPriority('', 2);
-        ```
-    
-        In this case, the promise function with `id: ''` runs second.
-    
-        You can also deprioritize a promise function to delay its execution:
-    
-        ```js
-        import PQueue from 'p-queue';
-    
-        const queue = new PQueue({concurrency: 1});
-    
-        queue.add(async () => '', {priority: 1});
-        queue.add(async () => '', {priority: 1, id: ''});
-        queue.add(async () => '');
-        queue.add(async () => '', {priority: 0});
-    
-        queue.setPriority('', -1);
-        ```
-        Here, the promise function with `id: ''` executes last.
-        */
-    setPriority(id, priority) {
-      this.#queue.setPriority(id, priority);
-    }
-    async add(function_, options = {}) {
-      options.id ??= (this.#idAssigner++).toString();
-      options = {
-        timeout: this.timeout,
-        throwOnTimeout: this.#throwOnTimeout,
-        ...options
-      };
-      return new Promise((resolve, reject) => {
-        this.#queue.enqueue(async () => {
-          this.#pending++;
-          this.#intervalCount++;
-          try {
-            options.signal?.throwIfAborted();
-            let operation = function_({ signal: options.signal });
-            if (options.timeout) {
-              operation = pTimeout(Promise.resolve(operation), { milliseconds: options.timeout });
-            }
-            if (options.signal) {
-              operation = Promise.race([operation, this.#throwOnAbort(options.signal)]);
-            }
-            const result = await operation;
-            resolve(result);
-            this.emit("completed", result);
-          } catch (error) {
-            if (error instanceof TimeoutError && !options.throwOnTimeout) {
-              resolve();
-              return;
+      return job.join(options).then((result) => {
+        this.safeDispatchEvent("success", { detail: { job, result } });
+        return result;
+      }).catch((err) => {
+        if (job.status === "queued") {
+          for (let i = 0; i < this.queue.length; i++) {
+            if (this.queue[i] === job) {
+              this.queue.splice(i, 1);
+              break;
             }
-            reject(error);
-            this.emit("error", error);
-          } finally {
-            this.#next();
           }
-        }, options);
-        this.emit("add");
-        this.#tryToStartAnother();
+        }
+        this.safeDispatchEvent("failure", { detail: { job, error: err } });
+        throw err;
       });
     }
-    async addAll(functions, options) {
-      return Promise.all(functions.map(async (function_) => this.add(function_, options)));
-    }
-    /**
-    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
-    */
-    start() {
-      if (!this.#isPaused) {
-        return this;
-      }
-      this.#isPaused = false;
-      this.#processQueue();
-      return this;
-    }
     /**
-    Put queue execution on hold.
-    */
-    pause() {
-      this.#isPaused = true;
+     * Clear the queue
+     */
+    clear() {
+      this.queue.splice(0, this.queue.length);
     }
     /**
-    Clear the queue.
-    */
-    clear() {
-      this.#queue = new this.#queueClass();
+     * Abort all jobs in the queue and clear it
+     */
+    abort() {
+      this.queue.forEach((job) => {
+        job.abort(new AbortError());
+      });
+      this.clear();
     }
     /**
-        Can be called multiple times. Useful if you for example add additional items at a later time.
-    
-        @returns A promise that settles when the queue becomes empty.
-        */
-    async onEmpty() {
-      if (this.#queue.size === 0) {
+     * Can be called multiple times. Useful if you for example add additional items at a later time.
+     *
+     * @returns A promise that settles when the queue becomes empty.
+     */
+    async onEmpty(options) {
+      if (this.size === 0) {
         return;
       }
-      await this.#onEvent("empty");
+      await raceEvent(this, "empty", options?.signal);
     }
     /**
-        @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
-    
-        If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
-    
-        Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
-        */
-    async onSizeLessThan(limit) {
-      if (this.#queue.size < limit) {
+     * @returns A promise that settles when the queue size is less than the given
+     * limit: `queue.size < limit`.
+     *
+     * If you want to avoid having the queue grow beyond a certain size you can
+     * `await queue.onSizeLessThan()` before adding a new item.
+     *
+     * Note that this only limits the number of items waiting to start. There
+     * could still be up to `concurrency` jobs already running that this call does
+     * not include in its calculation.
+     */
+    async onSizeLessThan(limit, options) {
+      if (this.size < limit) {
         return;
       }
-      await this.#onEvent("next", () => this.#queue.size < limit);
+      await raceEvent(this, "next", options?.signal, {
+        filter: () => this.size < limit
+      });
     }
     /**
-        The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
-    
-        @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
-        */
-    async onIdle() {
-      if (this.#pending === 0 && this.#queue.size === 0) {
+     * The difference with `.onEmpty` is that `.onIdle` guarantees that all work
+     * from the queue has finished. `.onEmpty` merely signals that the queue is
+     * empty, but it could mean that some promises haven't completed yet.
+     *
+     * @returns A promise that settles when the queue becomes empty, and all
+     * promises have completed; `queue.size === 0 && queue.pending === 0`.
+     */
+    async onIdle(options) {
+      if (this.pending === 0 && this.size === 0) {
         return;
       }
-      await this.#onEvent("idle");
-    }
-    async #onEvent(event, filter) {
-      return new Promise((resolve) => {
-        const listener = () => {
-          if (filter && !filter()) {
-            return;
-          }
-          this.off(event, listener);
-          resolve();
-        };
-        this.on(event, listener);
-      });
+      await raceEvent(this, "idle", options?.signal);
     }
     /**
-    Size of the queue, the number of queued items waiting to run.
-    */
+     * Size of the queue including running items
+     */
     get size() {
-      return this.#queue.size;
+      return this.queue.length;
     }
     /**
-        Size of the queue, filtered by the given options.
-    
-        For example, this can be used to find the number of items remaining in the queue with a specific priority level.
-        */
-    sizeBy(options) {
-      return this.#queue.filter(options).length;
+     * The number of queued items waiting to run.
+     */
+    get queued() {
+      return this.queue.length - this.pending;
     }
     /**
-    Number of running items (no longer in the queue).
-    */
-    get pending() {
-      return this.#pending;
+     * The number of items currently running.
+     */
+    get running() {
+      return this.pending;
     }
     /**
-    Whether the queue is currently paused.
-    */
-    get isPaused() {
-      return this.#isPaused;
+     * Returns an async generator that makes it easy to iterate over the results
+     * of jobs added to the queue.
+     *
+     * The generator will end when the queue becomes idle, that is there are no
+     * jobs running and no jobs that have yet to run.
+     *
+     * If you need to keep the queue open indefinitely, consider using it-pushable
+     * instead.
+     */
+    async *toGenerator(options) {
+      options?.signal?.throwIfAborted();
+      const stream = pushable({
+        objectMode: true
+      });
+      const cleanup = (err) => {
+        if (err != null) {
+          this.abort();
+        } else {
+          this.clear();
+        }
+        stream.end(err);
+      };
+      const onQueueJobComplete = (evt) => {
+        if (evt.detail != null) {
+          stream.push(evt.detail.result);
+        }
+      };
+      const onQueueError = (evt) => {
+        cleanup(evt.detail.error);
+      };
+      const onQueueIdle = () => {
+        cleanup();
+      };
+      const onSignalAbort = () => {
+        cleanup(new AbortError("Queue aborted"));
+      };
+      this.addEventListener("success", onQueueJobComplete);
+      this.addEventListener("failure", onQueueError);
+      this.addEventListener("idle", onQueueIdle);
+      options?.signal?.addEventListener("abort", onSignalAbort);
+      try {
+        yield* stream;
+      } finally {
+        this.removeEventListener("success", onQueueJobComplete);
+        this.removeEventListener("failure", onQueueError);
+        this.removeEventListener("idle", onQueueIdle);
+        options?.signal?.removeEventListener("abort", onSignalAbort);
+        cleanup();
+      }
     }
   };
 
@@ -882,17 +1005,21 @@
     if (implementation.isWorker === true) {
       return {
         readLock: implementation.readLock(name, options),
-        writeLock: implementation.writeLock(name, options)
+        writeLock: implementation.writeLock(name, options),
+        cleanUp: () => {
+        }
       };
     }
-    const masterQueue = new PQueue({ concurrency: 1 });
+    const masterQueue = new Queue({
+      concurrency: 1
+    });
     let readQueue;
     return {
       async readLock(opts) {
         if (readQueue != null) {
           return createReleaseable(readQueue, opts);
         }
-        readQueue = new PQueue({
+        readQueue = new Queue({
           concurrency: options.concurrency,
           autoStart: false
         });
@@ -911,7 +1038,11 @@
       async writeLock(opts) {
         readQueue = null;
         return createReleaseable(masterQueue, opts);
-      }
+      },
+      cleanUp: () => {
+        delete mutexes[name];
+      },
+      queue: masterQueue
     };
   };
   var defaultOptions2 = {
@@ -1026,11 +1157,13 @@
   var delay_default = delay;
 
   // test/fixtures/lock.ts
-  async function lock(type, muxex, counts, result, timeout = 0) {
+  async function lock(type, mutex, counts, result, timeout = 0, signal) {
     counts[type]++;
     const index = counts[type];
     result.push(`${type} ${index} waiting`);
-    const release = await muxex[`${type}Lock`]();
+    const release = await mutex[`${type}Lock`]({
+      signal
+    });
     result.push(`${type} ${index} start`);
     if (timeout > 0) {
       await delay_default(timeout);
diff --git a/node_modules/mortice/src/.DS_Store b/node_modules/mortice/src/.DS_Store
new file mode 100644
index 0000000..5008ddf
Binary files /dev/null and b/node_modules/mortice/src/.DS_Store differ
diff --git a/node_modules/mortice/src/index.ts b/node_modules/mortice/src/index.ts
index e9b86bf..8f71c99 100644
--- a/node_modules/mortice/src/index.ts
+++ b/node_modules/mortice/src/index.ts
@@ -98,10 +98,28 @@
  * // write something
  * release()
  * ```
+ *
+ * ## Cleanup
+ *
+ * If creating temporary mutexes, the `.cleanUp` function should be called when
+ * the mutex is no longer required.
+ *
+ * This must be done in the execution context that controls the mutex (normally
+ * the main or renderer thread), calling it in a worker is a no-op.
+ *
+ * ```javascript
+ * import mortice from 'mortice'
+ *
+ * const mutex = mortice()
+ *
+ * // ...some time later
+ *
+ * mutex.cleanUp()
+ * ```
  */
 
 import { AbortError } from 'abort-error'
-import PQueue from 'p-queue'
+import { Queue } from 'it-queue'
 import impl from './node.js'
 import type { AbortOptions } from 'abort-error'
 
@@ -131,8 +149,33 @@ export interface MorticeOptions {
 }
 
 export interface Mortice {
+  /**
+   * Acquire a read lock. Multiple reads will occur simultaneously up to the
+   * concurrency limit passed to the constructor.
+   */
   readLock(options?: AbortOptions): Promise<Release>
+
+  /**
+   * Acquire a write lock. The write lock will wait for any in-flight reads to
+   * complete, then prevent any further reads or writes until the lock is
+   * released.
+   */
   writeLock(options?: AbortOptions): Promise<Release>
+
+  /**
+   * Removes this mutex from the global state, after invoking this method it
+   * cannot be used any more.
+   *
+   * It must be called in the owning context, calling this method in a worker
+   * is a no-op.
+   */
+  cleanUp(): void
+
+  /**
+   * If this is the main thread, the state of the read/write queue may be
+   * inspected here
+   */
+  queue?: Queue
 }
 
 export interface Release {
@@ -142,7 +185,7 @@ export interface Release {
 const mutexes: Record<string, Mortice> = {}
 let implementation: any
 
-async function createReleaseable (queue: PQueue, options?: AbortOptions): Promise<Release> {
+async function createReleaseable (queue: Queue, options?: AbortOptions): Promise<Release> {
   let res: (release: Release) => void
   let rej: (err: Error) => void
 
@@ -180,12 +223,15 @@ const createMutex = (name: string, options: Required<MorticeOptions>): Mortice =
   if (implementation.isWorker === true) {
     return {
       readLock: implementation.readLock(name, options),
-      writeLock: implementation.writeLock(name, options)
+      writeLock: implementation.writeLock(name, options),
+      cleanUp: () => {}
     }
   }
 
-  const masterQueue = new PQueue({ concurrency: 1 })
-  let readQueue: PQueue | null
+  const masterQueue = new Queue({
+    concurrency: 1
+  })
+  let readQueue: Queue | null
 
   return {
     async readLock (opts?: AbortOptions) {
@@ -195,7 +241,7 @@ const createMutex = (name: string, options: Required<MorticeOptions>): Mortice =
       }
 
       // Create a new read queue
-      readQueue = new PQueue({
+      readQueue = new Queue({
         concurrency: options.concurrency,
         autoStart: false
       })
@@ -229,7 +275,11 @@ const createMutex = (name: string, options: Required<MorticeOptions>): Mortice =
       readQueue = null
 
       return createReleaseable(masterQueue, opts)
-    }
+    },
+    cleanUp: () => {
+      delete mutexes[name]
+    },
+    queue: masterQueue
   }
 }
 
