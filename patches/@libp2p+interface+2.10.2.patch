diff --git a/node_modules/@libp2p/interface/dist/index.min.js.map b/node_modules/@libp2p/interface/dist/index.min.js.map
index fdabd5f..d9be1a3 100644
--- a/node_modules/@libp2p/interface/dist/index.min.js.map
+++ b/node_modules/@libp2p/interface/dist/index.min.js.map
@@ -1,7 +1,7 @@
 {
   "version": 3,
   "sources": ["../src/index.ts", "../src/connection.ts", "../src/content-routing.ts", "../src/keys.ts", "../src/peer-discovery.ts", "../src/peer-id.ts", "../src/peer-routing.ts", "../src/peer-store.ts", "../src/pubsub.ts", "../src/transport.ts", "../src/errors.ts", "../src/events.browser.ts", "../src/event-target.ts", "../src/startable.ts"],
-  "sourcesContent": ["/**\n * @packageDocumentation\n *\n * Exports a `Libp2p` type for modules to use as a type argument.\n *\n * @example\n *\n * ```typescript\n * import type { Libp2p } from '@libp2p/interface'\n *\n * function doSomethingWithLibp2p (node: Libp2p) {\n *   // ...\n * }\n * ```\n */\n\nimport type { Connection, NewStreamOptions, Stream } from './connection.js'\nimport type { ContentRouting } from './content-routing.js'\nimport type { TypedEventTarget } from './event-target.js'\nimport type { Ed25519PublicKey, PublicKey, RSAPublicKey, Secp256k1PublicKey } from './keys.js'\nimport type { Metrics } from './metrics.js'\nimport type { Ed25519PeerId, PeerId, RSAPeerId, Secp256k1PeerId, URLPeerId } from './peer-id.js'\nimport type { PeerInfo } from './peer-info.js'\nimport type { PeerRouting } from './peer-routing.js'\nimport type { Address, Peer, PeerStore } from './peer-store.js'\nimport type { Startable } from './startable.js'\nimport type { StreamHandler, StreamHandlerOptions } from './stream-handler.js'\nimport type { Topology } from './topology.js'\nimport type { Listener, OutboundConnectionUpgradeEvents } from './transport.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { ProgressOptions, ProgressEvent } from 'progress-events'\n\n/**\n * Used by the connection manager to sort addresses into order before dialling\n */\nexport interface AddressSorter {\n  (a: Address, b: Address): -1 | 0 | 1\n}\n\n/**\n * Event detail emitted when peer data changes\n */\nexport interface PeerUpdate {\n  peer: Peer\n  previous?: Peer\n}\n\n/**\n * Peer data signed by the remote Peer's public key\n */\nexport interface SignedPeerRecord {\n  addresses: Multiaddr[]\n  seq: bigint\n}\n\n/**\n * A certificate that can be used to secure connections\n */\nexport interface TLSCertificate {\n  /**\n   * The private key that corresponds to the certificate in PEM format\n   */\n  key: string\n\n  /**\n   * The certificate chain in PEM format\n   */\n  cert: string\n}\n\n/**\n * Data returned from a successful identify response\n */\nexport interface IdentifyResult {\n  /**\n   * The remote Peer's PeerId\n   */\n  peerId: PeerId\n\n  /**\n   * The unsigned addresses they are listening on. Note - any multiaddrs present\n   * in the signed peer record should be preferred to the value here.\n   */\n  listenAddrs: Multiaddr[]\n\n  /**\n   * The protocols the remote peer supports\n   */\n  protocols: string[]\n\n  /**\n   * The remote protocol version\n   */\n  protocolVersion?: string\n\n  /**\n   * The remote agent version\n   */\n  agentVersion?: string\n\n  /**\n   * The public key part of the remote PeerId - this is only useful for older\n   * RSA-based PeerIds, the more modern Ed25519 and secp256k1 types have the\n   * public key embedded in them\n   */\n  publicKey?: Uint8Array\n\n  /**\n   * If set this is the address that the remote peer saw the identify request\n   * originate from\n   */\n  observedAddr?: Multiaddr\n\n  /**\n   * If sent by the remote peer this is the deserialized signed peer record\n   */\n  signedPeerRecord?: SignedPeerRecord\n\n  /**\n   * The connection that the identify protocol ran over\n   */\n  connection: Connection\n}\n\n/**\n * Logger component for libp2p\n */\nexport interface Logger {\n  (formatter: any, ...args: any[]): void\n  error(formatter: any, ...args: any[]): void\n  trace(formatter: any, ...args: any[]): void\n  enabled: boolean\n}\n\n/**\n * Peer logger component for libp2p. This can be used to create loggers that are\n * scoped to individual system components or services.\n *\n * To see logs, run your app with `DEBUG` set as an env var or for browsers, in\n * `localStorage`:\n *\n * ```console\n * $ DEBUG=libp2p* node index.js\n *  libp2p:my-service hello +0ms\n * ```\n */\nexport interface ComponentLogger {\n  /**\n   * Returns a logger for the specified component.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * import { ComponentLogger, Logger } from '@libp2p/interface'\n   *\n   * interface MyServiceComponents {\n   *   logger: ComponentLogger\n   * }\n   *\n   * class MyService {\n   *   private readonly log: Logger\n   *\n   *   constructor (components) {\n   *     this.log = components.logger.forComponent('libp2p:my-service')\n   *\n   *     this.log('hello')\n   *     // logs:\n   *     // libp2p:my-service hello +0ms\n   *   }\n   * }\n   * ```\n   */\n  forComponent(name: string): Logger\n}\n\n/**\n * Once you have a libp2p instance, you can listen to several events it emits,\n * so that you can be notified of relevant network events.\n *\n * Event names are `noun:verb` so the first part is the name of the object\n * being acted on and the second is the action.\n */\nexport interface Libp2pEvents<T extends ServiceMap = ServiceMap> {\n  /**\n   * This event is dispatched when a new network peer is discovered.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:discovery', (event) => {\n   *    const peerInfo = event.detail\n   *    // ...\n   * })\n   * ```\n   */\n  'peer:discovery': CustomEvent<PeerInfo>\n\n  /**\n   * This event will be triggered any time a new peer connects.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:connect', (event) => {\n   *   const peerId = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:connect': CustomEvent<PeerId>\n\n  /**\n   * This event will be triggered any time we are disconnected from another\n   * peer, regardless of the circumstances of that disconnection. If we happen\n   * to have multiple connections to a peer, this event will **only** be\n   * triggered when the last connection is closed.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:disconnect', (event) => {\n   *   const peerId = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:disconnect': CustomEvent<PeerId>\n\n  /**\n   * When a peer tagged with `keep-alive` disconnects, we will make multiple\n   * attempts to reconnect to it with a backoff factor (see the connection\n   * manager settings for details). If these all fail, the `keep-alive` tag will\n   * be removed and this event will be emitted.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:reconnect-failure', (event) => {\n   *   const peerId = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:reconnect-failure': CustomEvent<PeerId>\n\n  /**\n   * This event is dispatched after a remote peer has successfully responded to\n   * the identify protocol. Note that for this to be emitted, both peers must\n   * have an identify service configured.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:identify', (event) => {\n   *   const identifyResult = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:identify': CustomEvent<IdentifyResult>\n\n  /**\n   * This event is dispatched when the peer store data for a peer has been\n   * updated - e.g. their multiaddrs, protocols etc have changed.\n   *\n   * If they were previously known to this node, the old peer data will be\n   * set in the `previous` field.\n   *\n   * This may be in response to the identify protocol running, a manual\n   * update or some other event.\n   */\n  'peer:update': CustomEvent<PeerUpdate>\n\n  /**\n   * This event is dispatched when the current node's peer record changes -\n   * for example a transport started listening on a new address or a new\n   * protocol handler was registered.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('self:peer:update', (event) => {\n   *   const { peer } = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'self:peer:update': CustomEvent<PeerUpdate>\n\n  /**\n   * This event is dispatched when a transport begins listening on a new address\n   */\n  'transport:listening': CustomEvent<Listener>\n\n  /**\n   * This event is dispatched when a transport stops listening on an address\n   */\n  'transport:close': CustomEvent<Listener>\n\n  /**\n   * This event is dispatched when the connection manager has more than the\n   * configured allowable max connections and has closed some connections to\n   * bring the node back under the limit.\n   */\n  'connection:prune': CustomEvent<Connection[]>\n\n  /**\n   * This event notifies listeners when new incoming or outgoing connections\n   * are opened.\n   */\n  'connection:open': CustomEvent<Connection>\n\n  /**\n   * This event notifies listeners when incoming or outgoing connections are\n   * closed.\n   */\n  'connection:close': CustomEvent<Connection>\n\n  /**\n   * This event notifies listeners that a TLS certificate is available for use\n   */\n  'certificate:provision': CustomEvent<TLSCertificate>\n\n  /**\n   * This event notifies listeners that a new TLS certificate is available for\n   * use. Any previous certificate may no longer be valid.\n   */\n  'certificate:renew': CustomEvent<TLSCertificate>\n\n  /**\n   * This event notifies listeners that the node has started\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('start', (event) => {\n   *   console.info(libp2p.isStarted()) // true\n   * })\n   * ```\n   */\n  start: CustomEvent<Libp2p<T>>\n\n  /**\n   * This event notifies listeners that the node has stopped\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('stop', (event) => {\n   *   console.info(libp2p.isStarted()) // false\n   * })\n   * ```\n   */\n  stop: CustomEvent<Libp2p<T>>\n}\n\n/**\n * A map of user defined services available on the libp2p node via the\n * `services` key\n *\n * @example\n *\n * ```TypeScript\n * const node = await createLibp2p({\n *   // ...other options\n *   services: {\n *     myService: myService({\n *       // ...service options\n *     })\n *   }\n * })\n *\n * // invoke methods on the service\n * node.services.myService.anOperation()\n * ```\n */\nexport type ServiceMap = Record<string, unknown>\n\nexport type PendingDialStatus = 'queued' | 'active' | 'error' | 'success'\n\n/**\n * An item in the dial queue\n */\nexport interface PendingDial {\n  /**\n   * A unique identifier for this dial\n   */\n  id: string\n\n  /**\n   * The current status of the dial\n   */\n  status: PendingDialStatus\n\n  /**\n   * If known, this is the peer id that libp2p expects to be dialling\n   */\n  peerId?: PeerId\n\n  /**\n   * The list of multiaddrs that will be dialled. The returned connection will\n   * use the first address that succeeds, all other dials part of this pending\n   * dial will be cancelled.\n   */\n  multiaddrs: Multiaddr[]\n}\n\nexport type Libp2pStatus = 'starting' | 'started' | 'stopping' | 'stopped'\n\nexport interface IsDialableOptions extends AbortOptions {\n  /**\n   * If the dial attempt would open a protocol, and the multiaddr being dialed\n   * is a circuit relay address, passing true here would cause the test to fail\n   * because that protocol would not be allowed to run over a data/time limited\n   * connection.\n   */\n  runOnLimitedConnection?: boolean\n}\n\nexport type TransportManagerDialProgressEvents =\n  ProgressEvent<'transport-manager:selected-transport', string>\n\nexport type OpenConnectionProgressEvents =\n  TransportManagerDialProgressEvents |\n  ProgressEvent<'dial-queue:already-connected'> |\n  ProgressEvent<'dial-queue:already-in-dial-queue'> |\n  ProgressEvent<'dial-queue:add-to-dial-queue'> |\n  ProgressEvent<'dial-queue:start-dial'> |\n  ProgressEvent<'dial-queue:calculated-addresses', Address[]> |\n  OutboundConnectionUpgradeEvents\n\nexport interface DialOptions extends AbortOptions, ProgressOptions {\n  /**\n   * If true, open a new connection to the remote even if one already exists\n   */\n  force?: boolean\n}\n\nexport interface DialProtocolOptions extends NewStreamOptions {\n\n}\n\n/**\n * Libp2p nodes implement this interface.\n */\nexport interface Libp2p<T extends ServiceMap = ServiceMap> extends Startable, TypedEventTarget<Libp2pEvents<T>> {\n  /**\n   * The PeerId is a unique identifier for a node on the network.\n   *\n   * It is the hash of an RSA public key or, for Ed25519 or secp256k1 keys,\n   * the key itself.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * console.info(libp2p.peerId)\n   * // PeerId(12D3Foo...)\n   * ````\n   */\n  peerId: PeerId\n\n  /**\n   * The peer store holds information we know about other peers on the network.\n   * - multiaddrs, supported protocols, etc.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peer = await libp2p.peerStore.get(peerId)\n   * console.info(peer)\n   * // { id: PeerId(12D3Foo...), addresses: [] ... }\n   * ```\n   */\n  peerStore: PeerStore\n\n  /**\n   * The peer routing subsystem allows the user to find peers on the network\n   * or to find peers close to binary keys.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peerInfo = await libp2p.peerRouting.findPeer(peerId)\n   * console.info(peerInfo)\n   * // { id: PeerId(12D3Foo...), multiaddrs: [] ... }\n   * ```\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for await (const peerInfo of libp2p.peerRouting.getClosestPeers(key)) {\n   *   console.info(peerInfo)\n   *   // { id: PeerId(12D3Foo...), multiaddrs: [] ... }\n   * }\n   * ```\n   */\n  peerRouting: PeerRouting\n\n  /**\n   * The content routing subsystem allows the user to find providers for content,\n   * let the network know they are providers for content, and get/put values to\n   * the DHT.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for await (const peerInfo of libp2p.contentRouting.findProviders(cid)) {\n   *   console.info(peerInfo)\n   *   // { id: PeerId(12D3Foo...), multiaddrs: [] ... }\n   * }\n   * ```\n   */\n  contentRouting: ContentRouting\n\n  /**\n   * The metrics subsystem allows recording values to assess the health/performance\n   * of the running node.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const metric = libp2p.metrics.registerMetric({\n   *   'my-metric'\n   * })\n   *\n   * // later\n   * metric.update(5)\n   * ```\n   */\n  metrics?: Metrics\n\n  /**\n   * The logger used by this libp2p node\n   */\n  logger: ComponentLogger\n\n  /**\n   * The current status of the libp2p node\n   */\n  status: Libp2pStatus\n\n  /**\n   * Get a deduplicated list of peer advertising multiaddrs by concatenating\n   * the listen addresses used by transports with any configured\n   * announce addresses as well as observed addresses reported by peers.\n   *\n   * If Announce addrs are specified, configured listen addresses will be\n   * ignored though observed addresses will still be included.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const listenMa = libp2p.getMultiaddrs()\n   * // [ <Multiaddr 047f00000106f9ba - /ip4/127.0.0.1/tcp/63930> ]\n   * ```\n   */\n  getMultiaddrs(): Multiaddr[]\n\n  /**\n   * Returns a list of supported protocols\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const protocols = libp2p.getProtocols()\n   * // [ '/ipfs/ping/1.0.0', '/ipfs/id/1.0.0' ]\n   * ```\n   */\n  getProtocols(): string[]\n\n  /**\n   * Return a list of all connections this node has open, optionally filtering\n   * by a PeerId\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for (const connection of libp2p.getConnections()) {\n   *   console.log(peerId, connection.remoteAddr.toString())\n   *   // Logs the PeerId string and the observed remote multiaddr of each Connection\n   * }\n   * ```\n   */\n  getConnections(peerId?: PeerId): Connection[]\n\n  /**\n   * Return the list of dials currently in progress or queued to start\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for (const pendingDial of libp2p.getDialQueue()) {\n   *   console.log(pendingDial)\n   * }\n   * ```\n   */\n  getDialQueue(): PendingDial[]\n\n  /**\n   * Return a list of all peers we currently have a connection open to\n   */\n  getPeers(): PeerId[]\n\n  /**\n   * Dials to the provided peer. If successful, the known metadata of the\n   * peer will be added to the nodes `peerStore`.\n   *\n   * If a PeerId is passed as the first argument, the peer will need to have known multiaddrs for it in the PeerStore.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const conn = await libp2p.dial(remotePeerId)\n   *\n   * // create a new stream within the connection\n   * const stream = await conn.newStream(['/echo/1.1.0', '/echo/1.0.0'])\n   *\n   * // protocol negotiated: 'echo/1.0.0' means that the other party only supports the older version\n   *\n   * // ...\n   * await conn.close()\n   * ```\n   */\n  dial(peer: PeerId | Multiaddr | Multiaddr[], options?: DialOptions): Promise<Connection>\n\n  /**\n   * Dials to the provided peer and tries to handshake with the given protocols in order.\n   * If successful, the known metadata of the peer will be added to the nodes `peerStore`,\n   * and the `MuxedStream` will be returned together with the successful negotiated protocol.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * import { pipe } from 'it-pipe'\n   *\n   * const { stream, protocol } = await libp2p.dialProtocol(remotePeerId, protocols)\n   *\n   * // Use this new stream like any other duplex stream\n   * pipe([1, 2, 3], stream, consume)\n   * ```\n   */\n  dialProtocol(peer: PeerId | Multiaddr | Multiaddr[], protocols: string | string[], options?: DialProtocolOptions): Promise<Stream>\n\n  /**\n   * Attempts to gracefully close an open connection to the given peer. If the\n   * connection is not closed in the grace period, it will be forcefully closed.\n   *\n   * An AbortSignal can optionally be passed to control when the connection is\n   * forcefully closed.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * await libp2p.hangUp(remotePeerId)\n   * ```\n   */\n  hangUp(peer: PeerId | Multiaddr, options?: AbortOptions): Promise<void>\n\n  /**\n   * Sets up [multistream-select routing](https://github.com/multiformats/multistream-select) of protocols to their application handlers. Whenever a stream is opened on one of the provided protocols, the handler will be called. `handle` must be called in order to register a handler and support for a given protocol. This also informs other peers of the protocols you support.\n   *\n   * `libp2p.handle(protocols, handler, options)`\n   *\n   * In the event of a new handler for the same protocol being added and error\n   * will be thrown. Pass `force: true` to override this.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const handler = ({ connection, stream, protocol }) => {\n   *   // use stream or connection according to the needs\n   * }\n   *\n   * libp2p.handle('/echo/1.0.0', handler, {\n   *   maxInboundStreams: 5,\n   *   maxOutboundStreams: 5\n   * })\n   * ```\n   */\n  handle(protocol: string | string[], handler: StreamHandler, options?: StreamHandlerOptions): Promise<void>\n\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.unhandle(['/echo/1.0.0'])\n   * ```\n   */\n  unhandle(protocols: string[] | string): Promise<void>\n\n  /**\n   * Register a topology to be informed when peers are encountered that\n   * support the specified protocol\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const id = await libp2p.register('/echo/1.0.0', {\n   *   onConnect: (peer, connection) => {\n   *     // handle connect\n   *   },\n   *   onDisconnect: (peer, connection) => {\n   *     // handle disconnect\n   *   }\n   * })\n   * ```\n   */\n  register(protocol: string, topology: Topology): Promise<string>\n\n  /**\n   * Unregister topology to no longer be informed when peers connect or\n   * disconnect.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const id = await libp2p.register(...)\n   *\n   * libp2p.unregister(id)\n   * ```\n   */\n  unregister(id: string): void\n\n  /**\n   * Returns the public key for the passed PeerId. If the PeerId is of the 'RSA'\n   * type this may mean searching the routing if the peer's key is not present\n   * in the peer store.\n   */\n  getPublicKey(peer: Ed25519PeerId, options?: AbortOptions): Promise<Ed25519PublicKey>\n  getPublicKey(peer: Secp256k1PeerId, options?: AbortOptions): Promise<Secp256k1PublicKey>\n  getPublicKey(peer: RSAPeerId, options?: AbortOptions): Promise<RSAPublicKey>\n  getPublicKey(peer: URLPeerId, options?: AbortOptions): Promise<never>\n  getPublicKey(peer: PeerId, options?: AbortOptions): Promise<PublicKey>\n\n  /**\n   * Given the current node configuration, returns a promise of `true` or\n   * `false` if the node would attempt to dial the passed multiaddr.\n   *\n   * This means a relevant transport is configured, and the connection gater\n   * would not block the dial attempt.\n   *\n   * This may involve resolving DNS addresses so you should pass an AbortSignal.\n   */\n  isDialable(multiaddr: Multiaddr | Multiaddr[], options?: IsDialableOptions): Promise<boolean>\n\n  /**\n   * A set of user defined services\n   */\n  services: T\n}\n\n/**\n * Metadata about the current node\n */\nexport interface NodeInfo {\n  /**\n   * The implementation name\n   */\n  name: string\n\n  /**\n   * The implementation version\n   */\n  version: string\n\n  /**\n   * A string that contains information about the implementation and runtime\n   */\n  userAgent: string\n}\n\n/**\n * An object that contains an AbortSignal as\n * the optional `signal` property.\n *\n * @example\n *\n * ```TypeScript\n * const controller = new AbortController()\n *\n * aLongRunningOperation({\n *   signal: controller.signal\n * })\n *\n * // later\n *\n * controller.abort()\n */\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\n/**\n * An object that contains a Logger as the `log` property.\n */\nexport interface LoggerOptions {\n  log: Logger\n}\n\n/**\n * An object that includes a trace object that is passed onwards.\n *\n * This is used by metrics method tracing to link function calls together.\n */\nexport interface TraceOptions {\n  trace?: any\n}\n\n/**\n * A signal that needs to be cleared when no longer in use\n */\nexport interface ClearableSignal extends AbortSignal {\n  clear(): void\n}\n\n/**\n * When a routing operation involves reading values, these options allow\n * controlling where the values are read from. By default libp2p will check\n * local caches but may not use the network if a valid local value is found,\n * these options allow tuning that behavior.\n */\nexport interface RoutingOptions extends AbortOptions, ProgressOptions, TraceOptions {\n  /**\n   * Pass `false` to not use the network\n   *\n   * @default true\n   */\n  useNetwork?: boolean\n\n  /**\n   * Pass `false` to not use cached values\n   *\n   * @default true\n   */\n  useCache?: boolean\n}\n\n/**\n * This symbol is used by libp2p services to define the capabilities they can\n * provide to other libp2p services.\n *\n * The service should define a property with this symbol as the key and the\n * value should be a string array of provided capabilities.\n */\nexport const serviceCapabilities = Symbol.for('@libp2p/service-capabilities')\n\n/**\n * This symbol is used by libp2p services to define the capabilities they\n * require from other libp2p services.\n *\n * The service should define a property with this symbol as the key and the\n * value should be a string array of required capabilities.\n */\nexport const serviceDependencies = Symbol.for('@libp2p/service-dependencies')\n\nexport * from './connection.js'\nexport * from './connection-encrypter.js'\nexport * from './connection-gater.js'\nexport * from './content-routing.js'\nexport * from './keys.js'\nexport * from './metrics.js'\nexport * from './peer-discovery.js'\nexport * from './peer-id.js'\nexport * from './peer-info.js'\nexport * from './peer-routing.js'\nexport * from './peer-store.js'\nexport * from './pubsub.js'\nexport * from './record.js'\nexport * from './stream-handler.js'\nexport * from './stream-muxer.js'\nexport * from './topology.js'\nexport * from './transport.js'\nexport * from './errors.js'\nexport * from './event-target.js'\nexport * from './events.js'\nexport * from './startable.js'\n", "import type { AbortOptions, Logger } from './index.js'\nimport type { PeerId } from './peer-id.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Duplex, Source } from 'it-stream-types'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface ConnectionTimeline {\n  /**\n   * When the connection was opened\n   */\n  open: number\n\n  /**\n   * When the MultiaddrConnection was upgraded to a Connection - e.g. the type\n   * of connection encryption and multiplexing was negotiated.\n   */\n  upgraded?: number\n\n  /**\n   * When the connection was closed.\n   */\n  close?: number\n}\n\n/**\n * Outbound connections are opened by the local node, inbound streams are opened by the remote\n */\nexport type Direction = 'inbound' | 'outbound'\n\nexport interface StreamTimeline {\n  /**\n   * A timestamp of when the stream was opened\n   */\n  open: number\n\n  /**\n   * A timestamp of when the stream was closed for both reading and writing\n   */\n  close?: number\n\n  /**\n   * A timestamp of when the stream was closed for reading\n   */\n  closeRead?: number\n\n  /**\n   * A timestamp of when the stream was closed for writing\n   */\n  closeWrite?: number\n\n  /**\n   * A timestamp of when the stream was reset\n   */\n  reset?: number\n\n  /**\n   * A timestamp of when the stream was aborted\n   */\n  abort?: number\n}\n\n/**\n * The states a stream can be in\n */\nexport type StreamStatus = 'open' | 'closing' | 'closed' | 'aborted' | 'reset'\n\n/**\n * The states the readable end of a stream can be in\n *\n * ready - the readable end is ready for reading\n * closing - the readable end is closing\n * closed - the readable end has closed\n */\nexport type ReadStatus = 'ready' | 'closing' | 'closed'\n\n/**\n * The states the writable end of a stream can be in\n *\n * ready - the writable end is ready for writing\n * writing - the writable end is in the process of being written to\n * done - the source passed to the `.sink` function yielded all values without error\n * closing - the writable end is closing\n * closed - the writable end has closed\n */\nexport type WriteStatus = 'ready' | 'writing' | 'done' | 'closing' | 'closed'\n\n/**\n * A Stream is a data channel between two peers that\n * can be written to and read from at both ends.\n *\n * It may be encrypted and multiplexed depending on the\n * configuration of the nodes.\n */\nexport interface Stream extends Duplex<AsyncGenerator<Uint8ArrayList>, Source<Uint8ArrayList | Uint8Array>, Promise<void>> {\n  /**\n   * Closes the stream for **reading** *and* **writing**.\n   *\n   * Any buffered data in the source can still be consumed and the stream will end normally.\n   *\n   * This will cause a `CLOSE` message to be sent to the remote, *unless* the sink has already ended.\n   *\n   * The sink and the source will return normally.\n   */\n  close(options?: AbortOptions): Promise<void>\n\n  /**\n   * Closes the stream for **reading**. If iterating over the source of this stream in a `for await of` loop, it will return (exit the loop) after any buffered data has been consumed.\n   *\n   * This function is called automatically by the muxer when it receives a `CLOSE` message from the remote.\n   *\n   * The source will return normally, the sink will continue to consume.\n   */\n  closeRead(options?: AbortOptions): Promise<void>\n\n  /**\n   * Closes the stream for **writing**. If iterating over the source of this stream in a `for await of` loop, it will return (exit the loop) after any buffered data has been consumed.\n   *\n   * The source will return normally, the sink will continue to consume.\n   */\n  closeWrite(options?: AbortOptions): Promise<void>\n\n  /**\n   * Closes the stream for **reading** *and* **writing**. This should be called when a *local error* has occurred.\n   *\n   * Note, if called without an error any buffered data in the source can still be consumed and the stream will end normally.\n   *\n   * This will cause a `RESET` message to be sent to the remote, *unless* the sink has already ended.\n   *\n   * The sink will return and the source will throw.\n   */\n  abort(err: Error): void\n\n  /**\n   * Unique identifier for a stream. Identifiers are not unique across muxers.\n   */\n  id: string\n\n  /**\n   * Outbound streams are opened by the local node, inbound streams are opened by the remote\n   */\n  direction: Direction\n\n  /**\n   * Lifecycle times for the stream\n   */\n  timeline: StreamTimeline\n\n  /**\n   * The protocol negotiated for this stream\n   */\n  protocol?: string\n\n  /**\n   * User defined stream metadata\n   */\n  metadata: Record<string, any>\n\n  /**\n   * The current status of the stream\n   */\n  status: StreamStatus\n\n  /**\n   * The current status of the readable end of the stream\n   */\n  readStatus: ReadStatus\n\n  /**\n   * The current status of the writable end of the stream\n   */\n  writeStatus: WriteStatus\n\n  /**\n   * The stream logger\n   */\n  log: Logger\n}\n\nexport interface NewStreamOptions extends AbortOptions {\n  /**\n   * If specified, and no handler has been registered with the registrar for the\n   * successfully negotiated protocol, use this as the max outbound stream limit\n   * for the protocol\n   */\n  maxOutboundStreams?: number\n\n  /**\n   * Opt-in to running over a limited connection - one that has restrictions\n   * on the amount of data that may be transferred or how long it may be open for.\n   *\n   * These limits are typically enforced by a relay server, if the protocol\n   * will be transferring a lot of data or the stream will be open for a long time\n   * consider upgrading to a direct connection before opening the stream.\n   *\n   * @default false\n   */\n  runOnLimitedConnection?: boolean\n\n  /**\n   * By default when negotiating a protocol the dialer writes then protocol name\n   * then reads the response.\n   *\n   * When a only a single protocol is being negotiated on an outbound stream,\n   * and the stream is written to before being read from, we can optimistically\n   * write the protocol name and the first chunk of data together in the first\n   * message.\n   *\n   * Reading and handling the protocol response is done asynchronously, which\n   * means we can skip a round trip on writing to newly opened streams which\n   * significantly reduces the time-to-first-byte on a stream.\n   *\n   * The side-effect of this is that the underlying stream won't negotiate the\n   * protocol until either data is written to or read from the stream so it will\n   * not be opened on the remote until this is done.\n   *\n   * Pass `false` here to optimistically write the protocol name and first chunk\n   * of data in the first message.\n   *\n   * If multiple protocols are being negotiated, negotiation is always completed\n   * in full before the stream is returned so this option has no effect.\n   *\n   * @default true\n   */\n  negotiateFully?: boolean\n}\n\nexport type ConnectionStatus = 'open' | 'closing' | 'closed'\n\n/**\n * Connection limits are present on connections that are only allowed to\n * transfer a certain amount of bytes or be open for a certain number\n * of seconds.\n *\n * These limits are applied by Circuit Relay v2 servers, for example and\n * the connection will normally be closed abruptly if the limits are\n * exceeded.\n */\nexport interface ConnectionLimits {\n  /**\n   * If present this is the number of bytes remaining that may be\n   * transferred over this connection\n   */\n  bytes?: bigint\n\n  /**\n   * If present this is the number of seconds that this connection will\n   * remain open for\n   */\n  seconds?: number\n}\n\n/**\n * A Connection is a high-level representation of a connection\n * to a remote peer that may have been secured by encryption and\n * multiplexed, depending on the configuration of the nodes\n * between which the connection is made.\n */\nexport interface Connection {\n  /**\n   * The unique identifier for this connection\n   */\n  id: string\n\n  /**\n   * The address of the remote end of the connection\n   */\n  remoteAddr: Multiaddr\n\n  /**\n   * The id of the peer at the remote end of the connection\n   */\n  remotePeer: PeerId\n\n  /**\n   * A list of tags applied to this connection\n   */\n  tags: string[]\n\n  /**\n   * A list of open streams on this connection\n   */\n  streams: Stream[]\n\n  /**\n   * Outbound connections are opened by the local node, inbound streams are opened by the remote\n   */\n  direction: Direction\n\n  /**\n   * Lifecycle times for the connection\n   */\n  timeline: ConnectionTimeline\n\n  /**\n   * The multiplexer negotiated for this connection\n   */\n  multiplexer?: string\n\n  /**\n   * The encryption protocol negotiated for this connection\n   */\n  encryption?: string\n\n  /**\n   * The current status of the connection\n   */\n  status: ConnectionStatus\n\n  /**\n   * If present, this connection has limits applied to it, perhaps by an\n   * intermediate relay. Once the limits have been reached the connection will\n   * be closed by the relay.\n   */\n  limits?: ConnectionLimits\n\n  /**\n   * The time in milliseconds it takes to make a round trip to the remote peer.\n   *\n   * This is updated periodically by the connection monitor.\n   */\n  rtt?: number\n\n  /**\n   * Create a new stream on this connection and negotiate one of the passed protocols\n   */\n  newStream(protocols: string | string[], options?: NewStreamOptions): Promise<Stream>\n\n  /**\n   * Gracefully close the connection. All queued data will be written to the\n   * underlying transport.\n   */\n  close(options?: AbortOptions): Promise<void>\n\n  /**\n   * Immediately close the connection, any queued data will be discarded\n   */\n  abort(err: Error): void\n\n  /**\n   * The connection logger\n   */\n  log: Logger\n}\n\nexport const connectionSymbol = Symbol.for('@libp2p/connection')\n\nexport function isConnection (other: any): other is Connection {\n  return other != null && Boolean(other[connectionSymbol])\n}\n\nexport interface ConnectionProtector {\n  /**\n   * Takes a given Connection and creates a private encryption stream\n   * between its two peers from the PSK the Protector instance was\n   * created with.\n   */\n  protect(connection: MultiaddrConnection, options?: AbortOptions): Promise<MultiaddrConnection>\n}\n\nexport interface MultiaddrConnectionTimeline {\n  /**\n   * When the connection was opened\n   */\n  open: number\n\n  /**\n   * When the MultiaddrConnection was upgraded to a Connection - the type of\n   * connection encryption and multiplexing was negotiated.\n   */\n  upgraded?: number\n\n  /**\n   * When the connection was closed.\n   */\n  close?: number\n}\n\n/**\n * A MultiaddrConnection is returned by transports after dialing\n * a peer. It is a low-level primitive and is the raw connection\n * without encryption or stream multiplexing.\n */\nexport interface MultiaddrConnection extends Duplex<AsyncGenerator<Uint8Array | Uint8ArrayList>> {\n  /**\n   * Gracefully close the connection. All queued data will be written to the\n   * underlying transport.\n   */\n  close(options?: AbortOptions): Promise<void>\n\n  /**\n   * Immediately close the connection, any queued data will be discarded\n   */\n  abort(err: Error): void\n\n  /**\n   * The address of the remote end of the connection\n   */\n  remoteAddr: Multiaddr\n\n  /**\n   * When connection life cycle events occurred\n   */\n  timeline: MultiaddrConnectionTimeline\n\n  /**\n   * The multiaddr connection logger\n   */\n  log: Logger\n}\n", "import type { RoutingOptions } from './index.js'\nimport type { PeerInfo } from './peer-info.js'\nimport type { CID } from 'multiformats/cid'\n\n/**\n * Any object that implements this Symbol as a property should return a\n * Partial<ContentRouting> instance as the property value, similar to how\n * `Symbol.Iterable` can be used to return an `Iterable` from an `Iterator`.\n *\n * @example\n *\n * ```TypeScript\n * import { contentRoutingSymbol, ContentRouting } from '@libp2p/content-routing'\n *\n * class MyContentRouter implements ContentRouting {\n *   get [contentRoutingSymbol] () {\n *     return this\n *   }\n *\n *   // ...other methods\n * }\n * ```\n */\nexport const contentRoutingSymbol = Symbol.for('@libp2p/content-routing')\n\n/**\n * Implementers of this interface can provide a ContentRouting implementation to\n * interested callers.\n */\nexport interface ContentRoutingProvider {\n  [contentRoutingSymbol]: Partial<ContentRouting>\n}\n\nexport interface ContentRouting {\n  /**\n   * The implementation of this method should ensure that network peers know the\n   * caller can provide content that corresponds to the passed CID.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // ...\n   * await contentRouting.provide(cid)\n   * ```\n   */\n  provide(cid: CID, options?: RoutingOptions): Promise<void>\n\n  /**\n   * If network peers need to be periodically reminded that the caller can\n   * provide content corresponding to the passed CID, call this function to no\n   * longer remind them.\n   */\n  cancelReprovide (key: CID, options?: RoutingOptions): Promise<void>\n\n  /**\n   * Find the providers of the passed CID.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // Iterate over the providers found for the given cid\n   * for await (const provider of contentRouting.findProviders(cid)) {\n   *  console.log(provider.id, provider.multiaddrs)\n   * }\n   * ```\n   */\n  findProviders(cid: CID, options?: RoutingOptions): AsyncIterable<PeerInfo>\n\n  /**\n   * Puts a value corresponding to the passed key in a way that can later be\n   * retrieved by another network peer using the get method.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // ...\n   * const key = '/key'\n   * const value = uint8ArrayFromString('oh hello there')\n   *\n   * await contentRouting.put(key, value)\n   * ```\n   */\n  put(key: Uint8Array, value: Uint8Array, options?: RoutingOptions): Promise<void>\n\n  /**\n   * Retrieves a value from the network corresponding to the passed key.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // ...\n   *\n   * const key = '/key'\n   * const value = await contentRouting.get(key)\n   * ```\n   */\n  get(key: Uint8Array, options?: RoutingOptions): Promise<Uint8Array>\n}\n", "import type { CID } from 'multiformats/cid'\nimport type { MultihashDigest } from 'multiformats/hashes/interface'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport type KeyType = 'RSA' | 'Ed25519' | 'secp256k1' | 'ECDSA'\n\nexport interface RSAPublicKey {\n  /**\n   * The type of this key\n   */\n  readonly type: 'RSA'\n\n  /**\n   * PKIX in ASN1 DER format\n   */\n  readonly raw: Uint8Array\n\n  /**\n   * The public key as a JSON web key\n   */\n  readonly jwk: JsonWebKey\n\n  /**\n   * Returns `true` if the passed object matches this key\n   */\n  equals(key?: any): boolean\n\n  /**\n   * Returns this public key as a Multihash digest.\n   *\n   * It contains a sha256 hash of the protobuf version of the public key.\n   */\n  toMultihash(): MultihashDigest<0x12>\n\n  /**\n   * Return this public key as a CID encoded with the `libp2p-key` codec\n   *\n   * The digest contains a sha256 hash of the protobuf version of the public\n   * key.\n   */\n  toCID(): CID<unknown, 0x72, 0x12, 1>\n\n  /**\n   * Verify the passed data was signed by the private key corresponding to this\n   * public key\n   */\n  verify(data: Uint8Array | Uint8ArrayList, sig: Uint8Array): boolean | Promise<boolean>\n\n  /**\n   * Returns this key as a multihash with base58btc encoding\n   */\n  toString(): string\n}\n\nexport interface Ed25519PublicKey {\n  /**\n   * The type of this key\n   */\n  readonly type: 'Ed25519'\n\n  /**\n   * The raw public key bytes\n   */\n  readonly raw: Uint8Array\n\n  /**\n   * Returns `true` if the passed object matches this key\n   */\n  equals(key?: any): boolean\n\n  /**\n   * Returns this public key as an identity hash containing the protobuf wrapped\n   * public key\n   */\n  toMultihash(): MultihashDigest<0x0>\n\n  /**\n   * Return this public key as a CID encoded with the `libp2p-key` codec\n   *\n   * The digest contains an identity hash containing the protobuf wrapped\n   * version of the public key.\n   */\n  toCID(): CID<unknown, 0x72, 0x0, 1>\n\n  /**\n   * Verify the passed data was signed by the private key corresponding to this\n   * public key\n   */\n  verify(data: Uint8Array | Uint8ArrayList, sig: Uint8Array): boolean | Promise<boolean>\n\n  /**\n   * Returns this key as a multihash with base58btc encoding\n   */\n  toString(): string\n}\n\nexport interface Secp256k1PublicKey {\n  /**\n   * The type of this key\n   */\n  readonly type: 'secp256k1'\n\n  /**\n   * The raw public key bytes\n   */\n  readonly raw: Uint8Array\n\n  /**\n   * Returns `true` if the passed object matches this key\n   */\n  equals(key?: any): boolean\n\n  /**\n   * Returns this public key as an identity hash containing the protobuf wrapped\n   * public key\n   */\n  toMultihash(): MultihashDigest<0x0>\n\n  /**\n   * Return this public key as a CID encoded with the `libp2p-key` codec\n   *\n   * The digest contains an identity hash containing the protobuf wrapped\n   * version of the public key.\n   */\n  toCID(): CID<unknown, 0x72, 0x0, 1>\n\n  /**\n   * Verify the passed data was signed by the private key corresponding to this\n   * public key\n   */\n  verify(data: Uint8Array | Uint8ArrayList, sig: Uint8Array): boolean | Promise<boolean>\n\n  /**\n   * Returns this key as a multihash with base58btc encoding\n   */\n  toString(): string\n}\n\nexport interface ECDSAPublicKey {\n  /**\n   * The type of this key\n   */\n  readonly type: 'ECDSA'\n\n  /**\n   * The public key as a DER-encoded PKIMessage\n   */\n  readonly raw: Uint8Array\n\n  /**\n   * The public key as a JSON web key\n   */\n  readonly jwk: JsonWebKey\n\n  /**\n   * Returns `true` if the passed object matches this key\n   */\n  equals(key?: any): boolean\n\n  /**\n   * Returns this public key as an identity hash containing the protobuf wrapped\n   * public key\n   */\n  toMultihash(): MultihashDigest<0x0>\n\n  /**\n   * Return this public key as a CID encoded with the `libp2p-key` codec\n   *\n   * The digest contains an identity hash containing the protobuf wrapped\n   * version of the public key.\n   */\n  toCID(): CID<unknown, 0x72, 0x0, 1>\n\n  /**\n   * Verify the passed data was signed by the private key corresponding to this\n   * public key\n   */\n  verify(data: Uint8Array | Uint8ArrayList, sig: Uint8Array): boolean | Promise<boolean>\n\n  /**\n   * Returns this key as a multihash with base58btc encoding\n   */\n  toString(): string\n}\n\nexport type PublicKey = RSAPublicKey | Ed25519PublicKey | Secp256k1PublicKey | ECDSAPublicKey\n\n/**\n * Returns true if the passed argument has type overlap with the `PublicKey`\n * interface. Can be used to disambiguate object types.\n */\nexport function isPublicKey (key?: any): key is PublicKey {\n  if (key == null) {\n    return false\n  }\n\n  return (key.type === 'RSA' || key.type === 'Ed25519' || key.type === 'secp256k1' || key.type === 'ECDSA') &&\n    key.raw instanceof Uint8Array &&\n    typeof key.equals === 'function' &&\n    typeof key.toMultihash === 'function' &&\n    typeof key.toCID === 'function' &&\n    typeof key.verify === 'function'\n}\n\n/**\n * Generic private key interface\n */\nexport interface RSAPrivateKey {\n  /**\n   * The type of this key\n   */\n  readonly type: 'RSA'\n\n  /**\n   * The public key that corresponds to this private key\n   */\n  readonly publicKey: RSAPublicKey\n\n  /**\n   * PKIX in ASN1 DER format\n   */\n  readonly raw: Uint8Array\n\n  /**\n   * The private key as a JSON web key\n   */\n  readonly jwk: JsonWebKey\n\n  /**\n   * Returns `true` if the passed object matches this key\n   */\n  equals(key?: any): boolean\n\n  /**\n   * Sign the passed data with this private key and return the signature for\n   * later verification\n   */\n  sign(data: Uint8Array | Uint8ArrayList): Uint8Array | Promise<Uint8Array>\n}\n\nexport interface Ed25519PrivateKey {\n  /**\n   * The type of this key\n   */\n  readonly type: 'Ed25519'\n\n  /**\n   * The public key that corresponds to this private key\n   */\n  readonly publicKey: Ed25519PublicKey\n\n  /**\n   * The raw private key bytes\n   */\n  readonly raw: Uint8Array\n\n  /**\n   * Returns `true` if the passed object matches this key\n   */\n  equals(key?: any): boolean\n\n  /**\n   * Sign the passed data with this private key and return the signature for\n   * later verification\n   */\n  sign(data: Uint8Array | Uint8ArrayList): Uint8Array | Promise<Uint8Array>\n}\n\nexport interface Secp256k1PrivateKey {\n  /**\n   * The type of this key\n   */\n  readonly type: 'secp256k1'\n\n  /**\n   * The public key that corresponds to this private key\n   */\n  readonly publicKey: Secp256k1PublicKey\n\n  /**\n   * The raw private key bytes\n   */\n  readonly raw: Uint8Array\n\n  /**\n   * Returns `true` if the passed object matches this key\n   */\n  equals(key?: any): boolean\n\n  /**\n   * Sign the passed data with this private key and return the signature for\n   * later verification\n   */\n  sign(data: Uint8Array | Uint8ArrayList): Uint8Array | Promise<Uint8Array>\n}\n\nexport interface ECDSAPrivateKey {\n  /**\n   * The type of this key\n   */\n  readonly type: 'ECDSA'\n\n  /**\n   * The public key that corresponds to this private key\n   */\n  readonly publicKey: ECDSAPublicKey\n\n  /**\n   * The private key as a DER-encoded PKIMessage\n   */\n  readonly raw: Uint8Array\n\n  /**\n   * The private key as a JSON web key\n   */\n  readonly jwk: JsonWebKey\n\n  /**\n   * Returns `true` if the passed object matches this key\n   */\n  equals(key?: any): boolean\n\n  /**\n   * Sign the passed data with this private key and return the signature for\n   * later verification\n   */\n  sign(data: Uint8Array | Uint8ArrayList): Uint8Array | Promise<Uint8Array>\n}\n\nexport type PrivateKey = RSAPrivateKey | Ed25519PrivateKey | Secp256k1PrivateKey | ECDSAPrivateKey\n\n/**\n * Returns true if the passed argument has type overlap with the `PrivateKey`\n * interface. Can be used to disambiguate object types.\n */\nexport function isPrivateKey (key?: any): key is PrivateKey {\n  if (key == null) {\n    return false\n  }\n\n  return (key.type === 'RSA' || key.type === 'Ed25519' || key.type === 'secp256k1' || key.type === 'ECDSA') &&\n    isPublicKey(key.publicKey) &&\n    key.raw instanceof Uint8Array &&\n    typeof key.equals === 'function' &&\n    typeof key.sign === 'function'\n}\n", "import type { TypedEventTarget } from './event-target.js'\nimport type { PeerInfo } from './peer-info.js'\n\n/**\n * Any object that implements this Symbol as a property should return a\n * PeerDiscovery instance as the property value, similar to how\n * `Symbol.Iterable` can be used to return an `Iterable` from an `Iterator`.\n *\n * @example\n *\n * ```TypeScript\n * import { peerDiscovery, PeerDiscovery } from '@libp2p/peer-discovery'\n *\n * class MyPeerDiscoverer implements PeerDiscovery {\n *   get [peerDiscovery] () {\n *     return this\n *   }\n *\n *   // ...other methods\n * }\n * ```\n */\nexport const peerDiscoverySymbol = Symbol.for('@libp2p/peer-discovery')\n\n/**\n * Implementers of this interface can provide a PeerDiscovery implementation to\n * interested callers.\n */\nexport interface PeerDiscoveryProvider {\n  [peerDiscoverySymbol]: PeerDiscovery\n}\n\nexport interface PeerDiscoveryEvents {\n  peer: CustomEvent<PeerInfo>\n}\n\n/**\n * A class that implements the `PeerDiscovery` interface uses an\n * implementation-specific method to discover peers. These peers are then added\n * to the peer store for use by other system components and services.\n */\nexport interface PeerDiscovery extends TypedEventTarget<PeerDiscoveryEvents> {}\n", "import type { Ed25519PublicKey, KeyType, RSAPublicKey, Secp256k1PublicKey } from './keys.js'\nimport type { CID } from 'multiformats/cid'\nimport type { MultihashDigest } from 'multiformats/hashes/interface'\n\nexport type PeerIdType = KeyType | string\n\n/**\n * A PeerId generated from an RSA public key - it is a base58btc encoded sha-256\n * hash of the public key.\n *\n * RSA public keys are too large to pass around freely, instead Ed25519 or\n * secp256k1 should be preferred as they can embed their public key in the\n * PeerId itself.\n *\n * @deprecated Ed25519 or secp256k1 keys are preferred to RSA\n */\nexport interface RSAPeerId {\n  readonly type: 'RSA'\n\n  /**\n   * RSA public keys are too large to embed in the multihash commonly used to\n   * refer to peers, so this will only be defined if the public key has\n   * previously been found through a routing query or during normal protocol\n   * operations\n   */\n  readonly publicKey?: RSAPublicKey\n\n  /**\n   * Returns the multihash from `toMultihash()` as a base58btc encoded string\n   */\n  toString(): string\n\n  /**\n   * Returns a multihash, the digest of which is the SHA2-256 hash of the public\n   * key\n   */\n  toMultihash(): MultihashDigest<0x12>\n\n  /**\n   * Returns a CID with the libp2p key code and the same multihash as\n   * `toMultihash()`\n   */\n  toCID(): CID<Uint8Array, 0x72, 0x12, 1>\n\n  /**\n   * Returns true if the passed argument is equivalent to this PeerId\n   */\n  equals(other?: any): boolean\n}\n\nexport interface Ed25519PeerId {\n  readonly type: 'Ed25519'\n\n  /**\n   * This will always be defined as the public key is embedded in the multihash\n   * of this PeerId\n   */\n  readonly publicKey: Ed25519PublicKey\n\n  /**\n   * Returns the multihash from `toMultihash()` as a base58btc encoded string\n   */\n  toString(): string\n\n  /**\n   * Returns a multihash, the digest of which is the protobuf-encoded public key\n   * encoded as an identity hash\n   */\n  toMultihash(): MultihashDigest<0x0>\n\n  /**\n   * Returns a CID with the libp2p key code and the same multihash as\n   * `toMultihash()`\n   */\n  toCID(): CID<Uint8Array, 0x72, 0x0, 1>\n\n  /**\n   * Returns true if the passed argument is equivalent to this PeerId\n   */\n  equals(other?: any): boolean\n}\n\nexport interface Secp256k1PeerId {\n  readonly type: 'secp256k1'\n\n  /**\n   * This will always be defined as the public key is embedded in the multihash\n   * of this PeerId\n   */\n  readonly publicKey: Secp256k1PublicKey\n\n  /**\n   * Returns the multihash from `toMultihash()` as a base58btc encoded string\n   */\n  toString(): string\n\n  /**\n   * Returns a multihash, the digest of which is the protobuf-encoded public key\n   * encoded as an identity hash\n   */\n  toMultihash(): MultihashDigest<0x0>\n\n  /**\n   * Returns a CID with the libp2p key code and the same multihash as\n   * `toMultihash()`\n   */\n  toCID(): CID<Uint8Array, 0x72, 0x0, 1>\n\n  /**\n   * Returns true if the passed argument is equivalent to this PeerId\n   */\n  equals(other?: any): boolean\n}\n\nexport interface URLPeerId {\n  readonly type: 'url'\n\n  /**\n   * This will always be undefined as URL Peers do not have public keys\n   */\n  readonly publicKey: undefined\n\n  /**\n   * Returns CID from `toCID()` encoded as a base36 string\n   */\n  toString(): string\n\n  /**\n   * Returns a multihash, the digest of which is the URL encoded as an identity\n   * hash\n   */\n  toMultihash(): MultihashDigest<0x0>\n\n  /**\n   * Returns a CID with the Transport IPFS Gateway HTTP code and the same\n   * multihash as `toMultihash()`\n   */\n  toCID(): CID<Uint8Array, 0x0920, 0x0, 1>\n\n  /**\n   * Returns true if the passed argument is equivalent to this PeerId\n   */\n  equals(other?: any): boolean\n}\n\n/**\n * This is a union of all known PeerId types - use the `.type` field to\n * disambiguate them\n */\nexport type PeerId = RSAPeerId | Ed25519PeerId | Secp256k1PeerId | URLPeerId\n\n/**\n * All PeerId implementations must use this symbol as the name of a property\n * with a boolean `true` value\n */\nexport const peerIdSymbol = Symbol.for('@libp2p/peer-id')\n\n/**\n * Returns true if the passed argument is a PeerId implementation\n */\nexport function isPeerId (other?: any): other is PeerId {\n  return Boolean(other?.[peerIdSymbol])\n}\n", "import type { RoutingOptions } from './index.js'\nimport type { PeerId } from './peer-id.js'\nimport type { PeerInfo } from './peer-info.js'\n\n/**\n * Any object that implements this Symbol as a property should return a\n * PeerRouting instance as the property value, similar to how `Symbol.Iterable`\n * can be used to return an `Iterable` from an `Iterator`.\n *\n * @example\n *\n * ```TypeScript\n * import { peerRouting, PeerRouting } from '@libp2p/peer-routing'\n *\n * class MyPeerRouter implements PeerRouting {\n *   get [peerRouting] () {\n *     return this\n *   }\n *\n *   // ...other methods\n * }\n * ```\n */\nexport const peerRoutingSymbol = Symbol.for('@libp2p/peer-routing')\n\n/**\n * Implementers of this interface can provide a PeerRouting implementation to\n * interested callers.\n */\nexport interface PeerRoutingProvider {\n  [peerRoutingSymbol]: Partial<PeerRouting>\n}\n\nexport interface PeerRouting {\n  /**\n   * Searches the network for peer info corresponding to the passed peer id.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // ...\n   * const peer = await peerRouting.findPeer(peerId, options)\n   * ```\n   */\n  findPeer(peerId: PeerId, options?: RoutingOptions): Promise<PeerInfo>\n\n  /**\n   * Search the network for peers that are closer to the passed key. Peer\n   * info should be yielded in ever-increasing closeness to the key.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // Iterate over the closest peers found for the given key\n   * for await (const peer of peerRouting.getClosestPeers(key)) {\n   *   console.log(peer.id, peer.multiaddrs)\n   * }\n   * ```\n   */\n  getClosestPeers(key: Uint8Array, options?: RoutingOptions): AsyncIterable<PeerInfo>\n}\n", "import type { PublicKey } from './keys.js'\nimport type { PeerId } from './peer-id.js'\nimport type { PeerInfo } from './peer-info.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\n/**\n * When a peer that is tagged with this prefix disconnects, we will attempt to\n * redial it, up to a limit.\n *\n * To allow multiple components to add/remove their own keep-alive tags without\n * accidentally overwriting those of other components, attach a unique suffix to\n * the tag, e.g. `keep-alive-circuit-relay` or `keep-alive-kad-dht`, etc.\n */\nexport const KEEP_ALIVE = 'keep-alive'\n\n/**\n * A multiaddr with an optional flag that indicates if its trustworthy\n */\nexport interface Address {\n  /**\n   * Peer multiaddr\n   */\n  multiaddr: Multiaddr\n\n  /**\n   * Obtained from a signed peer record\n   */\n  isCertified: boolean\n}\n\n/**\n * Data stored in the peer store about peers\n */\nexport interface Peer {\n  /**\n   * Peer's peer-id instance\n   */\n  id: PeerId\n\n  /**\n   * Peer's addresses containing a list of multiaddrs and a isCertified field\n   * indicating if the address was loaded from a signed peer record or not\n   */\n  addresses: Address[]\n\n  /**\n   * Peer's supported protocols\n   */\n  protocols: string[]\n\n  /**\n   * Peer's metadata map\n   */\n  metadata: Map<string, Uint8Array>\n\n  /**\n   * Tags a peer has\n   */\n  tags: Map<string, Tag>\n\n  /**\n   * The last peer record envelope received\n   */\n  peerRecordEnvelope?: Uint8Array\n}\n\n/**\n * Peer data used to update the peer store\n */\nexport interface PeerData {\n  /**\n   * Peer's addresses containing its multiaddrs and metadata - multiaddrs\n   * passed here can be treated as certified if the `isCertifed` value is\n   * set to true.\n   *\n   * If both addresses and multiaddrs are specified they will be merged\n   * together with entries in addresses taking precedence.\n   */\n  addresses?: Address[]\n\n  /**\n   * Peer's multiaddrs - any multiaddrs passed here will be treated as\n   * uncertified.\n   *\n   * If both addresses and multiaddrs are specified they will be merged\n   * together with entries in addresses taking precedence.\n   */\n  multiaddrs?: Multiaddr[]\n\n  /**\n   * Peer's supported protocols\n   */\n  protocols?: string[]\n\n  /**\n   * Peer's metadata map. When merging pass undefined as values to remove metadata.\n   */\n  metadata?: Map<string, Uint8Array | undefined> | Record<string, Uint8Array | undefined>\n\n  /**\n   * Peer tags. When merging pass undefined as values to remove tags.\n   */\n  tags?: Map<string, TagOptions | undefined> | Record<string, TagOptions | undefined>\n\n  /**\n   * If this Peer has an RSA key, it's public key can be set with this property.\n   *\n   * The byte array should be the protobuf encoded form of the public key.\n   */\n  publicKey?: PublicKey\n\n  /**\n   * The last peer record envelope received\n   */\n  peerRecordEnvelope?: Uint8Array\n}\n\nexport interface TagOptions {\n  /**\n   * An optional tag value (1-100)\n   */\n  value?: number\n\n  /**\n   * An optional duration in ms after which the tag will expire\n   */\n  ttl?: number\n}\n\nexport interface Tag {\n  /**\n   * The tag value\n   */\n  value: number\n}\n\n/**\n * A predicate by which to filter lists of peers\n */\nexport interface PeerQueryFilter { (peer: Peer): boolean }\n\n/**\n * A predicate by which to sort lists of peers\n */\nexport interface PeerQueryOrder { (a: Peer, b: Peer): -1 | 0 | 1 }\n\n/**\n * A query for getting lists of peers\n */\nexport interface PeerQuery {\n  filters?: PeerQueryFilter[]\n  orders?: PeerQueryOrder[]\n  limit?: number\n  offset?: number\n}\n\nexport interface PeerStore {\n  /**\n   * Loop over every peer - the looping is async because we read from a\n   * datastore but the peer operation is sync, this is to prevent\n   * long-lived peer operations causing deadlocks over the datastore\n   * which can happen if they try to access the peer store during the\n   * loop\n   *\n   * @example\n   *\n   * ```TypeScript\n   * await peerStore.forEach(peer => {\n   *   // ...\n   * })\n   * ```\n   */\n  forEach(fn: (peer: Peer) => void, query?: PeerQuery): Promise<void>\n\n  /**\n   * Returns all peers in the peer store.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for (const peer of await peerStore.all()) {\n   *   // ...\n   * }\n   * ```\n   */\n  all(query?: PeerQuery): Promise<Peer[]>\n\n  /**\n   * Delete all data stored for the passed peer\n   *\n   * @example\n   *\n   * ```TypeScript\n   * await peerStore.addressBook.set(peerId, multiaddrs)\n   * await peerStore.addressBook.get(peerId)\n   * // multiaddrs[]\n   *\n   * await peerStore.delete(peerId)\n   *\n   * await peerStore.addressBook.get(peerId)\n   * // []\n   * ```\n   */\n  delete(peerId: PeerId): Promise<void>\n\n  /**\n   * Returns true if the passed PeerId is in the peer store\n   *\n   * @example\n   *\n   * ```TypeScript\n   * await peerStore.has(peerId)\n   * // false\n   * await peerStore.addressBook.add(peerId, multiaddrs)\n   * await peerStore.has(peerId)\n   * // true\n   * ```\n   */\n  has(peerId: PeerId): Promise<boolean>\n\n  /**\n   * Returns all data stored for the passed PeerId\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peer = await peerStore.get(peerId)\n   * // { .. }\n   * ```\n   */\n  get(peerId: PeerId): Promise<Peer>\n\n  /**\n   * Returns a PeerInfo object for the passed peer id. This is similar to `get`\n   * except the returned value contains fewer fields and is often used to\n   * exchange peer information with other systems.\n   *\n   * The returned object can be passed to `JSON.stringify` without any\n   * additional processing.\n   *\n   * @see https://docs.libp2p.io/concepts/fundamentals/peers/#peer-info\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peerInfo = await peerStore.getInfo(peerId)\n   *\n   * console.info(JSON.stringify(peerInfo))\n   * // {\n   * //    id: 'peerId'\n   * //    multiaddrs: [\n   * //      '...'\n   * //    ]\n   * // }\n   * ```\n   */\n  getInfo (peerId: PeerId): Promise<PeerInfo>\n\n  /**\n   * Adds a peer to the peer store, overwriting any existing data\n   *\n   * @example\n   *\n   * ```TypeScript\n   * await peerStore.save(peerId, {\n   *   multiaddrs\n   * })\n   * ```\n   */\n  save(id: PeerId, data: PeerData): Promise<Peer>\n\n  /**\n   * Adds a peer to the peer store, overwriting only the passed fields\n   *\n   * @example\n   *\n   * ```TypeScript\n   * await peerStore.patch(peerId, {\n   *   multiaddrs\n   * })\n   * ```\n   */\n  patch(id: PeerId, data: PeerData): Promise<Peer>\n\n  /**\n   * Adds a peer to the peer store, deeply merging any existing data.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * await peerStore.merge(peerId, {\n   *   multiaddrs\n   * })\n   * ```\n   */\n  merge(id: PeerId, data: PeerData): Promise<Peer>\n\n  /**\n   * Unmarshal and verify a signed peer record, extract the multiaddrs and\n   * overwrite the stored addresses for the peer.\n   *\n   * Optionally pass an expected PeerId to verify that the peer record was\n   * signed by that peer.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * await peerStore.consumePeerRecord(buf, expectedPeer)\n   * ```\n   */\n  consumePeerRecord(buf: Uint8Array, expectedPeer?: PeerId): Promise<boolean>\n}\n", "import type { Stream } from './connection.js'\nimport type { TypedEventTarget } from './event-target.js'\nimport type { PublicKey } from './keys.js'\nimport type { PeerId } from './peer-id.js'\nimport type { Pushable } from 'it-pushable'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\n/**\n * On the producing side:\n * - Build messages with the signature, key (from may be enough for certain inlineable public key types), from and seqno fields.\n *\n * On the consuming side:\n * - Enforce the fields to be present, reject otherwise.\n * - Propagate only if the fields are valid and signature can be verified, reject otherwise.\n */\nexport const StrictSign = 'StrictSign'\n\n/**\n * On the producing side:\n * - Build messages without the signature, key, from and seqno fields.\n * - The corresponding protobuf key-value pairs are absent from the marshaled message, not just empty.\n *\n * On the consuming side:\n * - Enforce the fields to be absent, reject otherwise.\n * - Propagate only if the fields are absent, reject otherwise.\n * - A message_id function will not be able to use the above fields, and should instead rely on the data field. A commonplace strategy is to calculate a hash.\n */\nexport const StrictNoSign = 'StrictNoSign'\n\nexport type SignaturePolicy = typeof StrictSign | typeof StrictNoSign\n\nexport interface SignedMessage {\n  type: 'signed'\n  from: PeerId\n  topic: string\n  data: Uint8Array\n  sequenceNumber: bigint\n  signature: Uint8Array\n  key: PublicKey\n}\n\nexport interface UnsignedMessage {\n  type: 'unsigned'\n  topic: string\n  data: Uint8Array\n}\n\nexport type Message = SignedMessage | UnsignedMessage\n\nexport interface PubSubRPCMessage {\n  from?: Uint8Array\n  topic?: string\n  data?: Uint8Array\n  sequenceNumber?: Uint8Array\n  signature?: Uint8Array\n  key?: Uint8Array\n}\n\nexport interface PubSubRPCSubscription {\n  subscribe?: boolean\n  topic?: string\n}\n\nexport interface PubSubRPC {\n  subscriptions: PubSubRPCSubscription[]\n  messages: PubSubRPCMessage[]\n}\n\nexport interface PeerStreams extends TypedEventTarget<PeerStreamEvents> {\n  id: PeerId\n  protocol: string\n  outboundStream?: Pushable<Uint8ArrayList>\n  inboundStream?: AsyncIterable<Uint8ArrayList>\n  isWritable: boolean\n\n  close(): void\n  write(buf: Uint8Array | Uint8ArrayList): void\n  attachInboundStream(stream: Stream): AsyncIterable<Uint8ArrayList>\n  attachOutboundStream(stream: Stream): Promise<Pushable<Uint8ArrayList>>\n}\n\nexport interface PubSubInit {\n  enabled?: boolean\n\n  multicodecs?: string[]\n\n  /**\n   * defines how signatures should be handled\n   */\n  globalSignaturePolicy?: SignaturePolicy\n\n  /**\n   * if can relay messages not subscribed\n   */\n  canRelayMessage?: boolean\n\n  /**\n   * if publish should emit to self, if subscribed\n   */\n  emitSelf?: boolean\n\n  /**\n   * handle this many incoming pubsub messages concurrently\n   */\n  messageProcessingConcurrency?: number\n\n  /**\n   * How many parallel incoming streams to allow on the pubsub protocol per-connection\n   */\n  maxInboundStreams?: number\n\n  /**\n   * How many parallel outgoing streams to allow on the pubsub protocol per-connection\n   */\n  maxOutboundStreams?: number\n}\n\nexport interface Subscription {\n  topic: string\n  subscribe: boolean\n}\n\nexport interface SubscriptionChangeData {\n  peerId: PeerId\n  subscriptions: Subscription[]\n}\n\nexport interface PubSubEvents {\n  'subscription-change': CustomEvent<SubscriptionChangeData>\n  message: CustomEvent<Message>\n}\n\nexport interface PublishResult {\n  recipients: PeerId[]\n}\n\nexport enum TopicValidatorResult {\n  /**\n   * The message is considered valid, and it should be delivered and forwarded to the network\n   */\n  Accept = 'accept',\n  /**\n   * The message is neither delivered nor forwarded to the network\n   */\n  Ignore = 'ignore',\n  /**\n   * The message is considered invalid, and it should be rejected\n   */\n  Reject = 'reject'\n}\n\nexport interface TopicValidatorFn {\n  (peer: PeerId, message: Message): TopicValidatorResult | Promise<TopicValidatorResult>\n}\n\n/**\n * @deprecated This will be removed from `@libp2p/interface` in a future release, pubsub implementations should declare their own types\n */\nexport interface PubSub<Events extends Record<string, any> = PubSubEvents> extends TypedEventTarget<Events> {\n  /**\n   * The global signature policy controls whether or not we sill send and receive\n   * signed or unsigned messages.\n   *\n   * Signed messages prevent spoofing message senders and should be preferred to\n   * using unsigned messages.\n   */\n  globalSignaturePolicy: typeof StrictSign | typeof StrictNoSign\n\n  /**\n   * A list of multicodecs that contain the pubsub protocol name.\n   */\n  multicodecs: string[]\n\n  /**\n   * Pubsub routers support message validators per topic, which will validate the message\n   * before its propagations. They are stored in a map where keys are the topic name and\n   * values are the validators.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const validateMessage = (msgTopic, msg) => {\n   *   const input = uint8ArrayToString(msg.data)\n   *   const validInputs = ['a', 'b', 'c']\n   *\n   *   if (!validInputs.includes(input)) {\n   *     throw new Error('no valid input received')\n   *   }\n   * }\n   * libp2p.pubsub.topicValidators.set(topic, validateMessage)\n   * ```\n   */\n  topicValidators: Map<string, TopicValidatorFn>\n\n  getPeers(): PeerId[]\n\n  /**\n   * Gets a list of topics the node is subscribed to.\n   *\n   * ```TypeScript\n   * const topics = libp2p.pubsub.getTopics()\n   * ```\n   */\n  getTopics(): string[]\n\n  /**\n   * Subscribes to a pubsub topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const handler = (msg) => {\n   *   if (msg.topic === topic) {\n   *     // msg.data - pubsub data received\n   *   }\n   * }\n   *\n   * libp2p.pubsub.addEventListener('message', handler)\n   * libp2p.pubsub.subscribe(topic)\n   * ```\n   */\n  subscribe(topic: string): void\n\n  /**\n   * Unsubscribes from a pubsub topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const handler = (msg) => {\n   *   // msg.data - pubsub data received\n   * }\n   *\n   * libp2p.pubsub.removeEventListener(topic handler)\n   * libp2p.pubsub.unsubscribe(topic)\n   * ```\n   */\n  unsubscribe(topic: string): void\n\n  /**\n   * Gets a list of the PeerIds that are subscribed to one topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peerIds = libp2p.pubsub.getSubscribers(topic)\n   * ```\n   */\n  getSubscribers(topic: string): PeerId[]\n\n  /**\n   * Publishes messages to the given topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const data = uint8ArrayFromString('data')\n   *\n   * await libp2p.pubsub.publish(topic, data)\n   * ```\n   */\n  publish(topic: string, data: Uint8Array): Promise<PublishResult>\n}\n\nexport interface PeerStreamEvents {\n  'stream:inbound': CustomEvent<never>\n  'stream:outbound': CustomEvent<never>\n  close: CustomEvent<never>\n}\n\n/**\n * All Pubsub implementations must use this symbol as the name of a property\n * with a boolean `true` value\n */\nexport const pubSubSymbol = Symbol.for('@libp2p/pubsub')\n\n/**\n * Returns true if the passed argument is a PubSub implementation\n */\nexport function isPubSub (obj?: any): obj is PubSub {\n  return Boolean(obj?.[pubSubSymbol])\n}\n", "import type { Connection, ConnectionLimits, MultiaddrConnection } from './connection.js'\nimport type { TypedEventTarget } from './event-target.js'\nimport type { AbortOptions, ClearableSignal, ConnectionEncrypter } from './index.js'\nimport type { StreamMuxerFactory } from './stream-muxer.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { ProgressOptions, ProgressEvent } from 'progress-events'\n\nexport interface ListenerEvents {\n  /**\n   * This event signals to the transport manager that the listening addresses\n   * have changed and may be emitted at any point and/or multiple times\n   */\n  listening: CustomEvent\n\n  /**\n   * Emitted if listening on an address failed\n   */\n  error: CustomEvent<Error>\n\n  /**\n   * Emitted when the listener has been shut down, has no open connections and\n   * will no longer accept new connections\n   */\n  close: CustomEvent\n}\n\nexport interface Listener extends TypedEventTarget<ListenerEvents> {\n  /**\n   * Start a listener\n   */\n  listen(multiaddr: Multiaddr): Promise<void>\n  /**\n   * Get listen addresses\n   */\n  getAddrs(): Multiaddr[]\n  /**\n   * Close listener\n   *\n   * @returns {Promise<void>}\n   */\n  close(): Promise<void>\n  /**\n   * Allows transports to amend announce addresses - to add certificate hashes\n   * or other metadata that cannot be known before runtime\n   */\n  updateAnnounceAddrs(addrs: Multiaddr[]): void\n}\n\nexport const transportSymbol = Symbol.for('@libp2p/transport')\n\n/**\n * A filter that acts on a list of multiaddrs\n */\nexport interface MultiaddrFilter {\n  (multiaddrs: Multiaddr[]): Multiaddr[]\n}\n\nexport interface CreateListenerOptions {\n  /**\n   * The upgrader turns a MultiaddrConnection into a Connection and notifies\n   * other libp2p components about a new incoming connection.\n   */\n  upgrader: Upgrader\n}\n\nexport interface DialTransportOptions<DialEvents extends ProgressEvent = ProgressEvent> extends Required<AbortOptions>, ProgressOptions<DialEvents> {\n  /**\n   * The upgrader turns a MultiaddrConnection into a Connection which should be\n   * returned by the transport's dial method\n   */\n  upgrader: Upgrader\n}\n\n/**\n * A libp2p transport offers dial and listen methods to establish connections.\n */\nexport interface Transport<DialEvents extends ProgressEvent = ProgressEvent> {\n  /**\n   * Used to identify the transport\n   */\n  [Symbol.toStringTag]: string\n\n  /**\n   * Used by the isTransport function\n   */\n  [transportSymbol]: true\n\n  /**\n   * Dial a given multiaddr.\n   */\n  dial(ma: Multiaddr, options: DialTransportOptions<DialEvents>): Promise<Connection>\n\n  /**\n   * Create transport listeners.\n   */\n  createListener(options: CreateListenerOptions): Listener\n\n  /**\n   * Takes a list of `Multiaddr`s and returns only addresses that are valid for\n   * the transport to listen on\n   */\n  listenFilter: MultiaddrFilter\n\n  /**\n   * Takes a list of `Multiaddr`s and returns only addresses that are valid for\n   * the transport to dial\n   */\n  dialFilter: MultiaddrFilter\n}\n\n/**\n * Used to disambiguate transport implementations\n */\nexport function isTransport (other?: any): other is Transport {\n  return other != null && Boolean(other[transportSymbol])\n}\n\n/**\n * Enum Transport Manager Fault Tolerance values\n */\nexport enum FaultTolerance {\n  /**\n   * should be used for failing in any listen circumstance\n   */\n  FATAL_ALL = 0,\n\n  /**\n   * should be used for not failing when not listening\n   */\n  NO_FATAL\n}\n\n/**\n * Options accepted by the upgrader during connection establishment\n */\nexport interface UpgraderOptions<ConnectionUpgradeEvents extends ProgressEvent = ProgressEvent> extends ProgressOptions<ConnectionUpgradeEvents>, Required<AbortOptions> {\n  /**\n   * If true the invoking transport is expected to implement it's own encryption\n   * and an encryption protocol will not attempted to be negotiated via\n   * multi-stream select\n   *\n   * @default false\n   */\n  skipEncryption?: boolean\n\n  /**\n   * If true no connection protection will be performed on the connection.\n   */\n  skipProtection?: boolean\n\n  /**\n   * By default a stream muxer protocol will be negotiated via multi-stream\n   * select after an encryption protocol has been agreed on.\n   *\n   * If a transport provides it's own stream muxing facility pass a muxer\n   * factory instance here to skip muxer negotiation.\n   */\n  muxerFactory?: StreamMuxerFactory\n\n  /**\n   * If the connection is to have limits applied to it, pass them here\n   */\n  limits?: ConnectionLimits\n\n  /**\n   * Multi-stream select is a initiator/responder protocol. By default a\n   * connection returned from `upgrader.upgradeOutbound` will be the initiator\n   * and one returned from `upgrader.upgradeInbound` will be the responder.\n   *\n   * Pass a value here to override the default.\n   */\n  initiator?: boolean\n}\n\nexport type InboundConnectionUpgradeEvents =\nProgressEvent<'upgrader:encrypt-inbound-connection'> |\nProgressEvent<'upgrader:multiplex-inbound-connection'>\n\nexport type OutboundConnectionUpgradeEvents =\nProgressEvent<'upgrader:encrypt-outbound-connection'> |\nProgressEvent<'upgrader:multiplex-outbound-connection'>\n\nexport interface Upgrader {\n  /**\n   * Upgrades an outbound connection created by the `dial` method of a transport\n   */\n  upgradeOutbound(maConn: MultiaddrConnection, opts?: UpgraderOptions<OutboundConnectionUpgradeEvents>): Promise<Connection>\n\n  /**\n   * Upgrades an inbound connection received by a transport listener and\n   * notifies other libp2p components about the new connection\n   */\n  upgradeInbound(maConn: MultiaddrConnection, opts?: UpgraderOptions<InboundConnectionUpgradeEvents>): Promise<void>\n\n  /**\n   * Used by transports that perform part of the upgrade process themselves and\n   * do some async work. This allows configuring inbound upgrade timeouts from a\n   * single location.\n   *\n   * Regular transports should just pass the signal from their shutdown\n   * controller to `upgradeInbound`.\n   */\n  createInboundAbortSignal (signal: AbortSignal): ClearableSignal\n\n  /**\n   * Returns configured stream muxers\n   */\n  getStreamMuxers (): Map<string, StreamMuxerFactory>\n\n  /**\n   * Returns configured connection encrypters\n   */\n  getConnectionEncrypters (): Map<string, ConnectionEncrypter>\n}\n", "/**\n * When this error is thrown it means an operation was aborted,\n * usually in response to the `abort` event being emitted by an\n * AbortSignal.\n */\nexport class AbortError extends Error {\n  static name = 'AbortError'\n\n  constructor (message: string = 'The operation was aborted') {\n    super(message)\n    this.name = 'AbortError'\n  }\n}\n\n/**\n * Thrown when a remote Peer ID does not match the expected one\n */\nexport class UnexpectedPeerError extends Error {\n  static name = 'UnexpectedPeerError'\n\n  constructor (message = 'Unexpected Peer') {\n    super(message)\n    this.name = 'UnexpectedPeerError'\n  }\n}\n\n/**\n * Thrown when a crypto exchange fails\n */\nexport class InvalidCryptoExchangeError extends Error {\n  static name = 'InvalidCryptoExchangeError'\n\n  constructor (message = 'Invalid crypto exchange') {\n    super(message)\n    this.name = 'InvalidCryptoExchangeError'\n  }\n}\n\n/**\n * Thrown when invalid parameters are passed to a function or method call\n */\nexport class InvalidParametersError extends Error {\n  static name = 'InvalidParametersError'\n\n  constructor (message = 'Invalid parameters') {\n    super(message)\n    this.name = 'InvalidParametersError'\n  }\n}\n\n/**\n * Thrown when a public key is invalid\n */\nexport class InvalidPublicKeyError extends Error {\n  static name = 'InvalidPublicKeyError'\n\n  constructor (message = 'Invalid public key') {\n    super(message)\n    this.name = 'InvalidPublicKeyError'\n  }\n}\n\n/**\n * Thrown when a private key is invalid\n */\nexport class InvalidPrivateKeyError extends Error {\n  static name = 'InvalidPrivateKeyError'\n\n  constructor (message = 'Invalid private key') {\n    super(message)\n    this.name = 'InvalidPrivateKeyError'\n  }\n}\n\n/**\n * Thrown when a operation is unsupported\n */\nexport class UnsupportedOperationError extends Error {\n  static name = 'UnsupportedOperationError'\n\n  constructor (message = 'Unsupported operation') {\n    super(message)\n    this.name = 'UnsupportedOperationError'\n  }\n}\n\n/**\n * Thrown when a connection is closing\n */\nexport class ConnectionClosingError extends Error {\n  static name = 'ConnectionClosingError'\n\n  constructor (message = 'The connection is closing') {\n    super(message)\n    this.name = 'ConnectionClosingError'\n  }\n}\n\n/**\n * Thrown when a connection is closed\n */\nexport class ConnectionClosedError extends Error {\n  static name = 'ConnectionClosedError'\n\n  constructor (message = 'The connection is closed') {\n    super(message)\n    this.name = 'ConnectionClosedError'\n  }\n}\n\n/**\n * Thrown when a connection fails\n */\nexport class ConnectionFailedError extends Error {\n  static name = 'ConnectionFailedError'\n\n  constructor (message = 'Connection failed') {\n    super(message)\n    this.name = 'ConnectionFailedError'\n  }\n}\n\n/**\n * Thrown when the muxer is closed and an attempt to open a stream occurs\n */\nexport class MuxerClosedError extends Error {\n  static name = 'MuxerClosedError'\n\n  constructor (message = 'The muxer is closed') {\n    super(message)\n    this.name = 'MuxerClosedError'\n  }\n}\n\n/**\n * Thrown when a protocol stream is reset by the remote muxer\n */\nexport class StreamResetError extends Error {\n  static name = 'StreamResetError'\n\n  constructor (message = 'The stream has been reset') {\n    super(message)\n    this.name = 'StreamResetError'\n  }\n}\n\n/**\n * Thrown when a stream is in an invalid state\n */\nexport class StreamStateError extends Error {\n  static name = 'StreamStateError'\n\n  constructor (message = 'The stream is in an invalid state') {\n    super(message)\n    this.name = 'StreamStateError'\n  }\n}\n\n/**\n * Thrown when a value could not be found\n */\nexport class NotFoundError extends Error {\n  static name = 'NotFoundError'\n\n  constructor (message = 'Not found') {\n    super(message)\n    this.name = 'NotFoundError'\n  }\n}\n\n/**\n * Thrown when an invalid peer ID is encountered\n */\nexport class InvalidPeerIdError extends Error {\n  static name = 'InvalidPeerIdError'\n\n  constructor (message = 'Invalid PeerID') {\n    super(message)\n    this.name = 'InvalidPeerIdError'\n  }\n}\n\n/**\n * Thrown when an invalid multiaddr is encountered\n */\nexport class InvalidMultiaddrError extends Error {\n  static name = 'InvalidMultiaddrError'\n\n  constructor (message = 'Invalid multiaddr') {\n    super(message)\n    this.name = 'InvalidMultiaddrError'\n  }\n}\n\n/**\n * Thrown when an invalid CID is encountered\n */\nexport class InvalidCIDError extends Error {\n  static name = 'InvalidCIDError'\n\n  constructor (message = 'Invalid CID') {\n    super(message)\n    this.name = 'InvalidCIDError'\n  }\n}\n\n/**\n * Thrown when an invalid multihash is encountered\n */\nexport class InvalidMultihashError extends Error {\n  static name = 'InvalidMultihashError'\n\n  constructor (message = 'Invalid Multihash') {\n    super(message)\n    this.name = 'InvalidMultihashError'\n  }\n}\n\n/**\n * Thrown when a protocol is not supported\n */\nexport class UnsupportedProtocolError extends Error {\n  static name = 'UnsupportedProtocolError'\n\n  constructor (message = 'Unsupported protocol error') {\n    super(message)\n    this.name = 'UnsupportedProtocolError'\n  }\n}\n\n/**\n * An invalid or malformed message was encountered during a protocol exchange\n */\nexport class InvalidMessageError extends Error {\n  static name = 'InvalidMessageError'\n\n  constructor (message = 'Invalid message') {\n    super(message)\n    this.name = 'InvalidMessageError'\n  }\n}\n\n/**\n * Thrown when a remote peer sends a structurally valid message that does not\n * comply with the protocol\n */\nexport class ProtocolError extends Error {\n  static name = 'ProtocolError'\n\n  constructor (message = 'Protocol error') {\n    super(message)\n    this.name = 'ProtocolError'\n  }\n}\n\n/**\n * Throw when an operation times out\n */\nexport class TimeoutError extends Error {\n  static name = 'TimeoutError'\n\n  constructor (message = 'Timed out') {\n    super(message)\n    this.name = 'TimeoutError'\n  }\n}\n\n/**\n * Thrown when a startable component is interacted with but it has not been\n * started yet\n */\nexport class NotStartedError extends Error {\n  static name = 'NotStartedError'\n\n  constructor (message = 'Not started') {\n    super(message)\n    this.name = 'NotStartedError'\n  }\n}\n\n/**\n * Thrown when a component is started that has already been started\n */\nexport class AlreadyStartedError extends Error {\n  static name = 'AlreadyStartedError'\n\n  constructor (message = 'Already started') {\n    super(message)\n    this.name = 'AlreadyStartedError'\n  }\n}\n\n/**\n * Thrown when dialing an address failed\n */\nexport class DialError extends Error {\n  static name = 'DialError'\n\n  constructor (message = 'Dial error') {\n    super(message)\n    this.name = 'DialError'\n  }\n}\n\n/**\n * Thrown when listening on an address failed\n */\nexport class ListenError extends Error {\n  static name = 'ListenError'\n\n  constructor (message = 'Listen error') {\n    super(message)\n    this.name = 'ListenError'\n  }\n}\n\n/**\n * This error is thrown when a limited connection is encountered, i.e. if the\n * user tried to open a stream on a connection for a protocol that is not\n * configured to run over limited connections.\n */\nexport class LimitedConnectionError extends Error {\n  static name = 'LimitedConnectionError'\n\n  constructor (message = 'Limited connection') {\n    super(message)\n    this.name = 'LimitedConnectionError'\n  }\n}\n\n/**\n * This error is thrown where there are too many inbound protocols streams open\n */\nexport class TooManyInboundProtocolStreamsError extends Error {\n  static name = 'TooManyInboundProtocolStreamsError'\n\n  constructor (message = 'Too many inbound protocol streams') {\n    super(message)\n    this.name = 'TooManyInboundProtocolStreamsError'\n  }\n}\n\n/**\n * This error is thrown where there are too many outbound protocols streams open\n */\nexport class TooManyOutboundProtocolStreamsError extends Error {\n  static name = 'TooManyOutboundProtocolStreamsError'\n\n  constructor (message = 'Too many outbound protocol streams') {\n    super(message)\n    this.name = 'TooManyOutboundProtocolStreamsError'\n  }\n}\n\n/**\n * Thrown when an attempt to operate on an unsupported key was made\n */\nexport class UnsupportedKeyTypeError extends Error {\n  static name = 'UnsupportedKeyTypeError'\n\n  constructor (message = 'Unsupported key type') {\n    super(message)\n    this.name = 'UnsupportedKeyTypeError'\n  }\n}\n\n/**\n * Thrown when an operation has not been implemented\n */\nexport class NotImplementedError extends Error {\n  static name = 'NotImplementedError'\n\n  constructor (message = 'Not implemented') {\n    super(message)\n    this.name = 'NotImplementedError'\n  }\n}\n", "/**\n * Noop for browser compatibility\n */\nexport function setMaxListeners (): void {}\n", "import { setMaxListeners } from './events.js'\n\nexport interface EventCallback<EventType> { (evt: EventType): void }\nexport interface EventObject<EventType> { handleEvent: EventCallback<EventType> }\nexport type EventHandler<EventType> = EventCallback<EventType> | EventObject<EventType>\n\ninterface Listener {\n  once: boolean\n  callback: any\n}\n\n/**\n * Adds types to the EventTarget class. Hopefully this won't be necessary\n * forever.\n *\n * https://github.com/microsoft/TypeScript/issues/28357\n * https://github.com/microsoft/TypeScript/issues/43477\n * https://github.com/microsoft/TypeScript/issues/299\n * etc\n */\nexport interface TypedEventTarget <EventMap extends Record<string, any>> extends EventTarget {\n  addEventListener<K extends keyof EventMap>(type: K, listener: EventHandler<EventMap[K]> | null, options?: boolean | AddEventListenerOptions): void\n\n  listenerCount (type: string): number\n\n  removeEventListener<K extends keyof EventMap>(type: K, listener?: EventHandler<EventMap[K]> | null, options?: boolean | EventListenerOptions): void\n\n  removeEventListener (type: string, listener?: EventHandler<Event>, options?: boolean | EventListenerOptions): void\n\n  safeDispatchEvent<Detail>(type: keyof EventMap, detail?: CustomEventInit<Detail>): boolean\n}\n\n/**\n * An implementation of a typed event target\n */\nexport class TypedEventEmitter<EventMap extends Record<string, any>> extends EventTarget implements TypedEventTarget<EventMap> {\n  readonly #listeners = new Map<any, Listener[]>()\n\n  constructor () {\n    super()\n\n    // silence MaxListenersExceededWarning warning on Node.js, this is a red\n    // herring almost all of the time\n    setMaxListeners(Infinity, this)\n  }\n\n  listenerCount (type: string): number {\n    const listeners = this.#listeners.get(type)\n\n    if (listeners == null) {\n      return 0\n    }\n\n    return listeners.length\n  }\n\n  addEventListener<K extends keyof EventMap>(type: K, listener: EventHandler<EventMap[K]> | null, options?: boolean | AddEventListenerOptions): void\n  addEventListener (type: string, listener: EventHandler<Event>, options?: boolean | AddEventListenerOptions): void {\n    super.addEventListener(type, listener, options)\n\n    let list = this.#listeners.get(type)\n\n    if (list == null) {\n      list = []\n      this.#listeners.set(type, list)\n    }\n\n    list.push({\n      callback: listener,\n      once: (options !== true && options !== false && options?.once) ?? false\n    })\n  }\n\n  removeEventListener<K extends keyof EventMap>(type: K, listener?: EventHandler<EventMap[K]> | null, options?: boolean | EventListenerOptions): void\n  removeEventListener (type: string, listener?: EventHandler<Event>, options?: boolean | EventListenerOptions): void {\n    super.removeEventListener(type.toString(), listener ?? null, options)\n\n    let list = this.#listeners.get(type)\n\n    if (list == null) {\n      return\n    }\n\n    list = list.filter(({ callback }) => callback !== listener)\n    this.#listeners.set(type, list)\n  }\n\n  dispatchEvent (event: Event): boolean {\n    const result = super.dispatchEvent(event)\n\n    let list = this.#listeners.get(event.type)\n\n    if (list == null) {\n      return result\n    }\n\n    list = list.filter(({ once }) => !once)\n    this.#listeners.set(event.type, list)\n\n    return result\n  }\n\n  safeDispatchEvent<Detail>(type: keyof EventMap, detail: CustomEventInit<Detail> = {}): boolean {\n    return this.dispatchEvent(new CustomEvent<Detail>(type as string, detail))\n  }\n}\n", "/**\n * Implemented by components that have a life cycle\n */\nexport interface Startable {\n  /**\n   * If implemented, this method will be invoked before the start method.\n   *\n   * It should not assume any other components have been started.\n   */\n  beforeStart?(): void | Promise<void>\n\n  /**\n   * This method will be invoked to start the component.\n   *\n   * It should not assume that any other components have been started.\n   */\n  start(): void | Promise<void>\n\n  /**\n   * If implemented, this method will be invoked after the start method.\n   *\n   * All other components will have had their start method invoked before this method is called.\n   */\n  afterStart?(): void | Promise<void>\n\n  /**\n   * If implemented, this method will be invoked before the stop method.\n   *\n   * Any other components will still be running when this method is called.\n   */\n  beforeStop?(): void | Promise<void>\n\n  /**\n   * This method will be invoked to stop the component.\n   *\n   * It should not assume any other components are running when it is called.\n   */\n  stop(): void | Promise<void>\n\n  /**\n   * If implemented, this method will be invoked after the stop method.\n   *\n   * All other components will have had their stop method invoked before this method is called.\n   */\n  afterStop?(): void | Promise<void>\n}\n\n/**\n * Returns `true` if the object has type overlap with `Startable`\n */\nexport function isStartable (obj?: any): obj is Startable {\n  return obj != null && typeof obj.start === 'function' && typeof obj.stop === 'function'\n}\n\n/**\n * A function that can be used to start and objects passed to it. This checks\n * that an object is startable before invoking its lifecycle methods so it is\n * safe to pass non-`Startable`s in.\n *\n * @example\n *\n * ```TypeScript\n * import { start } from '@libp2p/interface'\n * import type { Startable } from '@libp2p/interface'\n *\n * const startable: Startable = {\n *   start: () => {},\n *   stop: () => {}\n * }\n *\n * const notStartable = 5\n *\n * await start(\n *   startable,\n *   notStartable\n * )\n * ```\n */\nexport async function start (...objs: any[]): Promise<void> {\n  const startables: Startable[] = []\n\n  for (const obj of objs) {\n    if (isStartable(obj)) {\n      startables.push(obj)\n    }\n  }\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.beforeStart != null) {\n        await s.beforeStart()\n      }\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      await s.start()\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.afterStart != null) {\n        await s.afterStart()\n      }\n    })\n  )\n}\n\n/**\n * A function that can be used to stop and objects passed to it. This checks\n * that an object is startable before invoking its lifecycle methods so it is\n * safe to pass non-`Startable`s in.\n *\n * @example\n *\n * ```TypeScript\n * import { stop } from '@libp2p/interface'\n * import type { Startable } from '@libp2p/interface'\n *\n * const startable: Startable = {\n *   start: () => {},\n *   stop: () => {}\n * }\n *\n * const notStartable = 5\n *\n * await stop(\n *   startable,\n *   notStartable\n * )\n * ```\n */\nexport async function stop (...objs: any[]): Promise<void> {\n  const startables: Startable[] = []\n\n  for (const obj of objs) {\n    if (isStartable(obj)) {\n      startables.push(obj)\n    }\n  }\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.beforeStop != null) {\n        await s.beforeStop()\n      }\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      await s.stop()\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.afterStop != null) {\n        await s.afterStop()\n      }\n    })\n  )\n}\n"],
-  "mappings": "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",
+  "sourcesContent": ["/**\n * @packageDocumentation\n *\n * Exports a `Libp2p` type for modules to use as a type argument.\n *\n * @example\n *\n * ```typescript\n * import type { Libp2p } from '@libp2p/interface'\n *\n * function doSomethingWithLibp2p (node: Libp2p) {\n *   // ...\n * }\n * ```\n */\n\nimport type { Connection, NewStreamOptions, Stream } from './connection.js'\nimport type { ContentRouting } from './content-routing.js'\nimport type { TypedEventTarget } from './event-target.js'\nimport type { Ed25519PublicKey, PublicKey, RSAPublicKey, Secp256k1PublicKey } from './keys.js'\nimport type { Metrics } from './metrics.js'\nimport type { Ed25519PeerId, PeerId, RSAPeerId, Secp256k1PeerId, URLPeerId } from './peer-id.js'\nimport type { PeerInfo } from './peer-info.js'\nimport type { PeerRouting } from './peer-routing.js'\nimport type { Address, Peer, PeerStore } from './peer-store.js'\nimport type { Startable } from './startable.js'\nimport type { StreamHandler, StreamHandlerOptions } from './stream-handler.js'\nimport type { Topology } from './topology.js'\nimport type { Listener, OutboundConnectionUpgradeEvents } from './transport.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { ProgressOptions, ProgressEvent } from 'progress-events'\n\n/**\n * Used by the connection manager to sort addresses into order before dialling\n */\nexport interface AddressSorter {\n  (a: Address, b: Address): -1 | 0 | 1\n}\n\n/**\n * Event detail emitted when peer data changes\n */\nexport interface PeerUpdate {\n  peer: Peer\n  previous?: Peer\n}\n\n/**\n * Peer data signed by the remote Peer's public key\n */\nexport interface SignedPeerRecord {\n  addresses: Multiaddr[]\n  seq: bigint\n}\n\n/**\n * A certificate that can be used to secure connections\n */\nexport interface TLSCertificate {\n  /**\n   * The private key that corresponds to the certificate in PEM format\n   */\n  key: string\n\n  /**\n   * The certificate chain in PEM format\n   */\n  cert: string\n}\n\n/**\n * Data returned from a successful identify response\n */\nexport interface IdentifyResult {\n  /**\n   * The remote Peer's PeerId\n   */\n  peerId: PeerId\n\n  /**\n   * The unsigned addresses they are listening on. Note - any multiaddrs present\n   * in the signed peer record should be preferred to the value here.\n   */\n  listenAddrs: Multiaddr[]\n\n  /**\n   * The protocols the remote peer supports\n   */\n  protocols: string[]\n\n  /**\n   * The remote protocol version\n   */\n  protocolVersion?: string\n\n  /**\n   * The remote agent version\n   */\n  agentVersion?: string\n\n  /**\n   * The public key part of the remote PeerId - this is only useful for older\n   * RSA-based PeerIds, the more modern Ed25519 and secp256k1 types have the\n   * public key embedded in them\n   */\n  publicKey?: Uint8Array\n\n  /**\n   * If set this is the address that the remote peer saw the identify request\n   * originate from\n   */\n  observedAddr?: Multiaddr\n\n  /**\n   * If sent by the remote peer this is the deserialized signed peer record\n   */\n  signedPeerRecord?: SignedPeerRecord\n\n  /**\n   * The connection that the identify protocol ran over\n   */\n  connection: Connection\n}\n\n/**\n * Logger component for libp2p\n */\nexport interface Logger {\n  (formatter: any, ...args: any[]): void\n  error(formatter: any, ...args: any[]): void\n  trace(formatter: any, ...args: any[]): void\n  enabled: boolean\n}\n\n/**\n * Peer logger component for libp2p. This can be used to create loggers that are\n * scoped to individual system components or services.\n *\n * To see logs, run your app with `DEBUG` set as an env var or for browsers, in\n * `localStorage`:\n *\n * ```console\n * $ DEBUG=libp2p* node index.js\n *  libp2p:my-service hello +0ms\n * ```\n */\nexport interface ComponentLogger {\n  /**\n   * Returns a logger for the specified component.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * import { ComponentLogger, Logger } from '@libp2p/interface'\n   *\n   * interface MyServiceComponents {\n   *   logger: ComponentLogger\n   * }\n   *\n   * class MyService {\n   *   private readonly log: Logger\n   *\n   *   constructor (components) {\n   *     this.log = components.logger.forComponent('libp2p:my-service')\n   *\n   *     this.log('hello')\n   *     // logs:\n   *     // libp2p:my-service hello +0ms\n   *   }\n   * }\n   * ```\n   */\n  forComponent(name: string): Logger\n}\n\n/**\n * Once you have a libp2p instance, you can listen to several events it emits,\n * so that you can be notified of relevant network events.\n *\n * Event names are `noun:verb` so the first part is the name of the object\n * being acted on and the second is the action.\n */\nexport interface Libp2pEvents<T extends ServiceMap = ServiceMap> {\n  /**\n   * This event is dispatched when a new network peer is discovered.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:discovery', (event) => {\n   *    const peerInfo = event.detail\n   *    // ...\n   * })\n   * ```\n   */\n  'peer:discovery': CustomEvent<PeerInfo>\n\n  /**\n   * This event will be triggered any time a new peer connects.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:connect', (event) => {\n   *   const peerId = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:connect': CustomEvent<PeerId>\n\n  /**\n   * This event will be triggered any time we are disconnected from another\n   * peer, regardless of the circumstances of that disconnection. If we happen\n   * to have multiple connections to a peer, this event will **only** be\n   * triggered when the last connection is closed.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:disconnect', (event) => {\n   *   const peerId = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:disconnect': CustomEvent<PeerId>\n\n  /**\n   * When a peer tagged with `keep-alive` disconnects, we will make multiple\n   * attempts to reconnect to it with a backoff factor (see the connection\n   * manager settings for details). If these all fail, the `keep-alive` tag will\n   * be removed and this event will be emitted.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:reconnect-failure', (event) => {\n   *   const peerId = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:reconnect-failure': CustomEvent<PeerId>\n\n  /**\n   * This event is dispatched after a remote peer has successfully responded to\n   * the identify protocol. Note that for this to be emitted, both peers must\n   * have an identify service configured.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:identify', (event) => {\n   *   const identifyResult = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:identify': CustomEvent<IdentifyResult>\n\n  /**\n   * This event is dispatched when the peer store data for a peer has been\n   * updated - e.g. their multiaddrs, protocols etc have changed.\n   *\n   * If they were previously known to this node, the old peer data will be\n   * set in the `previous` field.\n   *\n   * This may be in response to the identify protocol running, a manual\n   * update or some other event.\n   */\n  'peer:update': CustomEvent<PeerUpdate>\n\n  /**\n   * This event is dispatched when the current node's peer record changes -\n   * for example a transport started listening on a new address or a new\n   * protocol handler was registered.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('self:peer:update', (event) => {\n   *   const { peer } = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'self:peer:update': CustomEvent<PeerUpdate>\n\n  /**\n   * This event is dispatched when a transport begins listening on a new address\n   */\n  'transport:listening': CustomEvent<Listener>\n\n  /**\n   * This event is dispatched when a transport stops listening on an address\n   */\n  'transport:close': CustomEvent<Listener>\n\n  /**\n   * This event is dispatched when the connection manager has more than the\n   * configured allowable max connections and has closed some connections to\n   * bring the node back under the limit.\n   */\n  'connection:prune': CustomEvent<Connection[]>\n\n  /**\n   * This event notifies listeners when new incoming or outgoing connections\n   * are opened.\n   */\n  'connection:open': CustomEvent<Connection>\n\n  /**\n   * This event notifies listeners when incoming or outgoing connections are\n   * closed.\n   */\n  'connection:close': CustomEvent<Connection>\n\n  /**\n   * This event notifies listeners that a TLS certificate is available for use\n   */\n  'certificate:provision': CustomEvent<TLSCertificate>\n\n  /**\n   * This event notifies listeners that a new TLS certificate is available for\n   * use. Any previous certificate may no longer be valid.\n   */\n  'certificate:renew': CustomEvent<TLSCertificate>\n\n  /**\n   * This event notifies listeners that the node has started\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('start', (event) => {\n   *   console.info(libp2p.isStarted()) // true\n   * })\n   * ```\n   */\n  start: CustomEvent<Libp2p<T>>\n\n  /**\n   * This event notifies listeners that the node has stopped\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('stop', (event) => {\n   *   console.info(libp2p.isStarted()) // false\n   * })\n   * ```\n   */\n  stop: CustomEvent<Libp2p<T>>\n}\n\n/**\n * A map of user defined services available on the libp2p node via the\n * `services` key\n *\n * @example\n *\n * ```TypeScript\n * const node = await createLibp2p({\n *   // ...other options\n *   services: {\n *     myService: myService({\n *       // ...service options\n *     })\n *   }\n * })\n *\n * // invoke methods on the service\n * node.services.myService.anOperation()\n * ```\n */\nexport type ServiceMap = Record<string, unknown>\n\nexport type PendingDialStatus = 'queued' | 'active' | 'error' | 'success'\n\n/**\n * An item in the dial queue\n */\nexport interface PendingDial {\n  /**\n   * A unique identifier for this dial\n   */\n  id: string\n\n  /**\n   * The current status of the dial\n   */\n  status: PendingDialStatus\n\n  /**\n   * If known, this is the peer id that libp2p expects to be dialling\n   */\n  peerId?: PeerId\n\n  /**\n   * The list of multiaddrs that will be dialled. The returned connection will\n   * use the first address that succeeds, all other dials part of this pending\n   * dial will be cancelled.\n   */\n  multiaddrs: Multiaddr[]\n}\n\nexport type Libp2pStatus = 'starting' | 'started' | 'stopping' | 'stopped'\n\nexport interface IsDialableOptions extends AbortOptions {\n  /**\n   * If the dial attempt would open a protocol, and the multiaddr being dialed\n   * is a circuit relay address, passing true here would cause the test to fail\n   * because that protocol would not be allowed to run over a data/time limited\n   * connection.\n   */\n  runOnLimitedConnection?: boolean\n}\n\nexport type TransportManagerDialProgressEvents =\n  ProgressEvent<'transport-manager:selected-transport', string>\n\nexport type OpenConnectionProgressEvents =\n  TransportManagerDialProgressEvents |\n  ProgressEvent<'dial-queue:already-connected'> |\n  ProgressEvent<'dial-queue:already-in-dial-queue'> |\n  ProgressEvent<'dial-queue:add-to-dial-queue'> |\n  ProgressEvent<'dial-queue:start-dial'> |\n  ProgressEvent<'dial-queue:calculated-addresses', Address[]> |\n  OutboundConnectionUpgradeEvents\n\nexport interface DialOptions extends AbortOptions, ProgressOptions {\n  /**\n   * If true, open a new connection to the remote even if one already exists\n   */\n  force?: boolean\n}\n\nexport interface DialProtocolOptions extends NewStreamOptions {\n\n}\n\n/**\n * Libp2p nodes implement this interface.\n */\nexport interface Libp2p<T extends ServiceMap = ServiceMap> extends Startable, TypedEventTarget<Libp2pEvents<T>> {\n  /**\n   * The PeerId is a unique identifier for a node on the network.\n   *\n   * It is the hash of an RSA public key or, for Ed25519 or secp256k1 keys,\n   * the key itself.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * console.info(libp2p.peerId)\n   * // PeerId(12D3Foo...)\n   * ````\n   */\n  peerId: PeerId\n\n  /**\n   * The peer store holds information we know about other peers on the network.\n   * - multiaddrs, supported protocols, etc.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peer = await libp2p.peerStore.get(peerId)\n   * console.info(peer)\n   * // { id: PeerId(12D3Foo...), addresses: [] ... }\n   * ```\n   */\n  peerStore: PeerStore\n\n  /**\n   * The peer routing subsystem allows the user to find peers on the network\n   * or to find peers close to binary keys.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peerInfo = await libp2p.peerRouting.findPeer(peerId)\n   * console.info(peerInfo)\n   * // { id: PeerId(12D3Foo...), multiaddrs: [] ... }\n   * ```\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for await (const peerInfo of libp2p.peerRouting.getClosestPeers(key)) {\n   *   console.info(peerInfo)\n   *   // { id: PeerId(12D3Foo...), multiaddrs: [] ... }\n   * }\n   * ```\n   */\n  peerRouting: PeerRouting\n\n  /**\n   * The content routing subsystem allows the user to find providers for content,\n   * let the network know they are providers for content, and get/put values to\n   * the DHT.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for await (const peerInfo of libp2p.contentRouting.findProviders(cid)) {\n   *   console.info(peerInfo)\n   *   // { id: PeerId(12D3Foo...), multiaddrs: [] ... }\n   * }\n   * ```\n   */\n  contentRouting: ContentRouting\n\n  /**\n   * The metrics subsystem allows recording values to assess the health/performance\n   * of the running node.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const metric = libp2p.metrics.registerMetric({\n   *   'my-metric'\n   * })\n   *\n   * // later\n   * metric.update(5)\n   * ```\n   */\n  metrics?: Metrics\n\n  /**\n   * The logger used by this libp2p node\n   */\n  logger: ComponentLogger\n\n  /**\n   * The current status of the libp2p node\n   */\n  status: Libp2pStatus\n\n  /**\n   * Get a deduplicated list of peer advertising multiaddrs by concatenating\n   * the listen addresses used by transports with any configured\n   * announce addresses as well as observed addresses reported by peers.\n   *\n   * If Announce addrs are specified, configured listen addresses will be\n   * ignored though observed addresses will still be included.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const listenMa = libp2p.getMultiaddrs()\n   * // [ <Multiaddr 047f00000106f9ba - /ip4/127.0.0.1/tcp/63930> ]\n   * ```\n   */\n  getMultiaddrs(): Multiaddr[]\n\n  /**\n   * Returns a list of supported protocols\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const protocols = libp2p.getProtocols()\n   * // [ '/ipfs/ping/1.0.0', '/ipfs/id/1.0.0' ]\n   * ```\n   */\n  getProtocols(): string[]\n\n  /**\n   * Return a list of all connections this node has open, optionally filtering\n   * by a PeerId\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for (const connection of libp2p.getConnections()) {\n   *   console.log(peerId, connection.remoteAddr.toString())\n   *   // Logs the PeerId string and the observed remote multiaddr of each Connection\n   * }\n   * ```\n   */\n  getConnections(peerId?: PeerId): Connection[]\n\n  /**\n   * Return the list of dials currently in progress or queued to start\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for (const pendingDial of libp2p.getDialQueue()) {\n   *   console.log(pendingDial)\n   * }\n   * ```\n   */\n  getDialQueue(): PendingDial[]\n\n  /**\n   * Return a list of all peers we currently have a connection open to\n   */\n  getPeers(): PeerId[]\n\n  /**\n   * Dials to the provided peer. If successful, the known metadata of the\n   * peer will be added to the nodes `peerStore`.\n   *\n   * If a PeerId is passed as the first argument, the peer will need to have known multiaddrs for it in the PeerStore.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const conn = await libp2p.dial(remotePeerId)\n   *\n   * // create a new stream within the connection\n   * const stream = await conn.newStream(['/echo/1.1.0', '/echo/1.0.0'])\n   *\n   * // protocol negotiated: 'echo/1.0.0' means that the other party only supports the older version\n   *\n   * // ...\n   * await conn.close()\n   * ```\n   */\n  dial(peer: PeerId | Multiaddr | Multiaddr[], options?: DialOptions): Promise<Connection>\n\n  /**\n   * Dials to the provided peer and tries to handshake with the given protocols in order.\n   * If successful, the known metadata of the peer will be added to the nodes `peerStore`,\n   * and the `MuxedStream` will be returned together with the successful negotiated protocol.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * import { pipe } from 'it-pipe'\n   *\n   * const { stream, protocol } = await libp2p.dialProtocol(remotePeerId, protocols)\n   *\n   * // Use this new stream like any other duplex stream\n   * pipe([1, 2, 3], stream, consume)\n   * ```\n   */\n  dialProtocol(peer: PeerId | Multiaddr | Multiaddr[], protocols: string | string[], options?: DialProtocolOptions): Promise<Stream>\n\n  /**\n   * Attempts to gracefully close an open connection to the given peer. If the\n   * connection is not closed in the grace period, it will be forcefully closed.\n   *\n   * An AbortSignal can optionally be passed to control when the connection is\n   * forcefully closed.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * await libp2p.hangUp(remotePeerId)\n   * ```\n   */\n  hangUp(peer: PeerId | Multiaddr, options?: AbortOptions): Promise<void>\n\n  /**\n   * Sets up [multistream-select routing](https://github.com/multiformats/multistream-select) of protocols to their application handlers. Whenever a stream is opened on one of the provided protocols, the handler will be called. `handle` must be called in order to register a handler and support for a given protocol. This also informs other peers of the protocols you support.\n   *\n   * `libp2p.handle(protocols, handler, options)`\n   *\n   * In the event of a new handler for the same protocol being added and error\n   * will be thrown. Pass `force: true` to override this.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const handler = ({ connection, stream, protocol }) => {\n   *   // use stream or connection according to the needs\n   * }\n   *\n   * libp2p.handle('/echo/1.0.0', handler, {\n   *   maxInboundStreams: 5,\n   *   maxOutboundStreams: 5\n   * })\n   * ```\n   */\n  handle(protocol: string | string[], handler: StreamHandler, options?: StreamHandlerOptions): Promise<void>\n\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.unhandle(['/echo/1.0.0'])\n   * ```\n   */\n  unhandle(protocols: string[] | string): Promise<void>\n\n  /**\n   * Register a topology to be informed when peers are encountered that\n   * support the specified protocol\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const id = await libp2p.register('/echo/1.0.0', {\n   *   onConnect: (peer, connection) => {\n   *     // handle connect\n   *   },\n   *   onDisconnect: (peer, connection) => {\n   *     // handle disconnect\n   *   }\n   * })\n   * ```\n   */\n  register(protocol: string, topology: Topology): Promise<string>\n\n  /**\n   * Unregister topology to no longer be informed when peers connect or\n   * disconnect.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const id = await libp2p.register(...)\n   *\n   * libp2p.unregister(id)\n   * ```\n   */\n  unregister(id: string): void\n\n  /**\n   * Returns the public key for the passed PeerId. If the PeerId is of the 'RSA'\n   * type this may mean searching the routing if the peer's key is not present\n   * in the peer store.\n   */\n  getPublicKey(peer: Ed25519PeerId, options?: AbortOptions): Promise<Ed25519PublicKey>\n  getPublicKey(peer: Secp256k1PeerId, options?: AbortOptions): Promise<Secp256k1PublicKey>\n  getPublicKey(peer: RSAPeerId, options?: AbortOptions): Promise<RSAPublicKey>\n  getPublicKey(peer: URLPeerId, options?: AbortOptions): Promise<never>\n  getPublicKey(peer: PeerId, options?: AbortOptions): Promise<PublicKey>\n\n  /**\n   * Given the current node configuration, returns a promise of `true` or\n   * `false` if the node would attempt to dial the passed multiaddr.\n   *\n   * This means a relevant transport is configured, and the connection gater\n   * would not block the dial attempt.\n   *\n   * This may involve resolving DNS addresses so you should pass an AbortSignal.\n   */\n  isDialable(multiaddr: Multiaddr | Multiaddr[], options?: IsDialableOptions): Promise<boolean>\n\n  /**\n   * A set of user defined services\n   */\n  services: T\n}\n\n/**\n * Metadata about the current node\n */\nexport interface NodeInfo {\n  /**\n   * The implementation name\n   */\n  name: string\n\n  /**\n   * The implementation version\n   */\n  version: string\n\n  /**\n   * A string that contains information about the implementation and runtime\n   */\n  userAgent: string\n}\n\n/**\n * An object that contains an AbortSignal as\n * the optional `signal` property.\n *\n * @example\n *\n * ```TypeScript\n * const controller = new AbortController()\n *\n * aLongRunningOperation({\n *   signal: controller.signal\n * })\n *\n * // later\n *\n * controller.abort()\n */\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\n/**\n * An object that contains a Logger as the `log` property.\n */\nexport interface LoggerOptions {\n  log: Logger\n}\n\n/**\n * An object that includes a trace object that is passed onwards.\n *\n * This is used by metrics method tracing to link function calls together.\n */\nexport interface TraceOptions {\n  trace?: any\n}\n\n/**\n * A signal that needs to be cleared when no longer in use\n */\nexport interface ClearableSignal extends AbortSignal {\n  clear(): void\n}\n\n/**\n * When a routing operation involves reading values, these options allow\n * controlling where the values are read from. By default libp2p will check\n * local caches but may not use the network if a valid local value is found,\n * these options allow tuning that behavior.\n */\nexport interface RoutingOptions extends AbortOptions, ProgressOptions, TraceOptions {\n  /**\n   * Pass `false` to not use the network\n   *\n   * @default true\n   */\n  useNetwork?: boolean\n\n  /**\n   * Pass `false` to not use cached values\n   *\n   * @default true\n   */\n  useCache?: boolean\n}\n\n/**\n * This symbol is used by libp2p services to define the capabilities they can\n * provide to other libp2p services.\n *\n * The service should define a property with this symbol as the key and the\n * value should be a string array of provided capabilities.\n */\nexport const serviceCapabilities = Symbol.for('@libp2p/service-capabilities')\n\n/**\n * This symbol is used by libp2p services to define the capabilities they\n * require from other libp2p services.\n *\n * The service should define a property with this symbol as the key and the\n * value should be a string array of required capabilities.\n */\nexport const serviceDependencies = Symbol.for('@libp2p/service-dependencies')\n\nexport * from './connection.js'\nexport * from './connection-encrypter.js'\nexport * from './connection-gater.js'\nexport * from './content-routing.js'\nexport * from './keys.js'\nexport * from './metrics.js'\nexport * from './peer-discovery.js'\nexport * from './peer-id.js'\nexport * from './peer-info.js'\nexport * from './peer-routing.js'\nexport * from './peer-store.js'\nexport * from './pubsub.js'\nexport * from './record.js'\nexport * from './stream-handler.js'\nexport * from './stream-muxer.js'\nexport * from './topology.js'\nexport * from './transport.js'\nexport * from './errors.js'\nexport * from './event-target.js'\nexport * from './events.js'\nexport * from './startable.js'\n", "import type { AbortOptions, Logger } from './index.js'\nimport type { PeerId } from './peer-id.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Duplex, Source } from 'it-stream-types'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface ConnectionTimeline {\n  /**\n   * When the connection was opened\n   */\n  open: number\n\n  /**\n   * When the MultiaddrConnection was upgraded to a Connection - e.g. the type\n   * of connection encryption and multiplexing was negotiated.\n   */\n  upgraded?: number\n\n  /**\n   * When the connection was closed.\n   */\n  close?: number\n}\n\n/**\n * Outbound connections are opened by the local node, inbound streams are opened by the remote\n */\nexport type Direction = 'inbound' | 'outbound'\n\nexport interface StreamTimeline {\n  /**\n   * A timestamp of when the stream was opened\n   */\n  open: number\n\n  /**\n   * A timestamp of when the stream was closed for both reading and writing\n   */\n  close?: number\n\n  /**\n   * A timestamp of when the stream was closed for reading\n   */\n  closeRead?: number\n\n  /**\n   * A timestamp of when the stream was closed for writing\n   */\n  closeWrite?: number\n\n  /**\n   * A timestamp of when the stream was reset\n   */\n  reset?: number\n\n  /**\n   * A timestamp of when the stream was aborted\n   */\n  abort?: number\n}\n\n/**\n * The states a stream can be in\n */\nexport type StreamStatus = 'open' | 'closing' | 'closed' | 'aborted' | 'reset'\n\n/**\n * The states the readable end of a stream can be in\n *\n * ready - the readable end is ready for reading\n * closing - the readable end is closing\n * closed - the readable end has closed\n */\nexport type ReadStatus = 'ready' | 'closing' | 'closed'\n\n/**\n * The states the writable end of a stream can be in\n *\n * ready - the writable end is ready for writing\n * writing - the writable end is in the process of being written to\n * done - the source passed to the `.sink` function yielded all values without error\n * closing - the writable end is closing\n * closed - the writable end has closed\n */\nexport type WriteStatus = 'ready' | 'writing' | 'done' | 'closing' | 'closed'\n\n/**\n * A Stream is a data channel between two peers that\n * can be written to and read from at both ends.\n *\n * It may be encrypted and multiplexed depending on the\n * configuration of the nodes.\n */\nexport interface Stream extends Duplex<AsyncGenerator<Uint8ArrayList>, Source<Uint8ArrayList | Uint8Array>, Promise<void>> {\n  /**\n   * Closes the stream for **reading** *and* **writing**.\n   *\n   * Any buffered data in the source can still be consumed and the stream will end normally.\n   *\n   * This will cause a `CLOSE` message to be sent to the remote, *unless* the sink has already ended.\n   *\n   * The sink and the source will return normally.\n   */\n  close(options?: AbortOptions): Promise<void>\n\n  /**\n   * Closes the stream for **reading**. If iterating over the source of this stream in a `for await of` loop, it will return (exit the loop) after any buffered data has been consumed.\n   *\n   * This function is called automatically by the muxer when it receives a `CLOSE` message from the remote.\n   *\n   * The source will return normally, the sink will continue to consume.\n   */\n  closeRead(options?: AbortOptions): Promise<void>\n\n  /**\n   * Closes the stream for **writing**. If iterating over the source of this stream in a `for await of` loop, it will return (exit the loop) after any buffered data has been consumed.\n   *\n   * The source will return normally, the sink will continue to consume.\n   */\n  closeWrite(options?: AbortOptions): Promise<void>\n\n  /**\n   * Closes the stream for **reading** *and* **writing**. This should be called when a *local error* has occurred.\n   *\n   * Note, if called without an error any buffered data in the source can still be consumed and the stream will end normally.\n   *\n   * This will cause a `RESET` message to be sent to the remote, *unless* the sink has already ended.\n   *\n   * The sink will return and the source will throw.\n   */\n  abort(err: Error): void\n\n  /**\n   * Unique identifier for a stream. Identifiers are not unique across muxers.\n   */\n  id: string\n\n  /**\n   * Outbound streams are opened by the local node, inbound streams are opened by the remote\n   */\n  direction: Direction\n\n  /**\n   * Lifecycle times for the stream\n   */\n  timeline: StreamTimeline\n\n  /**\n   * The protocol negotiated for this stream\n   */\n  protocol?: string\n\n  /**\n   * User defined stream metadata\n   */\n  metadata: Record<string, any>\n\n  /**\n   * The current status of the stream\n   */\n  status: StreamStatus\n\n  /**\n   * The current status of the readable end of the stream\n   */\n  readStatus: ReadStatus\n\n  /**\n   * The current status of the writable end of the stream\n   */\n  writeStatus: WriteStatus\n\n  /**\n   * The stream logger\n   */\n  log: Logger\n}\n\nexport interface NewStreamOptions extends AbortOptions {\n  /**\n   * If specified, and no handler has been registered with the registrar for the\n   * successfully negotiated protocol, use this as the max outbound stream limit\n   * for the protocol\n   */\n  maxOutboundStreams?: number\n\n  /**\n   * Opt-in to running over a limited connection - one that has restrictions\n   * on the amount of data that may be transferred or how long it may be open for.\n   *\n   * These limits are typically enforced by a relay server, if the protocol\n   * will be transferring a lot of data or the stream will be open for a long time\n   * consider upgrading to a direct connection before opening the stream.\n   *\n   * @default false\n   */\n  runOnLimitedConnection?: boolean\n\n  /**\n   * By default when negotiating a protocol the dialer writes then protocol name\n   * then reads the response.\n   *\n   * When a only a single protocol is being negotiated on an outbound stream,\n   * and the stream is written to before being read from, we can optimistically\n   * write the protocol name and the first chunk of data together in the first\n   * message.\n   *\n   * Reading and handling the protocol response is done asynchronously, which\n   * means we can skip a round trip on writing to newly opened streams which\n   * significantly reduces the time-to-first-byte on a stream.\n   *\n   * The side-effect of this is that the underlying stream won't negotiate the\n   * protocol until either data is written to or read from the stream so it will\n   * not be opened on the remote until this is done.\n   *\n   * Pass `false` here to optimistically write the protocol name and first chunk\n   * of data in the first message.\n   *\n   * If multiple protocols are being negotiated, negotiation is always completed\n   * in full before the stream is returned so this option has no effect.\n   *\n   * @default true\n   */\n  negotiateFully?: boolean\n}\n\nexport type ConnectionStatus = 'open' | 'closing' | 'closed'\n\n/**\n * Connection limits are present on connections that are only allowed to\n * transfer a certain amount of bytes or be open for a certain number\n * of seconds.\n *\n * These limits are applied by Circuit Relay v2 servers, for example and\n * the connection will normally be closed abruptly if the limits are\n * exceeded.\n */\nexport interface ConnectionLimits {\n  /**\n   * If present this is the number of bytes remaining that may be\n   * transferred over this connection\n   */\n  bytes?: bigint\n\n  /**\n   * If present this is the number of seconds that this connection will\n   * remain open for\n   */\n  seconds?: number\n}\n\n/**\n * A Connection is a high-level representation of a connection\n * to a remote peer that may have been secured by encryption and\n * multiplexed, depending on the configuration of the nodes\n * between which the connection is made.\n */\nexport interface Connection {\n  /**\n   * The unique identifier for this connection\n   */\n  id: string\n\n  /**\n   * The address of the remote end of the connection\n   */\n  remoteAddr: Multiaddr\n\n  /**\n   * The id of the peer at the remote end of the connection\n   */\n  remotePeer: PeerId\n\n  /**\n   * A list of tags applied to this connection\n   */\n  tags: string[]\n\n  /**\n   * A list of open streams on this connection\n   */\n  streams: Stream[]\n\n  /**\n   * Outbound connections are opened by the local node, inbound streams are opened by the remote\n   */\n  direction: Direction\n\n  /**\n   * Lifecycle times for the connection\n   */\n  timeline: ConnectionTimeline\n\n  /**\n   * The multiplexer negotiated for this connection\n   */\n  multiplexer?: string\n\n  /**\n   * The encryption protocol negotiated for this connection\n   */\n  encryption?: string\n\n  /**\n   * The current status of the connection\n   */\n  status: ConnectionStatus\n\n  /**\n   * If present, this connection has limits applied to it, perhaps by an\n   * intermediate relay. Once the limits have been reached the connection will\n   * be closed by the relay.\n   */\n  limits?: ConnectionLimits\n\n  /**\n   * The time in milliseconds it takes to make a round trip to the remote peer.\n   *\n   * This is updated periodically by the connection monitor.\n   */\n  rtt?: number\n\n  /**\n   * Create a new stream on this connection and negotiate one of the passed protocols\n   */\n  newStream(protocols: string | string[], options?: NewStreamOptions): Promise<Stream>\n\n  /**\n   * Gracefully close the connection. All queued data will be written to the\n   * underlying transport.\n   */\n  close(options?: AbortOptions): Promise<void>\n\n  /**\n   * Immediately close the connection, any queued data will be discarded\n   */\n  abort(err: Error): void\n\n  /**\n   * The connection logger\n   */\n  log: Logger\n}\n\nexport const connectionSymbol = Symbol.for('@libp2p/connection')\n\nexport function isConnection (other: any): other is Connection {\n  return other != null && Boolean(other[connectionSymbol])\n}\n\nexport interface ConnectionProtector {\n  /**\n   * Takes a given Connection and creates a private encryption stream\n   * between its two peers from the PSK the Protector instance was\n   * created with.\n   */\n  protect(connection: MultiaddrConnection, options?: AbortOptions): Promise<MultiaddrConnection>\n}\n\nexport interface MultiaddrConnectionTimeline {\n  /**\n   * When the connection was opened\n   */\n  open: number\n\n  /**\n   * When the MultiaddrConnection was upgraded to a Connection - the type of\n   * connection encryption and multiplexing was negotiated.\n   */\n  upgraded?: number\n\n  /**\n   * When the connection was closed.\n   */\n  close?: number\n}\n\n/**\n * A MultiaddrConnection is returned by transports after dialing\n * a peer. It is a low-level primitive and is the raw connection\n * without encryption or stream multiplexing.\n */\nexport interface MultiaddrConnection extends Duplex<AsyncGenerator<Uint8Array | Uint8ArrayList>> {\n  /**\n   * Gracefully close the connection. All queued data will be written to the\n   * underlying transport.\n   */\n  close(options?: AbortOptions): Promise<void>\n\n  /**\n   * Immediately close the connection, any queued data will be discarded\n   */\n  abort(err: Error): void\n\n  /**\n   * The address of the remote end of the connection\n   */\n  remoteAddr: Multiaddr\n\n  /**\n   * When connection life cycle events occurred\n   */\n  timeline: MultiaddrConnectionTimeline\n\n  /**\n   * The multiaddr connection logger\n   */\n  log: Logger\n}\n", "import type { RoutingOptions } from './index.js'\nimport type { PeerInfo } from './peer-info.js'\nimport type { CID } from 'multiformats/cid'\n\n/**\n * Any object that implements this Symbol as a property should return a\n * Partial<ContentRouting> instance as the property value, similar to how\n * `Symbol.Iterable` can be used to return an `Iterable` from an `Iterator`.\n *\n * @example\n *\n * ```TypeScript\n * import { contentRoutingSymbol, ContentRouting } from '@libp2p/content-routing'\n *\n * class MyContentRouter implements ContentRouting {\n *   get [contentRoutingSymbol] () {\n *     return this\n *   }\n *\n *   // ...other methods\n * }\n * ```\n */\nexport const contentRoutingSymbol = Symbol.for('@libp2p/content-routing')\n\n/**\n * Implementers of this interface can provide a ContentRouting implementation to\n * interested callers.\n */\nexport interface ContentRoutingProvider {\n  [contentRoutingSymbol]: Partial<ContentRouting>\n}\n\nexport interface ContentRouting {\n  /**\n   * The implementation of this method should ensure that network peers know the\n   * caller can provide content that corresponds to the passed CID.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // ...\n   * await contentRouting.provide(cid)\n   * ```\n   */\n  provide(cid: CID, options?: RoutingOptions): Promise<void>\n\n  /**\n   * If network peers need to be periodically reminded that the caller can\n   * provide content corresponding to the passed CID, call this function to no\n   * longer remind them.\n   */\n  cancelReprovide (key: CID, options?: RoutingOptions): Promise<void>\n\n  /**\n   * Find the providers of the passed CID.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // Iterate over the providers found for the given cid\n   * for await (const provider of contentRouting.findProviders(cid)) {\n   *  console.log(provider.id, provider.multiaddrs)\n   * }\n   * ```\n   */\n  findProviders(cid: CID, options?: RoutingOptions): AsyncIterable<PeerInfo>\n\n  /**\n   * Puts a value corresponding to the passed key in a way that can later be\n   * retrieved by another network peer using the get method.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // ...\n   * const key = '/key'\n   * const value = uint8ArrayFromString('oh hello there')\n   *\n   * await contentRouting.put(key, value)\n   * ```\n   */\n  put(key: Uint8Array, value: Uint8Array, options?: RoutingOptions): Promise<void>\n\n  /**\n   * Retrieves a value from the network corresponding to the passed key.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // ...\n   *\n   * const key = '/key'\n   * const value = await contentRouting.get(key)\n   * ```\n   */\n  get(key: Uint8Array, options?: RoutingOptions): Promise<Uint8Array>\n}\n", "import type { CID } from 'multiformats/cid'\nimport type { MultihashDigest } from 'multiformats/hashes/interface'\nimport type { Uint8ArrayList } from 'uint8arraylist'\nimport type { AbortOptions } from './index.ts'\n\nexport type KeyType = 'RSA' | 'Ed25519' | 'secp256k1' | 'ECDSA'\n\nexport interface RSAPublicKey {\n  /**\n   * The type of this key\n   */\n  readonly type: 'RSA'\n\n  /**\n   * PKIX in ASN1 DER format\n   */\n  readonly raw: Uint8Array\n\n  /**\n   * The public key as a JSON web key\n   */\n  readonly jwk: JsonWebKey\n\n  /**\n   * Returns `true` if the passed object matches this key\n   */\n  equals(key?: any): boolean\n\n  /**\n   * Returns this public key as a Multihash digest.\n   *\n   * It contains a sha256 hash of the protobuf version of the public key.\n   */\n  toMultihash(): MultihashDigest<0x12>\n\n  /**\n   * Return this public key as a CID encoded with the `libp2p-key` codec\n   *\n   * The digest contains a sha256 hash of the protobuf version of the public\n   * key.\n   */\n  toCID(): CID<unknown, 0x72, 0x12, 1>\n\n  /**\n   * Verify the passed data was signed by the private key corresponding to this\n   * public key\n   */\n  verify(data: Uint8Array | Uint8ArrayList, sig: Uint8Array, options?: AbortOptions): boolean | Promise<boolean>\n\n  /**\n   * Returns this key as a multihash with base58btc encoding\n   */\n  toString(): string\n}\n\nexport interface Ed25519PublicKey {\n  /**\n   * The type of this key\n   */\n  readonly type: 'Ed25519'\n\n  /**\n   * The raw public key bytes\n   */\n  readonly raw: Uint8Array\n\n  /**\n   * Returns `true` if the passed object matches this key\n   */\n  equals(key?: any): boolean\n\n  /**\n   * Returns this public key as an identity hash containing the protobuf wrapped\n   * public key\n   */\n  toMultihash(): MultihashDigest<0x0>\n\n  /**\n   * Return this public key as a CID encoded with the `libp2p-key` codec\n   *\n   * The digest contains an identity hash containing the protobuf wrapped\n   * version of the public key.\n   */\n  toCID(): CID<unknown, 0x72, 0x0, 1>\n\n  /**\n   * Verify the passed data was signed by the private key corresponding to this\n   * public key\n   */\n  verify(data: Uint8Array | Uint8ArrayList, sig: Uint8Array, options?: AbortOptions): boolean | Promise<boolean>\n\n  /**\n   * Returns this key as a multihash with base58btc encoding\n   */\n  toString(): string\n}\n\nexport interface Secp256k1PublicKey {\n  /**\n   * The type of this key\n   */\n  readonly type: 'secp256k1'\n\n  /**\n   * The raw public key bytes\n   */\n  readonly raw: Uint8Array\n\n  /**\n   * Returns `true` if the passed object matches this key\n   */\n  equals(key?: any): boolean\n\n  /**\n   * Returns this public key as an identity hash containing the protobuf wrapped\n   * public key\n   */\n  toMultihash(): MultihashDigest<0x0>\n\n  /**\n   * Return this public key as a CID encoded with the `libp2p-key` codec\n   *\n   * The digest contains an identity hash containing the protobuf wrapped\n   * version of the public key.\n   */\n  toCID(): CID<unknown, 0x72, 0x0, 1>\n\n  /**\n   * Verify the passed data was signed by the private key corresponding to this\n   * public key\n   */\n  verify(data: Uint8Array | Uint8ArrayList, sig: Uint8Array, options?: AbortOptions): boolean | Promise<boolean>\n\n  /**\n   * Returns this key as a multihash with base58btc encoding\n   */\n  toString(): string\n}\n\nexport interface ECDSAPublicKey {\n  /**\n   * The type of this key\n   */\n  readonly type: 'ECDSA'\n\n  /**\n   * The public key as a DER-encoded PKIMessage\n   */\n  readonly raw: Uint8Array\n\n  /**\n   * The public key as a JSON web key\n   */\n  readonly jwk: JsonWebKey\n\n  /**\n   * Returns `true` if the passed object matches this key\n   */\n  equals(key?: any): boolean\n\n  /**\n   * Returns this public key as an identity hash containing the protobuf wrapped\n   * public key\n   */\n  toMultihash(): MultihashDigest<0x0>\n\n  /**\n   * Return this public key as a CID encoded with the `libp2p-key` codec\n   *\n   * The digest contains an identity hash containing the protobuf wrapped\n   * version of the public key.\n   */\n  toCID(): CID<unknown, 0x72, 0x0, 1>\n\n  /**\n   * Verify the passed data was signed by the private key corresponding to this\n   * public key\n   */\n  verify(data: Uint8Array | Uint8ArrayList, sig: Uint8Array, options?: AbortOptions): boolean | Promise<boolean>\n\n  /**\n   * Returns this key as a multihash with base58btc encoding\n   */\n  toString(): string\n}\n\nexport type PublicKey = RSAPublicKey | Ed25519PublicKey | Secp256k1PublicKey | ECDSAPublicKey\n\n/**\n * Returns true if the passed argument has type overlap with the `PublicKey`\n * interface. Can be used to disambiguate object types.\n */\nexport function isPublicKey (key?: any): key is PublicKey {\n  if (key == null) {\n    return false\n  }\n\n  return (key.type === 'RSA' || key.type === 'Ed25519' || key.type === 'secp256k1' || key.type === 'ECDSA') &&\n    key.raw instanceof Uint8Array &&\n    typeof key.equals === 'function' &&\n    typeof key.toMultihash === 'function' &&\n    typeof key.toCID === 'function' &&\n    typeof key.verify === 'function'\n}\n\n/**\n * Generic private key interface\n */\nexport interface RSAPrivateKey {\n  /**\n   * The type of this key\n   */\n  readonly type: 'RSA'\n\n  /**\n   * The public key that corresponds to this private key\n   */\n  readonly publicKey: RSAPublicKey\n\n  /**\n   * PKIX in ASN1 DER format\n   */\n  readonly raw: Uint8Array\n\n  /**\n   * The private key as a JSON web key\n   */\n  readonly jwk: JsonWebKey\n\n  /**\n   * Returns `true` if the passed object matches this key\n   */\n  equals(key?: any): boolean\n\n  /**\n   * Sign the passed data with this private key and return the signature for\n   * later verification\n   */\n  sign(data: Uint8Array | Uint8ArrayList, options?: AbortOptions): Uint8Array | Promise<Uint8Array>\n}\n\nexport interface Ed25519PrivateKey {\n  /**\n   * The type of this key\n   */\n  readonly type: 'Ed25519'\n\n  /**\n   * The public key that corresponds to this private key\n   */\n  readonly publicKey: Ed25519PublicKey\n\n  /**\n   * The raw private key bytes\n   */\n  readonly raw: Uint8Array\n\n  /**\n   * Returns `true` if the passed object matches this key\n   */\n  equals(key?: any): boolean\n\n  /**\n   * Sign the passed data with this private key and return the signature for\n   * later verification\n   */\n  sign(data: Uint8Array | Uint8ArrayList, options?: AbortOptions): Uint8Array | Promise<Uint8Array>\n}\n\nexport interface Secp256k1PrivateKey {\n  /**\n   * The type of this key\n   */\n  readonly type: 'secp256k1'\n\n  /**\n   * The public key that corresponds to this private key\n   */\n  readonly publicKey: Secp256k1PublicKey\n\n  /**\n   * The raw private key bytes\n   */\n  readonly raw: Uint8Array\n\n  /**\n   * Returns `true` if the passed object matches this key\n   */\n  equals(key?: any): boolean\n\n  /**\n   * Sign the passed data with this private key and return the signature for\n   * later verification\n   */\n  sign(data: Uint8Array | Uint8ArrayList, options?: AbortOptions): Uint8Array | Promise<Uint8Array>\n}\n\nexport interface ECDSAPrivateKey {\n  /**\n   * The type of this key\n   */\n  readonly type: 'ECDSA'\n\n  /**\n   * The public key that corresponds to this private key\n   */\n  readonly publicKey: ECDSAPublicKey\n\n  /**\n   * The private key as a DER-encoded PKIMessage\n   */\n  readonly raw: Uint8Array\n\n  /**\n   * The private key as a JSON web key\n   */\n  readonly jwk: JsonWebKey\n\n  /**\n   * Returns `true` if the passed object matches this key\n   */\n  equals(key?: any): boolean\n\n  /**\n   * Sign the passed data with this private key and return the signature for\n   * later verification\n   */\n  sign(data: Uint8Array | Uint8ArrayList, options?: AbortOptions): Uint8Array | Promise<Uint8Array>\n}\n\nexport type PrivateKey = RSAPrivateKey | Ed25519PrivateKey | Secp256k1PrivateKey | ECDSAPrivateKey\n\n/**\n * Returns true if the passed argument has type overlap with the `PrivateKey`\n * interface. Can be used to disambiguate object types.\n */\nexport function isPrivateKey (key?: any): key is PrivateKey {\n  if (key == null) {\n    return false\n  }\n\n  return (key.type === 'RSA' || key.type === 'Ed25519' || key.type === 'secp256k1' || key.type === 'ECDSA') &&\n    isPublicKey(key.publicKey) &&\n    key.raw instanceof Uint8Array &&\n    typeof key.equals === 'function' &&\n    typeof key.sign === 'function'\n}\n", "import type { TypedEventTarget } from './event-target.js'\nimport type { PeerInfo } from './peer-info.js'\n\n/**\n * Any object that implements this Symbol as a property should return a\n * PeerDiscovery instance as the property value, similar to how\n * `Symbol.Iterable` can be used to return an `Iterable` from an `Iterator`.\n *\n * @example\n *\n * ```TypeScript\n * import { peerDiscovery, PeerDiscovery } from '@libp2p/peer-discovery'\n *\n * class MyPeerDiscoverer implements PeerDiscovery {\n *   get [peerDiscovery] () {\n *     return this\n *   }\n *\n *   // ...other methods\n * }\n * ```\n */\nexport const peerDiscoverySymbol = Symbol.for('@libp2p/peer-discovery')\n\n/**\n * Implementers of this interface can provide a PeerDiscovery implementation to\n * interested callers.\n */\nexport interface PeerDiscoveryProvider {\n  [peerDiscoverySymbol]: PeerDiscovery\n}\n\nexport interface PeerDiscoveryEvents {\n  peer: CustomEvent<PeerInfo>\n}\n\n/**\n * A class that implements the `PeerDiscovery` interface uses an\n * implementation-specific method to discover peers. These peers are then added\n * to the peer store for use by other system components and services.\n */\nexport interface PeerDiscovery extends TypedEventTarget<PeerDiscoveryEvents> {}\n", "import type { Ed25519PublicKey, KeyType, RSAPublicKey, Secp256k1PublicKey } from './keys.js'\nimport type { CID } from 'multiformats/cid'\nimport type { MultihashDigest } from 'multiformats/hashes/interface'\n\nexport type PeerIdType = KeyType | string\n\n/**\n * A PeerId generated from an RSA public key - it is a base58btc encoded sha-256\n * hash of the public key.\n *\n * RSA public keys are too large to pass around freely, instead Ed25519 or\n * secp256k1 should be preferred as they can embed their public key in the\n * PeerId itself.\n *\n * @deprecated Ed25519 or secp256k1 keys are preferred to RSA\n */\nexport interface RSAPeerId {\n  readonly type: 'RSA'\n\n  /**\n   * RSA public keys are too large to embed in the multihash commonly used to\n   * refer to peers, so this will only be defined if the public key has\n   * previously been found through a routing query or during normal protocol\n   * operations\n   */\n  readonly publicKey?: RSAPublicKey\n\n  /**\n   * Returns the multihash from `toMultihash()` as a base58btc encoded string\n   */\n  toString(): string\n\n  /**\n   * Returns a multihash, the digest of which is the SHA2-256 hash of the public\n   * key\n   */\n  toMultihash(): MultihashDigest<0x12>\n\n  /**\n   * Returns a CID with the libp2p key code and the same multihash as\n   * `toMultihash()`\n   */\n  toCID(): CID<Uint8Array, 0x72, 0x12, 1>\n\n  /**\n   * Returns true if the passed argument is equivalent to this PeerId\n   */\n  equals(other?: any): boolean\n}\n\nexport interface Ed25519PeerId {\n  readonly type: 'Ed25519'\n\n  /**\n   * This will always be defined as the public key is embedded in the multihash\n   * of this PeerId\n   */\n  readonly publicKey: Ed25519PublicKey\n\n  /**\n   * Returns the multihash from `toMultihash()` as a base58btc encoded string\n   */\n  toString(): string\n\n  /**\n   * Returns a multihash, the digest of which is the protobuf-encoded public key\n   * encoded as an identity hash\n   */\n  toMultihash(): MultihashDigest<0x0>\n\n  /**\n   * Returns a CID with the libp2p key code and the same multihash as\n   * `toMultihash()`\n   */\n  toCID(): CID<Uint8Array, 0x72, 0x0, 1>\n\n  /**\n   * Returns true if the passed argument is equivalent to this PeerId\n   */\n  equals(other?: any): boolean\n}\n\nexport interface Secp256k1PeerId {\n  readonly type: 'secp256k1'\n\n  /**\n   * This will always be defined as the public key is embedded in the multihash\n   * of this PeerId\n   */\n  readonly publicKey: Secp256k1PublicKey\n\n  /**\n   * Returns the multihash from `toMultihash()` as a base58btc encoded string\n   */\n  toString(): string\n\n  /**\n   * Returns a multihash, the digest of which is the protobuf-encoded public key\n   * encoded as an identity hash\n   */\n  toMultihash(): MultihashDigest<0x0>\n\n  /**\n   * Returns a CID with the libp2p key code and the same multihash as\n   * `toMultihash()`\n   */\n  toCID(): CID<Uint8Array, 0x72, 0x0, 1>\n\n  /**\n   * Returns true if the passed argument is equivalent to this PeerId\n   */\n  equals(other?: any): boolean\n}\n\nexport interface URLPeerId {\n  readonly type: 'url'\n\n  /**\n   * This will always be undefined as URL Peers do not have public keys\n   */\n  readonly publicKey: undefined\n\n  /**\n   * Returns CID from `toCID()` encoded as a base36 string\n   */\n  toString(): string\n\n  /**\n   * Returns a multihash, the digest of which is the URL encoded as an identity\n   * hash\n   */\n  toMultihash(): MultihashDigest<0x0>\n\n  /**\n   * Returns a CID with the Transport IPFS Gateway HTTP code and the same\n   * multihash as `toMultihash()`\n   */\n  toCID(): CID<Uint8Array, 0x0920, 0x0, 1>\n\n  /**\n   * Returns true if the passed argument is equivalent to this PeerId\n   */\n  equals(other?: any): boolean\n}\n\n/**\n * This is a union of all known PeerId types - use the `.type` field to\n * disambiguate them\n */\nexport type PeerId = RSAPeerId | Ed25519PeerId | Secp256k1PeerId | URLPeerId\n\n/**\n * All PeerId implementations must use this symbol as the name of a property\n * with a boolean `true` value\n */\nexport const peerIdSymbol = Symbol.for('@libp2p/peer-id')\n\n/**\n * Returns true if the passed argument is a PeerId implementation\n */\nexport function isPeerId (other?: any): other is PeerId {\n  return Boolean(other?.[peerIdSymbol])\n}\n", "import type { RoutingOptions } from './index.js'\nimport type { PeerId } from './peer-id.js'\nimport type { PeerInfo } from './peer-info.js'\n\n/**\n * Any object that implements this Symbol as a property should return a\n * PeerRouting instance as the property value, similar to how `Symbol.Iterable`\n * can be used to return an `Iterable` from an `Iterator`.\n *\n * @example\n *\n * ```TypeScript\n * import { peerRouting, PeerRouting } from '@libp2p/peer-routing'\n *\n * class MyPeerRouter implements PeerRouting {\n *   get [peerRouting] () {\n *     return this\n *   }\n *\n *   // ...other methods\n * }\n * ```\n */\nexport const peerRoutingSymbol = Symbol.for('@libp2p/peer-routing')\n\n/**\n * Implementers of this interface can provide a PeerRouting implementation to\n * interested callers.\n */\nexport interface PeerRoutingProvider {\n  [peerRoutingSymbol]: Partial<PeerRouting>\n}\n\nexport interface PeerRouting {\n  /**\n   * Searches the network for peer info corresponding to the passed peer id.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // ...\n   * const peer = await peerRouting.findPeer(peerId, options)\n   * ```\n   */\n  findPeer(peerId: PeerId, options?: RoutingOptions): Promise<PeerInfo>\n\n  /**\n   * Search the network for peers that are closer to the passed key. Peer\n   * info should be yielded in ever-increasing closeness to the key.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // Iterate over the closest peers found for the given key\n   * for await (const peer of peerRouting.getClosestPeers(key)) {\n   *   console.log(peer.id, peer.multiaddrs)\n   * }\n   * ```\n   */\n  getClosestPeers(key: Uint8Array, options?: RoutingOptions): AsyncIterable<PeerInfo>\n}\n", "import type { AbortOptions } from './index.ts'\nimport type { PublicKey } from './keys.js'\nimport type { PeerId } from './peer-id.js'\nimport type { PeerInfo } from './peer-info.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\n/**\n * When a peer that is tagged with this prefix disconnects, we will attempt to\n * redial it, up to a limit.\n *\n * To allow multiple components to add/remove their own keep-alive tags without\n * accidentally overwriting those of other components, attach a unique suffix to\n * the tag, e.g. `keep-alive-circuit-relay` or `keep-alive-kad-dht`, etc.\n */\nexport const KEEP_ALIVE = 'keep-alive'\n\n/**\n * A multiaddr with an optional flag that indicates if its trustworthy\n */\nexport interface Address {\n  /**\n   * Peer multiaddr\n   */\n  multiaddr: Multiaddr\n\n  /**\n   * Obtained from a signed peer record\n   */\n  isCertified: boolean\n}\n\n/**\n * Data stored in the peer store about peers\n */\nexport interface Peer {\n  /**\n   * Peer's peer-id instance\n   */\n  id: PeerId\n\n  /**\n   * Peer's addresses containing a list of multiaddrs and a isCertified field\n   * indicating if the address was loaded from a signed peer record or not\n   */\n  addresses: Address[]\n\n  /**\n   * Peer's supported protocols\n   */\n  protocols: string[]\n\n  /**\n   * Peer's metadata map\n   */\n  metadata: Map<string, Uint8Array>\n\n  /**\n   * Tags a peer has\n   */\n  tags: Map<string, Tag>\n\n  /**\n   * The last peer record envelope received\n   */\n  peerRecordEnvelope?: Uint8Array\n}\n\n/**\n * Peer data used to update the peer store\n */\nexport interface PeerData {\n  /**\n   * Peer's addresses containing its multiaddrs and metadata - multiaddrs\n   * passed here can be treated as certified if the `isCertifed` value is\n   * set to true.\n   *\n   * If both addresses and multiaddrs are specified they will be merged\n   * together with entries in addresses taking precedence.\n   */\n  addresses?: Address[]\n\n  /**\n   * Peer's multiaddrs - any multiaddrs passed here will be treated as\n   * uncertified.\n   *\n   * If both addresses and multiaddrs are specified they will be merged\n   * together with entries in addresses taking precedence.\n   */\n  multiaddrs?: Multiaddr[]\n\n  /**\n   * Peer's supported protocols\n   */\n  protocols?: string[]\n\n  /**\n   * Peer's metadata map. When merging pass undefined as values to remove metadata.\n   */\n  metadata?: Map<string, Uint8Array | undefined> | Record<string, Uint8Array | undefined>\n\n  /**\n   * Peer tags. When merging pass undefined as values to remove tags.\n   */\n  tags?: Map<string, TagOptions | undefined> | Record<string, TagOptions | undefined>\n\n  /**\n   * If this Peer has an RSA key, it's public key can be set with this property.\n   *\n   * The byte array should be the protobuf encoded form of the public key.\n   */\n  publicKey?: PublicKey\n\n  /**\n   * The last peer record envelope received\n   */\n  peerRecordEnvelope?: Uint8Array\n}\n\nexport interface TagOptions {\n  /**\n   * An optional tag value (1-100)\n   */\n  value?: number\n\n  /**\n   * An optional duration in ms after which the tag will expire\n   */\n  ttl?: number\n}\n\nexport interface Tag {\n  /**\n   * The tag value\n   */\n  value: number\n}\n\n/**\n * A predicate by which to filter lists of peers\n */\nexport interface PeerQueryFilter { (peer: Peer): boolean }\n\n/**\n * A predicate by which to sort lists of peers\n */\nexport interface PeerQueryOrder { (a: Peer, b: Peer): -1 | 0 | 1 }\n\n/**\n * A query for getting lists of peers\n */\nexport interface PeerQuery extends AbortOptions {\n  filters?: PeerQueryFilter[]\n  orders?: PeerQueryOrder[]\n  limit?: number\n  offset?: number\n}\n\nexport interface ConsumePeerRecordOptions extends AbortOptions {\n  expectedPeer?: PeerId\n}\n\nexport interface PeerStore {\n  /**\n   * Loop over every peer - the looping is async because we read from a\n   * datastore but the peer operation is sync, this is to prevent\n   * long-lived peer operations causing deadlocks over the datastore\n   * which can happen if they try to access the peer store during the\n   * loop\n   *\n   * @example\n   *\n   * ```TypeScript\n   * await peerStore.forEach(peer => {\n   *   // ...\n   * })\n   * ```\n   */\n  forEach(fn: (peer: Peer) => void, query?: PeerQuery): Promise<void>\n\n  /**\n   * Returns all peers in the peer store.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for (const peer of await peerStore.all()) {\n   *   // ...\n   * }\n   * ```\n   */\n  all(query?: PeerQuery): Promise<Peer[]>\n\n  /**\n   * Delete all data stored for the passed peer\n   *\n   * @example\n   *\n   * ```TypeScript\n   * await peerStore.addressBook.set(peerId, multiaddrs)\n   * await peerStore.addressBook.get(peerId)\n   * // multiaddrs[]\n   *\n   * await peerStore.delete(peerId)\n   *\n   * await peerStore.addressBook.get(peerId)\n   * // []\n   * ```\n   */\n  delete(peerId: PeerId, options?: AbortOptions): Promise<void>\n\n  /**\n   * Returns true if the passed PeerId is in the peer store\n   *\n   * @example\n   *\n   * ```TypeScript\n   * await peerStore.has(peerId)\n   * // false\n   * await peerStore.addressBook.add(peerId, multiaddrs)\n   * await peerStore.has(peerId)\n   * // true\n   * ```\n   */\n  has(peerId: PeerId, options?: AbortOptions): Promise<boolean>\n\n  /**\n   * Returns all data stored for the passed PeerId\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peer = await peerStore.get(peerId)\n   * // { .. }\n   * ```\n   */\n  get(peerId: PeerId, options?: AbortOptions): Promise<Peer>\n\n  /**\n   * Returns a PeerInfo object for the passed peer id. This is similar to `get`\n   * except the returned value contains fewer fields and is often used to\n   * exchange peer information with other systems.\n   *\n   * The returned object can be passed to `JSON.stringify` without any\n   * additional processing.\n   *\n   * @see https://docs.libp2p.io/concepts/fundamentals/peers/#peer-info\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peerInfo = await peerStore.getInfo(peerId)\n   *\n   * console.info(JSON.stringify(peerInfo))\n   * // {\n   * //    id: 'peerId'\n   * //    multiaddrs: [\n   * //      '...'\n   * //    ]\n   * // }\n   * ```\n   */\n  getInfo (peerId: PeerId, options?: AbortOptions): Promise<PeerInfo>\n\n  /**\n   * Adds a peer to the peer store, overwriting any existing data\n   *\n   * @example\n   *\n   * ```TypeScript\n   * await peerStore.save(peerId, {\n   *   multiaddrs\n   * })\n   * ```\n   */\n  save(id: PeerId, data: PeerData, options?: AbortOptions): Promise<Peer>\n\n  /**\n   * Adds a peer to the peer store, overwriting only the passed fields\n   *\n   * @example\n   *\n   * ```TypeScript\n   * await peerStore.patch(peerId, {\n   *   multiaddrs\n   * })\n   * ```\n   */\n  patch(id: PeerId, data: PeerData, options?: AbortOptions): Promise<Peer>\n\n  /**\n   * Adds a peer to the peer store, deeply merging any existing data.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * await peerStore.merge(peerId, {\n   *   multiaddrs\n   * })\n   * ```\n   */\n  merge(id: PeerId, data: PeerData, options?: AbortOptions): Promise<Peer>\n\n  /**\n   * Unmarshal and verify a signed peer record, extract the multiaddrs and\n   * overwrite the stored addresses for the peer.\n   *\n   * Optionally pass an expected PeerId to verify that the peer record was\n   * signed by that peer.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * await peerStore.consumePeerRecord(buf, expectedPeer)\n   * ```\n   */\n  consumePeerRecord(buf: Uint8Array, options?: ConsumePeerRecordOptions): Promise<boolean>\n\n  /**\n   * @deprecated Pass `expectedPeer` as a property of `options` instead\n   */\n  consumePeerRecord(buf: Uint8Array, expectedPeer?: PeerId, options?: AbortOptions): Promise<boolean>\n}\n", "import type { Stream } from './connection.js'\nimport type { TypedEventTarget } from './event-target.js'\nimport type { PublicKey } from './keys.js'\nimport type { PeerId } from './peer-id.js'\nimport type { Pushable } from 'it-pushable'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\n/**\n * On the producing side:\n * - Build messages with the signature, key (from may be enough for certain inlineable public key types), from and seqno fields.\n *\n * On the consuming side:\n * - Enforce the fields to be present, reject otherwise.\n * - Propagate only if the fields are valid and signature can be verified, reject otherwise.\n */\nexport const StrictSign = 'StrictSign'\n\n/**\n * On the producing side:\n * - Build messages without the signature, key, from and seqno fields.\n * - The corresponding protobuf key-value pairs are absent from the marshaled message, not just empty.\n *\n * On the consuming side:\n * - Enforce the fields to be absent, reject otherwise.\n * - Propagate only if the fields are absent, reject otherwise.\n * - A message_id function will not be able to use the above fields, and should instead rely on the data field. A commonplace strategy is to calculate a hash.\n */\nexport const StrictNoSign = 'StrictNoSign'\n\nexport type SignaturePolicy = typeof StrictSign | typeof StrictNoSign\n\nexport interface SignedMessage {\n  type: 'signed'\n  from: PeerId\n  topic: string\n  data: Uint8Array\n  sequenceNumber: bigint\n  signature: Uint8Array\n  key: PublicKey\n}\n\nexport interface UnsignedMessage {\n  type: 'unsigned'\n  topic: string\n  data: Uint8Array\n}\n\nexport type Message = SignedMessage | UnsignedMessage\n\nexport interface PubSubRPCMessage {\n  from?: Uint8Array\n  topic?: string\n  data?: Uint8Array\n  sequenceNumber?: Uint8Array\n  signature?: Uint8Array\n  key?: Uint8Array\n}\n\nexport interface PubSubRPCSubscription {\n  subscribe?: boolean\n  topic?: string\n}\n\nexport interface PubSubRPC {\n  subscriptions: PubSubRPCSubscription[]\n  messages: PubSubRPCMessage[]\n}\n\nexport interface PeerStreams extends TypedEventTarget<PeerStreamEvents> {\n  id: PeerId\n  protocol: string\n  outboundStream?: Pushable<Uint8ArrayList>\n  inboundStream?: AsyncIterable<Uint8ArrayList>\n  isWritable: boolean\n\n  close(): void\n  write(buf: Uint8Array | Uint8ArrayList): void\n  attachInboundStream(stream: Stream): AsyncIterable<Uint8ArrayList>\n  attachOutboundStream(stream: Stream): Promise<Pushable<Uint8ArrayList>>\n}\n\nexport interface PubSubInit {\n  enabled?: boolean\n\n  multicodecs?: string[]\n\n  /**\n   * defines how signatures should be handled\n   */\n  globalSignaturePolicy?: SignaturePolicy\n\n  /**\n   * if can relay messages not subscribed\n   */\n  canRelayMessage?: boolean\n\n  /**\n   * if publish should emit to self, if subscribed\n   */\n  emitSelf?: boolean\n\n  /**\n   * handle this many incoming pubsub messages concurrently\n   */\n  messageProcessingConcurrency?: number\n\n  /**\n   * How many parallel incoming streams to allow on the pubsub protocol per-connection\n   */\n  maxInboundStreams?: number\n\n  /**\n   * How many parallel outgoing streams to allow on the pubsub protocol per-connection\n   */\n  maxOutboundStreams?: number\n}\n\nexport interface Subscription {\n  topic: string\n  subscribe: boolean\n}\n\nexport interface SubscriptionChangeData {\n  peerId: PeerId\n  subscriptions: Subscription[]\n}\n\nexport interface PubSubEvents {\n  'subscription-change': CustomEvent<SubscriptionChangeData>\n  message: CustomEvent<Message>\n}\n\nexport interface PublishResult {\n  recipients: PeerId[]\n}\n\nexport enum TopicValidatorResult {\n  /**\n   * The message is considered valid, and it should be delivered and forwarded to the network\n   */\n  Accept = 'accept',\n  /**\n   * The message is neither delivered nor forwarded to the network\n   */\n  Ignore = 'ignore',\n  /**\n   * The message is considered invalid, and it should be rejected\n   */\n  Reject = 'reject'\n}\n\nexport interface TopicValidatorFn {\n  (peer: PeerId, message: Message): TopicValidatorResult | Promise<TopicValidatorResult>\n}\n\n/**\n * @deprecated This will be removed from `@libp2p/interface` in a future release, pubsub implementations should declare their own types\n */\nexport interface PubSub<Events extends Record<string, any> = PubSubEvents> extends TypedEventTarget<Events> {\n  /**\n   * The global signature policy controls whether or not we sill send and receive\n   * signed or unsigned messages.\n   *\n   * Signed messages prevent spoofing message senders and should be preferred to\n   * using unsigned messages.\n   */\n  globalSignaturePolicy: typeof StrictSign | typeof StrictNoSign\n\n  /**\n   * A list of multicodecs that contain the pubsub protocol name.\n   */\n  multicodecs: string[]\n\n  /**\n   * Pubsub routers support message validators per topic, which will validate the message\n   * before its propagations. They are stored in a map where keys are the topic name and\n   * values are the validators.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const validateMessage = (msgTopic, msg) => {\n   *   const input = uint8ArrayToString(msg.data)\n   *   const validInputs = ['a', 'b', 'c']\n   *\n   *   if (!validInputs.includes(input)) {\n   *     throw new Error('no valid input received')\n   *   }\n   * }\n   * libp2p.pubsub.topicValidators.set(topic, validateMessage)\n   * ```\n   */\n  topicValidators: Map<string, TopicValidatorFn>\n\n  getPeers(): PeerId[]\n\n  /**\n   * Gets a list of topics the node is subscribed to.\n   *\n   * ```TypeScript\n   * const topics = libp2p.pubsub.getTopics()\n   * ```\n   */\n  getTopics(): string[]\n\n  /**\n   * Subscribes to a pubsub topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const handler = (msg) => {\n   *   if (msg.topic === topic) {\n   *     // msg.data - pubsub data received\n   *   }\n   * }\n   *\n   * libp2p.pubsub.addEventListener('message', handler)\n   * libp2p.pubsub.subscribe(topic)\n   * ```\n   */\n  subscribe(topic: string): void\n\n  /**\n   * Unsubscribes from a pubsub topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const handler = (msg) => {\n   *   // msg.data - pubsub data received\n   * }\n   *\n   * libp2p.pubsub.removeEventListener(topic handler)\n   * libp2p.pubsub.unsubscribe(topic)\n   * ```\n   */\n  unsubscribe(topic: string): void\n\n  /**\n   * Gets a list of the PeerIds that are subscribed to one topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peerIds = libp2p.pubsub.getSubscribers(topic)\n   * ```\n   */\n  getSubscribers(topic: string): PeerId[]\n\n  /**\n   * Publishes messages to the given topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const data = uint8ArrayFromString('data')\n   *\n   * await libp2p.pubsub.publish(topic, data)\n   * ```\n   */\n  publish(topic: string, data: Uint8Array): Promise<PublishResult>\n}\n\nexport interface PeerStreamEvents {\n  'stream:inbound': CustomEvent<never>\n  'stream:outbound': CustomEvent<never>\n  close: CustomEvent<never>\n}\n\n/**\n * All Pubsub implementations must use this symbol as the name of a property\n * with a boolean `true` value\n */\nexport const pubSubSymbol = Symbol.for('@libp2p/pubsub')\n\n/**\n * Returns true if the passed argument is a PubSub implementation\n */\nexport function isPubSub (obj?: any): obj is PubSub {\n  return Boolean(obj?.[pubSubSymbol])\n}\n", "import type { Connection, ConnectionLimits, MultiaddrConnection } from './connection.js'\nimport type { TypedEventTarget } from './event-target.js'\nimport type { AbortOptions, ClearableSignal, ConnectionEncrypter } from './index.js'\nimport type { StreamMuxerFactory } from './stream-muxer.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { ProgressOptions, ProgressEvent } from 'progress-events'\n\nexport interface ListenerEvents {\n  /**\n   * This event signals to the transport manager that the listening addresses\n   * have changed and may be emitted at any point and/or multiple times\n   */\n  listening: CustomEvent\n\n  /**\n   * Emitted if listening on an address failed\n   */\n  error: CustomEvent<Error>\n\n  /**\n   * Emitted when the listener has been shut down, has no open connections and\n   * will no longer accept new connections\n   */\n  close: CustomEvent\n}\n\nexport interface Listener extends TypedEventTarget<ListenerEvents> {\n  /**\n   * Start a listener\n   */\n  listen(multiaddr: Multiaddr): Promise<void>\n  /**\n   * Get listen addresses\n   */\n  getAddrs(): Multiaddr[]\n  /**\n   * Close listener\n   *\n   * @returns {Promise<void>}\n   */\n  close(): Promise<void>\n  /**\n   * Allows transports to amend announce addresses - to add certificate hashes\n   * or other metadata that cannot be known before runtime\n   */\n  updateAnnounceAddrs(addrs: Multiaddr[]): void\n}\n\nexport const transportSymbol = Symbol.for('@libp2p/transport')\n\n/**\n * A filter that acts on a list of multiaddrs\n */\nexport interface MultiaddrFilter {\n  (multiaddrs: Multiaddr[]): Multiaddr[]\n}\n\nexport interface CreateListenerOptions {\n  /**\n   * The upgrader turns a MultiaddrConnection into a Connection and notifies\n   * other libp2p components about a new incoming connection.\n   */\n  upgrader: Upgrader\n}\n\nexport interface DialTransportOptions<DialEvents extends ProgressEvent = ProgressEvent> extends Required<AbortOptions>, ProgressOptions<DialEvents> {\n  /**\n   * The upgrader turns a MultiaddrConnection into a Connection which should be\n   * returned by the transport's dial method\n   */\n  upgrader: Upgrader\n}\n\n/**\n * A libp2p transport offers dial and listen methods to establish connections.\n */\nexport interface Transport<DialEvents extends ProgressEvent = ProgressEvent> {\n  /**\n   * Used to identify the transport\n   */\n  [Symbol.toStringTag]: string\n\n  /**\n   * Used by the isTransport function\n   */\n  [transportSymbol]: true\n\n  /**\n   * Dial a given multiaddr.\n   */\n  dial(ma: Multiaddr, options: DialTransportOptions<DialEvents>): Promise<Connection>\n\n  /**\n   * Create transport listeners.\n   */\n  createListener(options: CreateListenerOptions): Listener\n\n  /**\n   * Takes a list of `Multiaddr`s and returns only addresses that are valid for\n   * the transport to listen on\n   */\n  listenFilter: MultiaddrFilter\n\n  /**\n   * Takes a list of `Multiaddr`s and returns only addresses that are valid for\n   * the transport to dial\n   */\n  dialFilter: MultiaddrFilter\n}\n\n/**\n * Used to disambiguate transport implementations\n */\nexport function isTransport (other?: any): other is Transport {\n  return other != null && Boolean(other[transportSymbol])\n}\n\n/**\n * Enum Transport Manager Fault Tolerance values\n */\nexport enum FaultTolerance {\n  /**\n   * should be used for failing in any listen circumstance\n   */\n  FATAL_ALL = 0,\n\n  /**\n   * should be used for not failing when not listening\n   */\n  NO_FATAL\n}\n\n/**\n * Options accepted by the upgrader during connection establishment\n */\nexport interface UpgraderOptions<ConnectionUpgradeEvents extends ProgressEvent = ProgressEvent> extends ProgressOptions<ConnectionUpgradeEvents>, Required<AbortOptions> {\n  /**\n   * If true the invoking transport is expected to implement it's own encryption\n   * and an encryption protocol will not attempted to be negotiated via\n   * multi-stream select\n   *\n   * @default false\n   */\n  skipEncryption?: boolean\n\n  /**\n   * If true no connection protection will be performed on the connection.\n   */\n  skipProtection?: boolean\n\n  /**\n   * By default a stream muxer protocol will be negotiated via multi-stream\n   * select after an encryption protocol has been agreed on.\n   *\n   * If a transport provides it's own stream muxing facility pass a muxer\n   * factory instance here to skip muxer negotiation.\n   */\n  muxerFactory?: StreamMuxerFactory\n\n  /**\n   * If the connection is to have limits applied to it, pass them here\n   */\n  limits?: ConnectionLimits\n\n  /**\n   * Multi-stream select is a initiator/responder protocol. By default a\n   * connection returned from `upgrader.upgradeOutbound` will be the initiator\n   * and one returned from `upgrader.upgradeInbound` will be the responder.\n   *\n   * Pass a value here to override the default.\n   */\n  initiator?: boolean\n}\n\nexport type InboundConnectionUpgradeEvents =\nProgressEvent<'upgrader:encrypt-inbound-connection'> |\nProgressEvent<'upgrader:multiplex-inbound-connection'>\n\nexport type OutboundConnectionUpgradeEvents =\nProgressEvent<'upgrader:encrypt-outbound-connection'> |\nProgressEvent<'upgrader:multiplex-outbound-connection'>\n\nexport interface Upgrader {\n  /**\n   * Upgrades an outbound connection created by the `dial` method of a transport\n   */\n  upgradeOutbound(maConn: MultiaddrConnection, opts?: UpgraderOptions<OutboundConnectionUpgradeEvents>): Promise<Connection>\n\n  /**\n   * Upgrades an inbound connection received by a transport listener and\n   * notifies other libp2p components about the new connection\n   */\n  upgradeInbound(maConn: MultiaddrConnection, opts?: UpgraderOptions<InboundConnectionUpgradeEvents>): Promise<void>\n\n  /**\n   * Used by transports that perform part of the upgrade process themselves and\n   * do some async work. This allows configuring inbound upgrade timeouts from a\n   * single location.\n   *\n   * Regular transports should just pass the signal from their shutdown\n   * controller to `upgradeInbound`.\n   */\n  createInboundAbortSignal (signal: AbortSignal): ClearableSignal\n\n  /**\n   * Returns configured stream muxers\n   */\n  getStreamMuxers (): Map<string, StreamMuxerFactory>\n\n  /**\n   * Returns configured connection encrypters\n   */\n  getConnectionEncrypters (): Map<string, ConnectionEncrypter>\n}\n", "/**\n * When this error is thrown it means an operation was aborted,\n * usually in response to the `abort` event being emitted by an\n * AbortSignal.\n */\nexport class AbortError extends Error {\n  static name = 'AbortError'\n\n  constructor (message: string = 'The operation was aborted') {\n    super(message)\n    this.name = 'AbortError'\n  }\n}\n\n/**\n * Thrown when a remote Peer ID does not match the expected one\n */\nexport class UnexpectedPeerError extends Error {\n  static name = 'UnexpectedPeerError'\n\n  constructor (message = 'Unexpected Peer') {\n    super(message)\n    this.name = 'UnexpectedPeerError'\n  }\n}\n\n/**\n * Thrown when a crypto exchange fails\n */\nexport class InvalidCryptoExchangeError extends Error {\n  static name = 'InvalidCryptoExchangeError'\n\n  constructor (message = 'Invalid crypto exchange') {\n    super(message)\n    this.name = 'InvalidCryptoExchangeError'\n  }\n}\n\n/**\n * Thrown when invalid parameters are passed to a function or method call\n */\nexport class InvalidParametersError extends Error {\n  static name = 'InvalidParametersError'\n\n  constructor (message = 'Invalid parameters') {\n    super(message)\n    this.name = 'InvalidParametersError'\n  }\n}\n\n/**\n * Thrown when a public key is invalid\n */\nexport class InvalidPublicKeyError extends Error {\n  static name = 'InvalidPublicKeyError'\n\n  constructor (message = 'Invalid public key') {\n    super(message)\n    this.name = 'InvalidPublicKeyError'\n  }\n}\n\n/**\n * Thrown when a private key is invalid\n */\nexport class InvalidPrivateKeyError extends Error {\n  static name = 'InvalidPrivateKeyError'\n\n  constructor (message = 'Invalid private key') {\n    super(message)\n    this.name = 'InvalidPrivateKeyError'\n  }\n}\n\n/**\n * Thrown when a operation is unsupported\n */\nexport class UnsupportedOperationError extends Error {\n  static name = 'UnsupportedOperationError'\n\n  constructor (message = 'Unsupported operation') {\n    super(message)\n    this.name = 'UnsupportedOperationError'\n  }\n}\n\n/**\n * Thrown when a connection is closing\n */\nexport class ConnectionClosingError extends Error {\n  static name = 'ConnectionClosingError'\n\n  constructor (message = 'The connection is closing') {\n    super(message)\n    this.name = 'ConnectionClosingError'\n  }\n}\n\n/**\n * Thrown when a connection is closed\n */\nexport class ConnectionClosedError extends Error {\n  static name = 'ConnectionClosedError'\n\n  constructor (message = 'The connection is closed') {\n    super(message)\n    this.name = 'ConnectionClosedError'\n  }\n}\n\n/**\n * Thrown when a connection fails\n */\nexport class ConnectionFailedError extends Error {\n  static name = 'ConnectionFailedError'\n\n  constructor (message = 'Connection failed') {\n    super(message)\n    this.name = 'ConnectionFailedError'\n  }\n}\n\n/**\n * Thrown when the muxer is closed and an attempt to open a stream occurs\n */\nexport class MuxerClosedError extends Error {\n  static name = 'MuxerClosedError'\n\n  constructor (message = 'The muxer is closed') {\n    super(message)\n    this.name = 'MuxerClosedError'\n  }\n}\n\n/**\n * Thrown when a protocol stream is reset by the remote muxer\n */\nexport class StreamResetError extends Error {\n  static name = 'StreamResetError'\n\n  constructor (message = 'The stream has been reset') {\n    super(message)\n    this.name = 'StreamResetError'\n  }\n}\n\n/**\n * Thrown when a stream is in an invalid state\n */\nexport class StreamStateError extends Error {\n  static name = 'StreamStateError'\n\n  constructor (message = 'The stream is in an invalid state') {\n    super(message)\n    this.name = 'StreamStateError'\n  }\n}\n\n/**\n * Thrown when a value could not be found\n */\nexport class NotFoundError extends Error {\n  static name = 'NotFoundError'\n\n  constructor (message = 'Not found') {\n    super(message)\n    this.name = 'NotFoundError'\n  }\n}\n\n/**\n * Thrown when an invalid peer ID is encountered\n */\nexport class InvalidPeerIdError extends Error {\n  static name = 'InvalidPeerIdError'\n\n  constructor (message = 'Invalid PeerID') {\n    super(message)\n    this.name = 'InvalidPeerIdError'\n  }\n}\n\n/**\n * Thrown when an invalid multiaddr is encountered\n */\nexport class InvalidMultiaddrError extends Error {\n  static name = 'InvalidMultiaddrError'\n\n  constructor (message = 'Invalid multiaddr') {\n    super(message)\n    this.name = 'InvalidMultiaddrError'\n  }\n}\n\n/**\n * Thrown when an invalid CID is encountered\n */\nexport class InvalidCIDError extends Error {\n  static name = 'InvalidCIDError'\n\n  constructor (message = 'Invalid CID') {\n    super(message)\n    this.name = 'InvalidCIDError'\n  }\n}\n\n/**\n * Thrown when an invalid multihash is encountered\n */\nexport class InvalidMultihashError extends Error {\n  static name = 'InvalidMultihashError'\n\n  constructor (message = 'Invalid Multihash') {\n    super(message)\n    this.name = 'InvalidMultihashError'\n  }\n}\n\n/**\n * Thrown when a protocol is not supported\n */\nexport class UnsupportedProtocolError extends Error {\n  static name = 'UnsupportedProtocolError'\n\n  constructor (message = 'Unsupported protocol error') {\n    super(message)\n    this.name = 'UnsupportedProtocolError'\n  }\n}\n\n/**\n * An invalid or malformed message was encountered during a protocol exchange\n */\nexport class InvalidMessageError extends Error {\n  static name = 'InvalidMessageError'\n\n  constructor (message = 'Invalid message') {\n    super(message)\n    this.name = 'InvalidMessageError'\n  }\n}\n\n/**\n * Thrown when a remote peer sends a structurally valid message that does not\n * comply with the protocol\n */\nexport class ProtocolError extends Error {\n  static name = 'ProtocolError'\n\n  constructor (message = 'Protocol error') {\n    super(message)\n    this.name = 'ProtocolError'\n  }\n}\n\n/**\n * Throw when an operation times out\n */\nexport class TimeoutError extends Error {\n  static name = 'TimeoutError'\n\n  constructor (message = 'Timed out') {\n    super(message)\n    this.name = 'TimeoutError'\n  }\n}\n\n/**\n * Thrown when a startable component is interacted with but it has not been\n * started yet\n */\nexport class NotStartedError extends Error {\n  static name = 'NotStartedError'\n\n  constructor (message = 'Not started') {\n    super(message)\n    this.name = 'NotStartedError'\n  }\n}\n\n/**\n * Thrown when a component is started that has already been started\n */\nexport class AlreadyStartedError extends Error {\n  static name = 'AlreadyStartedError'\n\n  constructor (message = 'Already started') {\n    super(message)\n    this.name = 'AlreadyStartedError'\n  }\n}\n\n/**\n * Thrown when dialing an address failed\n */\nexport class DialError extends Error {\n  static name = 'DialError'\n\n  constructor (message = 'Dial error') {\n    super(message)\n    this.name = 'DialError'\n  }\n}\n\n/**\n * Thrown when listening on an address failed\n */\nexport class ListenError extends Error {\n  static name = 'ListenError'\n\n  constructor (message = 'Listen error') {\n    super(message)\n    this.name = 'ListenError'\n  }\n}\n\n/**\n * This error is thrown when a limited connection is encountered, i.e. if the\n * user tried to open a stream on a connection for a protocol that is not\n * configured to run over limited connections.\n */\nexport class LimitedConnectionError extends Error {\n  static name = 'LimitedConnectionError'\n\n  constructor (message = 'Limited connection') {\n    super(message)\n    this.name = 'LimitedConnectionError'\n  }\n}\n\n/**\n * This error is thrown where there are too many inbound protocols streams open\n */\nexport class TooManyInboundProtocolStreamsError extends Error {\n  static name = 'TooManyInboundProtocolStreamsError'\n\n  constructor (message = 'Too many inbound protocol streams') {\n    super(message)\n    this.name = 'TooManyInboundProtocolStreamsError'\n  }\n}\n\n/**\n * This error is thrown where there are too many outbound protocols streams open\n */\nexport class TooManyOutboundProtocolStreamsError extends Error {\n  static name = 'TooManyOutboundProtocolStreamsError'\n\n  constructor (message = 'Too many outbound protocol streams') {\n    super(message)\n    this.name = 'TooManyOutboundProtocolStreamsError'\n  }\n}\n\n/**\n * Thrown when an attempt to operate on an unsupported key was made\n */\nexport class UnsupportedKeyTypeError extends Error {\n  static name = 'UnsupportedKeyTypeError'\n\n  constructor (message = 'Unsupported key type') {\n    super(message)\n    this.name = 'UnsupportedKeyTypeError'\n  }\n}\n\n/**\n * Thrown when an operation has not been implemented\n */\nexport class NotImplementedError extends Error {\n  static name = 'NotImplementedError'\n\n  constructor (message = 'Not implemented') {\n    super(message)\n    this.name = 'NotImplementedError'\n  }\n}\n", "/**\n * Noop for browser compatibility\n */\nexport function setMaxListeners (): void {}\n", "import { setMaxListeners } from './events.js'\n\nexport interface EventCallback<EventType> { (evt: EventType): void }\nexport interface EventObject<EventType> { handleEvent: EventCallback<EventType> }\nexport type EventHandler<EventType> = EventCallback<EventType> | EventObject<EventType>\n\ninterface Listener {\n  once: boolean\n  callback: any\n}\n\n/**\n * Adds types to the EventTarget class. Hopefully this won't be necessary\n * forever.\n *\n * https://github.com/microsoft/TypeScript/issues/28357\n * https://github.com/microsoft/TypeScript/issues/43477\n * https://github.com/microsoft/TypeScript/issues/299\n * etc\n */\nexport interface TypedEventTarget <EventMap extends Record<string, any>> extends EventTarget {\n  addEventListener<K extends keyof EventMap>(type: K, listener: EventHandler<EventMap[K]> | null, options?: boolean | AddEventListenerOptions): void\n\n  listenerCount (type: string): number\n\n  removeEventListener<K extends keyof EventMap>(type: K, listener?: EventHandler<EventMap[K]> | null, options?: boolean | EventListenerOptions): void\n\n  removeEventListener (type: string, listener?: EventHandler<Event>, options?: boolean | EventListenerOptions): void\n\n  safeDispatchEvent<Detail>(type: keyof EventMap, detail?: CustomEventInit<Detail>): boolean\n}\n\n/**\n * An implementation of a typed event target\n */\nexport class TypedEventEmitter<EventMap extends Record<string, any>> extends EventTarget implements TypedEventTarget<EventMap> {\n  readonly #listeners = new Map<any, Listener[]>()\n\n  constructor () {\n    super()\n\n    // silence MaxListenersExceededWarning warning on Node.js, this is a red\n    // herring almost all of the time\n    setMaxListeners(Infinity, this)\n  }\n\n  listenerCount (type: string): number {\n    const listeners = this.#listeners.get(type)\n\n    if (listeners == null) {\n      return 0\n    }\n\n    return listeners.length\n  }\n\n  addEventListener<K extends keyof EventMap>(type: K, listener: EventHandler<EventMap[K]> | null, options?: boolean | AddEventListenerOptions): void\n  addEventListener (type: string, listener: EventHandler<Event>, options?: boolean | AddEventListenerOptions): void {\n    super.addEventListener(type, listener, options)\n\n    let list = this.#listeners.get(type)\n\n    if (list == null) {\n      list = []\n      this.#listeners.set(type, list)\n    }\n\n    list.push({\n      callback: listener,\n      once: (options !== true && options !== false && options?.once) ?? false\n    })\n  }\n\n  removeEventListener<K extends keyof EventMap>(type: K, listener?: EventHandler<EventMap[K]> | null, options?: boolean | EventListenerOptions): void\n  removeEventListener (type: string, listener?: EventHandler<Event>, options?: boolean | EventListenerOptions): void {\n    super.removeEventListener(type.toString(), listener ?? null, options)\n\n    let list = this.#listeners.get(type)\n\n    if (list == null) {\n      return\n    }\n\n    list = list.filter(({ callback }) => callback !== listener)\n    this.#listeners.set(type, list)\n  }\n\n  dispatchEvent (event: Event): boolean {\n    const result = super.dispatchEvent(event)\n\n    let list = this.#listeners.get(event.type)\n\n    if (list == null) {\n      return result\n    }\n\n    list = list.filter(({ once }) => !once)\n    this.#listeners.set(event.type, list)\n\n    return result\n  }\n\n  safeDispatchEvent<Detail>(type: keyof EventMap, detail: CustomEventInit<Detail> = {}): boolean {\n    return this.dispatchEvent(new CustomEvent<Detail>(type as string, detail))\n  }\n}\n", "/**\n * Implemented by components that have a life cycle\n */\nexport interface Startable {\n  /**\n   * If implemented, this method will be invoked before the start method.\n   *\n   * It should not assume any other components have been started.\n   */\n  beforeStart?(): void | Promise<void>\n\n  /**\n   * This method will be invoked to start the component.\n   *\n   * It should not assume that any other components have been started.\n   */\n  start(): void | Promise<void>\n\n  /**\n   * If implemented, this method will be invoked after the start method.\n   *\n   * All other components will have had their start method invoked before this method is called.\n   */\n  afterStart?(): void | Promise<void>\n\n  /**\n   * If implemented, this method will be invoked before the stop method.\n   *\n   * Any other components will still be running when this method is called.\n   */\n  beforeStop?(): void | Promise<void>\n\n  /**\n   * This method will be invoked to stop the component.\n   *\n   * It should not assume any other components are running when it is called.\n   */\n  stop(): void | Promise<void>\n\n  /**\n   * If implemented, this method will be invoked after the stop method.\n   *\n   * All other components will have had their stop method invoked before this method is called.\n   */\n  afterStop?(): void | Promise<void>\n}\n\n/**\n * Returns `true` if the object has type overlap with `Startable`\n */\nexport function isStartable (obj?: any): obj is Startable {\n  return obj != null && typeof obj.start === 'function' && typeof obj.stop === 'function'\n}\n\n/**\n * A function that can be used to start and objects passed to it. This checks\n * that an object is startable before invoking its lifecycle methods so it is\n * safe to pass non-`Startable`s in.\n *\n * @example\n *\n * ```TypeScript\n * import { start } from '@libp2p/interface'\n * import type { Startable } from '@libp2p/interface'\n *\n * const startable: Startable = {\n *   start: () => {},\n *   stop: () => {}\n * }\n *\n * const notStartable = 5\n *\n * await start(\n *   startable,\n *   notStartable\n * )\n * ```\n */\nexport async function start (...objs: any[]): Promise<void> {\n  const startables: Startable[] = []\n\n  for (const obj of objs) {\n    if (isStartable(obj)) {\n      startables.push(obj)\n    }\n  }\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.beforeStart != null) {\n        await s.beforeStart()\n      }\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      await s.start()\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.afterStart != null) {\n        await s.afterStart()\n      }\n    })\n  )\n}\n\n/**\n * A function that can be used to stop and objects passed to it. This checks\n * that an object is startable before invoking its lifecycle methods so it is\n * safe to pass non-`Startable`s in.\n *\n * @example\n *\n * ```TypeScript\n * import { stop } from '@libp2p/interface'\n * import type { Startable } from '@libp2p/interface'\n *\n * const startable: Startable = {\n *   start: () => {},\n *   stop: () => {}\n * }\n *\n * const notStartable = 5\n *\n * await stop(\n *   startable,\n *   notStartable\n * )\n * ```\n */\nexport async function stop (...objs: any[]): Promise<void> {\n  const startables: Startable[] = []\n\n  for (const obj of objs) {\n    if (isStartable(obj)) {\n      startables.push(obj)\n    }\n  }\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.beforeStop != null) {\n        await s.beforeStop()\n      }\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      await s.stop()\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.afterStop != null) {\n        await s.afterStop()\n      }\n    })\n  )\n}\n"],
+  "mappings": "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",
   "names": ["index_exports", "__export", "AbortError", "AlreadyStartedError", "ConnectionClosedError", "ConnectionClosingError", "ConnectionFailedError", "DialError", "FaultTolerance", "InvalidCIDError", "InvalidCryptoExchangeError", "InvalidMessageError", "InvalidMultiaddrError", "InvalidMultihashError", "InvalidParametersError", "InvalidPeerIdError", "InvalidPrivateKeyError", "InvalidPublicKeyError", "KEEP_ALIVE", "LimitedConnectionError", "ListenError", "MuxerClosedError", "NotFoundError", "NotImplementedError", "NotStartedError", "ProtocolError", "StreamResetError", "StreamStateError", "StrictNoSign", "StrictSign", "TimeoutError", "TooManyInboundProtocolStreamsError", "TooManyOutboundProtocolStreamsError", "TopicValidatorResult", "TypedEventEmitter", "UnexpectedPeerError", "UnsupportedKeyTypeError", "UnsupportedOperationError", "UnsupportedProtocolError", "connectionSymbol", "contentRoutingSymbol", "isConnection", "isPeerId", "isPrivateKey", "isPubSub", "isPublicKey", "isStartable", "isTransport", "peerDiscoverySymbol", "peerIdSymbol", "peerRoutingSymbol", "pubSubSymbol", "serviceCapabilities", "serviceDependencies", "setMaxListeners", "start", "stop", "transportSymbol", "connectionSymbol", "isConnection", "other", "contentRoutingSymbol", "isPublicKey", "key", "isPrivateKey", "peerDiscoverySymbol", "peerIdSymbol", "isPeerId", "other", "peerRoutingSymbol", "KEEP_ALIVE", "StrictSign", "StrictNoSign", "TopicValidatorResult", "pubSubSymbol", "isPubSub", "obj", "transportSymbol", "isTransport", "other", "FaultTolerance", "AbortError", "message", "UnexpectedPeerError", "InvalidCryptoExchangeError", "InvalidParametersError", "InvalidPublicKeyError", "InvalidPrivateKeyError", "UnsupportedOperationError", "ConnectionClosingError", "ConnectionClosedError", "ConnectionFailedError", "MuxerClosedError", "StreamResetError", "StreamStateError", "NotFoundError", "InvalidPeerIdError", "InvalidMultiaddrError", "InvalidCIDError", "InvalidMultihashError", "UnsupportedProtocolError", "InvalidMessageError", "ProtocolError", "TimeoutError", "NotStartedError", "AlreadyStartedError", "DialError", "ListenError", "LimitedConnectionError", "TooManyInboundProtocolStreamsError", "TooManyOutboundProtocolStreamsError", "UnsupportedKeyTypeError", "NotImplementedError", "setMaxListeners", "TypedEventEmitter", "#listeners", "type", "listeners", "listener", "options", "list", "callback", "event", "result", "once", "detail", "isStartable", "obj", "start", "objs", "startables", "s", "stop", "serviceCapabilities", "serviceDependencies"]
 }
diff --git a/node_modules/@libp2p/interface/dist/src/keys.d.ts b/node_modules/@libp2p/interface/dist/src/keys.d.ts
index 4ef0c0d..f899d78 100644
--- a/node_modules/@libp2p/interface/dist/src/keys.d.ts
+++ b/node_modules/@libp2p/interface/dist/src/keys.d.ts
@@ -1,6 +1,7 @@
 import type { CID } from 'multiformats/cid';
 import type { MultihashDigest } from 'multiformats/hashes/interface';
 import type { Uint8ArrayList } from 'uint8arraylist';
+import type { AbortOptions } from './index.ts';
 export type KeyType = 'RSA' | 'Ed25519' | 'secp256k1' | 'ECDSA';
 export interface RSAPublicKey {
     /**
@@ -36,7 +37,7 @@ export interface RSAPublicKey {
      * Verify the passed data was signed by the private key corresponding to this
      * public key
      */
-    verify(data: Uint8Array | Uint8ArrayList, sig: Uint8Array): boolean | Promise<boolean>;
+    verify(data: Uint8Array | Uint8ArrayList, sig: Uint8Array, options?: AbortOptions): boolean | Promise<boolean>;
     /**
      * Returns this key as a multihash with base58btc encoding
      */
@@ -71,7 +72,7 @@ export interface Ed25519PublicKey {
      * Verify the passed data was signed by the private key corresponding to this
      * public key
      */
-    verify(data: Uint8Array | Uint8ArrayList, sig: Uint8Array): boolean | Promise<boolean>;
+    verify(data: Uint8Array | Uint8ArrayList, sig: Uint8Array, options?: AbortOptions): boolean | Promise<boolean>;
     /**
      * Returns this key as a multihash with base58btc encoding
      */
@@ -106,7 +107,7 @@ export interface Secp256k1PublicKey {
      * Verify the passed data was signed by the private key corresponding to this
      * public key
      */
-    verify(data: Uint8Array | Uint8ArrayList, sig: Uint8Array): boolean | Promise<boolean>;
+    verify(data: Uint8Array | Uint8ArrayList, sig: Uint8Array, options?: AbortOptions): boolean | Promise<boolean>;
     /**
      * Returns this key as a multihash with base58btc encoding
      */
@@ -145,7 +146,7 @@ export interface ECDSAPublicKey {
      * Verify the passed data was signed by the private key corresponding to this
      * public key
      */
-    verify(data: Uint8Array | Uint8ArrayList, sig: Uint8Array): boolean | Promise<boolean>;
+    verify(data: Uint8Array | Uint8ArrayList, sig: Uint8Array, options?: AbortOptions): boolean | Promise<boolean>;
     /**
      * Returns this key as a multihash with base58btc encoding
      */
@@ -185,7 +186,7 @@ export interface RSAPrivateKey {
      * Sign the passed data with this private key and return the signature for
      * later verification
      */
-    sign(data: Uint8Array | Uint8ArrayList): Uint8Array | Promise<Uint8Array>;
+    sign(data: Uint8Array | Uint8ArrayList, options?: AbortOptions): Uint8Array | Promise<Uint8Array>;
 }
 export interface Ed25519PrivateKey {
     /**
@@ -208,7 +209,7 @@ export interface Ed25519PrivateKey {
      * Sign the passed data with this private key and return the signature for
      * later verification
      */
-    sign(data: Uint8Array | Uint8ArrayList): Uint8Array | Promise<Uint8Array>;
+    sign(data: Uint8Array | Uint8ArrayList, options?: AbortOptions): Uint8Array | Promise<Uint8Array>;
 }
 export interface Secp256k1PrivateKey {
     /**
@@ -231,7 +232,7 @@ export interface Secp256k1PrivateKey {
      * Sign the passed data with this private key and return the signature for
      * later verification
      */
-    sign(data: Uint8Array | Uint8ArrayList): Uint8Array | Promise<Uint8Array>;
+    sign(data: Uint8Array | Uint8ArrayList, options?: AbortOptions): Uint8Array | Promise<Uint8Array>;
 }
 export interface ECDSAPrivateKey {
     /**
@@ -258,7 +259,7 @@ export interface ECDSAPrivateKey {
      * Sign the passed data with this private key and return the signature for
      * later verification
      */
-    sign(data: Uint8Array | Uint8ArrayList): Uint8Array | Promise<Uint8Array>;
+    sign(data: Uint8Array | Uint8ArrayList, options?: AbortOptions): Uint8Array | Promise<Uint8Array>;
 }
 export type PrivateKey = RSAPrivateKey | Ed25519PrivateKey | Secp256k1PrivateKey | ECDSAPrivateKey;
 /**
diff --git a/node_modules/@libp2p/interface/dist/src/keys.d.ts.map b/node_modules/@libp2p/interface/dist/src/keys.d.ts.map
index ae33a81..1d69d39 100644
--- a/node_modules/@libp2p/interface/dist/src/keys.d.ts.map
+++ b/node_modules/@libp2p/interface/dist/src/keys.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"keys.d.ts","sourceRoot":"","sources":["../../src/keys.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"keys.d.ts","sourceRoot":"","sources":["../../src/keys.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@libp2p/interface/dist/src/keys.js.map b/node_modules/@libp2p/interface/dist/src/keys.js.map
index 525e179..05b0618 100644
--- a/node_modules/@libp2p/interface/dist/src/keys.js.map
+++ b/node_modules/@libp2p/interface/dist/src/keys.js.map
@@ -1 +1 @@
-{"version":3,"file":"keys.js","sourceRoot":"","sources":["../../src/keys.ts"],"names":[],"mappings":"AA2LA;;;GAGG;AACH,MAAM,UAAU,WAAW,CAAE,GAAS;IACpC,IAAI,GAAG,IAAI,IAAI,EAAE,CAAC;QAChB,OAAO,KAAK,CAAA;IACd,CAAC;IAED,OAAO,CAAC,GAAG,CAAC,IAAI,KAAK,KAAK,IAAI,GAAG,CAAC,IAAI,KAAK,SAAS,IAAI,GAAG,CAAC,IAAI,KAAK,WAAW,IAAI,GAAG,CAAC,IAAI,KAAK,OAAO,CAAC;QACvG,GAAG,CAAC,GAAG,YAAY,UAAU;QAC7B,OAAO,GAAG,CAAC,MAAM,KAAK,UAAU;QAChC,OAAO,GAAG,CAAC,WAAW,KAAK,UAAU;QACrC,OAAO,GAAG,CAAC,KAAK,KAAK,UAAU;QAC/B,OAAO,GAAG,CAAC,MAAM,KAAK,UAAU,CAAA;AACpC,CAAC;AAiID;;;GAGG;AACH,MAAM,UAAU,YAAY,CAAE,GAAS;IACrC,IAAI,GAAG,IAAI,IAAI,EAAE,CAAC;QAChB,OAAO,KAAK,CAAA;IACd,CAAC;IAED,OAAO,CAAC,GAAG,CAAC,IAAI,KAAK,KAAK,IAAI,GAAG,CAAC,IAAI,KAAK,SAAS,IAAI,GAAG,CAAC,IAAI,KAAK,WAAW,IAAI,GAAG,CAAC,IAAI,KAAK,OAAO,CAAC;QACvG,WAAW,CAAC,GAAG,CAAC,SAAS,CAAC;QAC1B,GAAG,CAAC,GAAG,YAAY,UAAU;QAC7B,OAAO,GAAG,CAAC,MAAM,KAAK,UAAU;QAChC,OAAO,GAAG,CAAC,IAAI,KAAK,UAAU,CAAA;AAClC,CAAC"}
\ No newline at end of file
+{"version":3,"file":"keys.js","sourceRoot":"","sources":["../../src/keys.ts"],"names":[],"mappings":"AA4LA;;;GAGG;AACH,MAAM,UAAU,WAAW,CAAE,GAAS;IACpC,IAAI,GAAG,IAAI,IAAI,EAAE,CAAC;QAChB,OAAO,KAAK,CAAA;IACd,CAAC;IAED,OAAO,CAAC,GAAG,CAAC,IAAI,KAAK,KAAK,IAAI,GAAG,CAAC,IAAI,KAAK,SAAS,IAAI,GAAG,CAAC,IAAI,KAAK,WAAW,IAAI,GAAG,CAAC,IAAI,KAAK,OAAO,CAAC;QACvG,GAAG,CAAC,GAAG,YAAY,UAAU;QAC7B,OAAO,GAAG,CAAC,MAAM,KAAK,UAAU;QAChC,OAAO,GAAG,CAAC,WAAW,KAAK,UAAU;QACrC,OAAO,GAAG,CAAC,KAAK,KAAK,UAAU;QAC/B,OAAO,GAAG,CAAC,MAAM,KAAK,UAAU,CAAA;AACpC,CAAC;AAiID;;;GAGG;AACH,MAAM,UAAU,YAAY,CAAE,GAAS;IACrC,IAAI,GAAG,IAAI,IAAI,EAAE,CAAC;QAChB,OAAO,KAAK,CAAA;IACd,CAAC;IAED,OAAO,CAAC,GAAG,CAAC,IAAI,KAAK,KAAK,IAAI,GAAG,CAAC,IAAI,KAAK,SAAS,IAAI,GAAG,CAAC,IAAI,KAAK,WAAW,IAAI,GAAG,CAAC,IAAI,KAAK,OAAO,CAAC;QACvG,WAAW,CAAC,GAAG,CAAC,SAAS,CAAC;QAC1B,GAAG,CAAC,GAAG,YAAY,UAAU;QAC7B,OAAO,GAAG,CAAC,MAAM,KAAK,UAAU;QAChC,OAAO,GAAG,CAAC,IAAI,KAAK,UAAU,CAAA;AAClC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@libp2p/interface/dist/src/peer-store.d.ts b/node_modules/@libp2p/interface/dist/src/peer-store.d.ts
index d5d41a5..fbf6fe0 100644
--- a/node_modules/@libp2p/interface/dist/src/peer-store.d.ts
+++ b/node_modules/@libp2p/interface/dist/src/peer-store.d.ts
@@ -1,3 +1,4 @@
+import type { AbortOptions } from './index.ts';
 import type { PublicKey } from './keys.js';
 import type { PeerId } from './peer-id.js';
 import type { PeerInfo } from './peer-info.js';
@@ -129,12 +130,15 @@ export interface PeerQueryOrder {
 /**
  * A query for getting lists of peers
  */
-export interface PeerQuery {
+export interface PeerQuery extends AbortOptions {
     filters?: PeerQueryFilter[];
     orders?: PeerQueryOrder[];
     limit?: number;
     offset?: number;
 }
+export interface ConsumePeerRecordOptions extends AbortOptions {
+    expectedPeer?: PeerId;
+}
 export interface PeerStore {
     /**
      * Loop over every peer - the looping is async because we read from a
@@ -180,7 +184,7 @@ export interface PeerStore {
      * // []
      * ```
      */
-    delete(peerId: PeerId): Promise<void>;
+    delete(peerId: PeerId, options?: AbortOptions): Promise<void>;
     /**
      * Returns true if the passed PeerId is in the peer store
      *
@@ -194,7 +198,7 @@ export interface PeerStore {
      * // true
      * ```
      */
-    has(peerId: PeerId): Promise<boolean>;
+    has(peerId: PeerId, options?: AbortOptions): Promise<boolean>;
     /**
      * Returns all data stored for the passed PeerId
      *
@@ -205,7 +209,7 @@ export interface PeerStore {
      * // { .. }
      * ```
      */
-    get(peerId: PeerId): Promise<Peer>;
+    get(peerId: PeerId, options?: AbortOptions): Promise<Peer>;
     /**
      * Returns a PeerInfo object for the passed peer id. This is similar to `get`
      * except the returned value contains fewer fields and is often used to
@@ -230,7 +234,7 @@ export interface PeerStore {
      * // }
      * ```
      */
-    getInfo(peerId: PeerId): Promise<PeerInfo>;
+    getInfo(peerId: PeerId, options?: AbortOptions): Promise<PeerInfo>;
     /**
      * Adds a peer to the peer store, overwriting any existing data
      *
@@ -242,7 +246,7 @@ export interface PeerStore {
      * })
      * ```
      */
-    save(id: PeerId, data: PeerData): Promise<Peer>;
+    save(id: PeerId, data: PeerData, options?: AbortOptions): Promise<Peer>;
     /**
      * Adds a peer to the peer store, overwriting only the passed fields
      *
@@ -254,7 +258,7 @@ export interface PeerStore {
      * })
      * ```
      */
-    patch(id: PeerId, data: PeerData): Promise<Peer>;
+    patch(id: PeerId, data: PeerData, options?: AbortOptions): Promise<Peer>;
     /**
      * Adds a peer to the peer store, deeply merging any existing data.
      *
@@ -266,7 +270,7 @@ export interface PeerStore {
      * })
      * ```
      */
-    merge(id: PeerId, data: PeerData): Promise<Peer>;
+    merge(id: PeerId, data: PeerData, options?: AbortOptions): Promise<Peer>;
     /**
      * Unmarshal and verify a signed peer record, extract the multiaddrs and
      * overwrite the stored addresses for the peer.
@@ -280,6 +284,10 @@ export interface PeerStore {
      * await peerStore.consumePeerRecord(buf, expectedPeer)
      * ```
      */
-    consumePeerRecord(buf: Uint8Array, expectedPeer?: PeerId): Promise<boolean>;
+    consumePeerRecord(buf: Uint8Array, options?: ConsumePeerRecordOptions): Promise<boolean>;
+    /**
+     * @deprecated Pass `expectedPeer` as a property of `options` instead
+     */
+    consumePeerRecord(buf: Uint8Array, expectedPeer?: PeerId, options?: AbortOptions): Promise<boolean>;
 }
 //# sourceMappingURL=peer-store.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@libp2p/interface/dist/src/peer-store.d.ts.map b/node_modules/@libp2p/interface/dist/src/peer-store.d.ts.map
index 9a4a23a..8528c16 100644
--- a/node_modules/@libp2p/interface/dist/src/peer-store.d.ts.map
+++ b/node_modules/@libp2p/interface/dist/src/peer-store.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"peer-store.d.ts","sourceRoot":"","sources":["../../src/peer-store.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,SAAS,EAAE,MAAM,WAAW,CAAA;AAC1C,OAAO,KAAK,EAAE,MAAM,EAAE,MAAM,cAAc,CAAA;AAC1C,OAAO,KAAK,EAAE,QAAQ,EAAE,MAAM,gBAAgB,CAAA;AAC9C,OAAO,KAAK,EAAE,SAAS,EAAE,MAAM,yBAAyB,CAAA;AAExD;;;;;;;GAOG;AACH,eAAO,MAAM,UAAU,eAAe,CAAA;AAEtC;;GAEG;AACH,MAAM,WAAW,OAAO;IACtB;;OAEG;IACH,SAAS,EAAE,SAAS,CAAA;IAEpB;;OAEG;IACH,WAAW,EAAE,OAAO,CAAA;CACrB;AAED;;GAEG;AACH,MAAM,WAAW,IAAI;IACnB;;OAEG;IACH,EAAE,EAAE,MAAM,CAAA;IAEV;;;OAGG;IACH,SAAS,EAAE,OAAO,EAAE,CAAA;IAEpB;;OAEG;IACH,SAAS,EAAE,MAAM,EAAE,CAAA;IAEnB;;OAEG;IACH,QAAQ,EAAE,GAAG,CAAC,MAAM,EAAE,UAAU,CAAC,CAAA;IAEjC;;OAEG;IACH,IAAI,EAAE,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,CAAA;IAEtB;;OAEG;IACH,kBAAkB,CAAC,EAAE,UAAU,CAAA;CAChC;AAED;;GAEG;AACH,MAAM,WAAW,QAAQ;IACvB;;;;;;;OAOG;IACH,SAAS,CAAC,EAAE,OAAO,EAAE,CAAA;IAErB;;;;;;OAMG;IACH,UAAU,CAAC,EAAE,SAAS,EAAE,CAAA;IAExB;;OAEG;IACH,SAAS,CAAC,EAAE,MAAM,EAAE,CAAA;IAEpB;;OAEG;IACH,QAAQ,CAAC,EAAE,GAAG,CAAC,MAAM,EAAE,UAAU,GAAG,SAAS,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,UAAU,GAAG,SAAS,CAAC,CAAA;IAEvF;;OAEG;IACH,IAAI,CAAC,EAAE,GAAG,CAAC,MAAM,EAAE,UAAU,GAAG,SAAS,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,UAAU,GAAG,SAAS,CAAC,CAAA;IAEnF;;;;OAIG;IACH,SAAS,CAAC,EAAE,SAAS,CAAA;IAErB;;OAEG;IACH,kBAAkB,CAAC,EAAE,UAAU,CAAA;CAChC;AAED,MAAM,WAAW,UAAU;IACzB;;OAEG;IACH,KAAK,CAAC,EAAE,MAAM,CAAA;IAEd;;OAEG;IACH,GAAG,CAAC,EAAE,MAAM,CAAA;CACb;AAED,MAAM,WAAW,GAAG;IAClB;;OAEG;IACH,KAAK,EAAE,MAAM,CAAA;CACd;AAED;;GAEG;AACH,MAAM,WAAW,eAAe;IAAG,CAAC,IAAI,EAAE,IAAI,GAAG,OAAO,CAAA;CAAE;AAE1D;;GAEG;AACH,MAAM,WAAW,cAAc;IAAG,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAA;CAAE;AAElE;;GAEG;AACH,MAAM,WAAW,SAAS;IACxB,OAAO,CAAC,EAAE,eAAe,EAAE,CAAA;IAC3B,MAAM,CAAC,EAAE,cAAc,EAAE,CAAA;IACzB,KAAK,CAAC,EAAE,MAAM,CAAA;IACd,MAAM,CAAC,EAAE,MAAM,CAAA;CAChB;AAED,MAAM,WAAW,SAAS;IACxB;;;;;;;;;;;;;;OAcG;IACH,OAAO,CAAC,EAAE,EAAE,CAAC,IAAI,EAAE,IAAI,KAAK,IAAI,EAAE,KAAK,CAAC,EAAE,SAAS,GAAG,OAAO,CAAC,IAAI,CAAC,CAAA;IAEnE;;;;;;;;;;OAUG;IACH,GAAG,CAAC,KAAK,CAAC,EAAE,SAAS,GAAG,OAAO,CAAC,IAAI,EAAE,CAAC,CAAA;IAEvC;;;;;;;;;;;;;;;OAeG;IACH,MAAM,CAAC,MAAM,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC,CAAA;IAErC;;;;;;;;;;;;OAYG;IACH,GAAG,CAAC,MAAM,EAAE,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,CAAA;IAErC;;;;;;;;;OASG;IACH,GAAG,CAAC,MAAM,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC,CAAA;IAElC;;;;;;;;;;;;;;;;;;;;;;;OAuBG;IACH,OAAO,CAAE,MAAM,EAAE,MAAM,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAA;IAE3C;;;;;;;;;;OAUG;IACH,IAAI,CAAC,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,QAAQ,GAAG,OAAO,CAAC,IAAI,CAAC,CAAA;IAE/C;;;;;;;;;;OAUG;IACH,KAAK,CAAC,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,QAAQ,GAAG,OAAO,CAAC,IAAI,CAAC,CAAA;IAEhD;;;;;;;;;;OAUG;IACH,KAAK,CAAC,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,QAAQ,GAAG,OAAO,CAAC,IAAI,CAAC,CAAA;IAEhD;;;;;;;;;;;;OAYG;IACH,iBAAiB,CAAC,GAAG,EAAE,UAAU,EAAE,YAAY,CAAC,EAAE,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,CAAA;CAC5E"}
\ No newline at end of file
+{"version":3,"file":"peer-store.d.ts","sourceRoot":"","sources":["../../src/peer-store.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@libp2p/interface/dist/src/peer-store.js.map b/node_modules/@libp2p/interface/dist/src/peer-store.js.map
index 0ad9033..2cdbe92 100644
--- a/node_modules/@libp2p/interface/dist/src/peer-store.js.map
+++ b/node_modules/@libp2p/interface/dist/src/peer-store.js.map
@@ -1 +1 @@
-{"version":3,"file":"peer-store.js","sourceRoot":"","sources":["../../src/peer-store.ts"],"names":[],"mappings":"AAKA;;;;;;;GAOG;AACH,MAAM,CAAC,MAAM,UAAU,GAAG,YAAY,CAAA"}
\ No newline at end of file
+{"version":3,"file":"peer-store.js","sourceRoot":"","sources":["../../src/peer-store.ts"],"names":[],"mappings":"AAMA;;;;;;;GAOG;AACH,MAAM,CAAC,MAAM,UAAU,GAAG,YAAY,CAAA"}
\ No newline at end of file
diff --git a/node_modules/@libp2p/interface/dist/src/stream-handler.d.ts b/node_modules/@libp2p/interface/dist/src/stream-handler.d.ts
index 01a8cb1..e65379d 100644
--- a/node_modules/@libp2p/interface/dist/src/stream-handler.d.ts
+++ b/node_modules/@libp2p/interface/dist/src/stream-handler.d.ts
@@ -1,4 +1,5 @@
 import type { Connection, Stream } from './connection.js';
+import type { AbortOptions } from './index.ts';
 export interface IncomingStreamData {
     /**
      * The newly opened stream
@@ -15,7 +16,7 @@ export interface StreamHandler {
      */
     (data: IncomingStreamData): void;
 }
-export interface StreamHandlerOptions {
+export interface StreamHandlerOptions extends AbortOptions {
     /**
      * How many incoming streams can be open for this protocol at the same time on each connection
      *
diff --git a/node_modules/@libp2p/interface/dist/src/stream-handler.d.ts.map b/node_modules/@libp2p/interface/dist/src/stream-handler.d.ts.map
index 7002c2a..3584386 100644
--- a/node_modules/@libp2p/interface/dist/src/stream-handler.d.ts.map
+++ b/node_modules/@libp2p/interface/dist/src/stream-handler.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"stream-handler.d.ts","sourceRoot":"","sources":["../../src/stream-handler.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,UAAU,EAAE,MAAM,EAAE,MAAM,iBAAiB,CAAA;AAEzD,MAAM,WAAW,kBAAkB;IACjC;;OAEG;IACH,MAAM,EAAE,MAAM,CAAA;IAEd;;OAEG;IACH,UAAU,EAAE,UAAU,CAAA;CACvB;AAED,MAAM,WAAW,aAAa;IAC5B;;OAEG;IACH,CAAC,IAAI,EAAE,kBAAkB,GAAG,IAAI,CAAA;CACjC;AAED,MAAM,WAAW,oBAAoB;IACnC;;;;OAIG;IACH,iBAAiB,CAAC,EAAE,MAAM,CAAA;IAE1B;;;;OAIG;IACH,kBAAkB,CAAC,EAAE,MAAM,CAAA;IAE3B;;;OAGG;IACH,sBAAsB,CAAC,EAAE,OAAO,CAAA;IAEhC;;;OAGG;IACH,KAAK,CAAC,EAAE,IAAI,CAAA;CACb;AAED,MAAM,WAAW,mBAAmB;IAClC;;OAEG;IACH,OAAO,EAAE,aAAa,CAAA;IAEtB;;OAEG;IACH,OAAO,EAAE,oBAAoB,CAAA;CAC9B"}
\ No newline at end of file
+{"version":3,"file":"stream-handler.d.ts","sourceRoot":"","sources":["../../src/stream-handler.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,UAAU,EAAE,MAAM,EAAE,MAAM,iBAAiB,CAAA;AACzD,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,YAAY,CAAA;AAE9C,MAAM,WAAW,kBAAkB;IACjC;;OAEG;IACH,MAAM,EAAE,MAAM,CAAA;IAEd;;OAEG;IACH,UAAU,EAAE,UAAU,CAAA;CACvB;AAED,MAAM,WAAW,aAAa;IAC5B;;OAEG;IACH,CAAC,IAAI,EAAE,kBAAkB,GAAG,IAAI,CAAA;CACjC;AAED,MAAM,WAAW,oBAAqB,SAAQ,YAAY;IACxD;;;;OAIG;IACH,iBAAiB,CAAC,EAAE,MAAM,CAAA;IAE1B;;;;OAIG;IACH,kBAAkB,CAAC,EAAE,MAAM,CAAA;IAE3B;;;OAGG;IACH,sBAAsB,CAAC,EAAE,OAAO,CAAA;IAEhC;;;OAGG;IACH,KAAK,CAAC,EAAE,IAAI,CAAA;CACb;AAED,MAAM,WAAW,mBAAmB;IAClC;;OAEG;IACH,OAAO,EAAE,aAAa,CAAA;IAEtB;;OAEG;IACH,OAAO,EAAE,oBAAoB,CAAA;CAC9B"}
\ No newline at end of file
diff --git a/node_modules/@libp2p/interface/dist/tsconfig.tsbuildinfo b/node_modules/@libp2p/interface/dist/tsconfig.tsbuildinfo
new file mode 100644
index 0000000..815d565
--- /dev/null
+++ b/node_modules/@libp2p/interface/dist/tsconfig.tsbuildinfo
@@ -0,0 +1 @@
+{"fileNames":["../../../node_modules/typescript/lib/lib.es5.d.ts","../../../node_modules/typescript/lib/lib.es2015.d.ts","../../../node_modules/typescript/lib/lib.es2016.d.ts","../../../node_modules/typescript/lib/lib.es2017.d.ts","../../../node_modules/typescript/lib/lib.es2018.d.ts","../../../node_modules/typescript/lib/lib.es2019.d.ts","../../../node_modules/typescript/lib/lib.es2020.d.ts","../../../node_modules/typescript/lib/lib.es2021.d.ts","../../../node_modules/typescript/lib/lib.es2022.d.ts","../../../node_modules/typescript/lib/lib.es2023.d.ts","../../../node_modules/typescript/lib/lib.es2024.d.ts","../../../node_modules/typescript/lib/lib.dom.d.ts","../../../node_modules/typescript/lib/lib.dom.iterable.d.ts","../../../node_modules/typescript/lib/lib.webworker.d.ts","../../../node_modules/typescript/lib/lib.es2015.core.d.ts","../../../node_modules/typescript/lib/lib.es2015.collection.d.ts","../../../node_modules/typescript/lib/lib.es2015.generator.d.ts","../../../node_modules/typescript/lib/lib.es2015.iterable.d.ts","../../../node_modules/typescript/lib/lib.es2015.promise.d.ts","../../../node_modules/typescript/lib/lib.es2015.proxy.d.ts","../../../node_modules/typescript/lib/lib.es2015.reflect.d.ts","../../../node_modules/typescript/lib/lib.es2015.symbol.d.ts","../../../node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts","../../../node_modules/typescript/lib/lib.es2016.array.include.d.ts","../../../node_modules/typescript/lib/lib.es2016.intl.d.ts","../../../node_modules/typescript/lib/lib.es2017.arraybuffer.d.ts","../../../node_modules/typescript/lib/lib.es2017.date.d.ts","../../../node_modules/typescript/lib/lib.es2017.object.d.ts","../../../node_modules/typescript/lib/lib.es2017.sharedmemory.d.ts","../../../node_modules/typescript/lib/lib.es2017.string.d.ts","../../../node_modules/typescript/lib/lib.es2017.intl.d.ts","../../../node_modules/typescript/lib/lib.es2017.typedarrays.d.ts","../../../node_modules/typescript/lib/lib.es2018.asyncgenerator.d.ts","../../../node_modules/typescript/lib/lib.es2018.asynciterable.d.ts","../../../node_modules/typescript/lib/lib.es2018.intl.d.ts","../../../node_modules/typescript/lib/lib.es2018.promise.d.ts","../../../node_modules/typescript/lib/lib.es2018.regexp.d.ts","../../../node_modules/typescript/lib/lib.es2019.array.d.ts","../../../node_modules/typescript/lib/lib.es2019.object.d.ts","../../../node_modules/typescript/lib/lib.es2019.string.d.ts","../../../node_modules/typescript/lib/lib.es2019.symbol.d.ts","../../../node_modules/typescript/lib/lib.es2019.intl.d.ts","../../../node_modules/typescript/lib/lib.es2020.bigint.d.ts","../../../node_modules/typescript/lib/lib.es2020.date.d.ts","../../../node_modules/typescript/lib/lib.es2020.promise.d.ts","../../../node_modules/typescript/lib/lib.es2020.sharedmemory.d.ts","../../../node_modules/typescript/lib/lib.es2020.string.d.ts","../../../node_modules/typescript/lib/lib.es2020.symbol.wellknown.d.ts","../../../node_modules/typescript/lib/lib.es2020.intl.d.ts","../../../node_modules/typescript/lib/lib.es2020.number.d.ts","../../../node_modules/typescript/lib/lib.es2021.promise.d.ts","../../../node_modules/typescript/lib/lib.es2021.string.d.ts","../../../node_modules/typescript/lib/lib.es2021.weakref.d.ts","../../../node_modules/typescript/lib/lib.es2021.intl.d.ts","../../../node_modules/typescript/lib/lib.es2022.array.d.ts","../../../node_modules/typescript/lib/lib.es2022.error.d.ts","../../../node_modules/typescript/lib/lib.es2022.intl.d.ts","../../../node_modules/typescript/lib/lib.es2022.object.d.ts","../../../node_modules/typescript/lib/lib.es2022.string.d.ts","../../../node_modules/typescript/lib/lib.es2022.regexp.d.ts","../../../node_modules/typescript/lib/lib.es2023.array.d.ts","../../../node_modules/typescript/lib/lib.es2023.collection.d.ts","../../../node_modules/typescript/lib/lib.es2023.intl.d.ts","../../../node_modules/typescript/lib/lib.es2024.arraybuffer.d.ts","../../../node_modules/typescript/lib/lib.es2024.collection.d.ts","../../../node_modules/typescript/lib/lib.es2024.object.d.ts","../../../node_modules/typescript/lib/lib.es2024.promise.d.ts","../../../node_modules/typescript/lib/lib.es2024.regexp.d.ts","../../../node_modules/typescript/lib/lib.es2024.sharedmemory.d.ts","../../../node_modules/typescript/lib/lib.es2024.string.d.ts","../../../node_modules/typescript/lib/lib.decorators.d.ts","../../../node_modules/typescript/lib/lib.decorators.legacy.d.ts","../../../node_modules/multiformats/dist/src/bases/interface.d.ts","../../../node_modules/multiformats/dist/src/block/interface.d.ts","../../../node_modules/multiformats/dist/src/hashes/interface.d.ts","../../../node_modules/multiformats/dist/src/link/interface.d.ts","../../../node_modules/multiformats/dist/src/cid.d.ts","../../../node_modules/uint8arraylist/dist/src/index.d.ts","../src/keys.ts","../src/peer-id.ts","../../../node_modules/@multiformats/multiaddr/dist/src/protocols-table.d.ts","../../../node_modules/@multiformats/dns/dist/src/resolvers/dns-over-https.d.ts","../../../node_modules/@multiformats/dns/dist/src/resolvers/dns-json-over-https.d.ts","../../../node_modules/@multiformats/dns/dist/src/resolvers/index.d.ts","../../../node_modules/progress-events/dist/src/index.d.ts","../../../node_modules/@multiformats/dns/dist/src/index.d.ts","../../../node_modules/@multiformats/multiaddr/dist/src/resolvers/dnsaddr.d.ts","../../../node_modules/@multiformats/multiaddr/dist/src/resolvers/index.d.ts","../../../node_modules/@multiformats/multiaddr/dist/src/filter/multiaddr-filter.d.ts","../../../node_modules/@multiformats/multiaddr/dist/src/index.d.ts","../src/peer-info.ts","../src/content-routing.ts","../src/events.ts","../src/event-target.ts","../src/metrics.ts","../src/peer-routing.ts","../src/peer-store.ts","../src/startable.ts","../src/stream-handler.ts","../src/topology.ts","../../../node_modules/it-stream-types/dist/src/index.d.ts","../src/stream-muxer.ts","../src/transport.ts","../src/connection-gater.ts","../src/peer-discovery.ts","../../../node_modules/it-pushable/dist/src/index.d.ts","../src/pubsub.ts","../src/record.ts","../src/errors.ts","../src/index.ts","../src/connection.ts","../src/connection-encrypter.ts","../src/events.browser.ts","../../../node_modules/@babel/types/lib/index.d.ts","../../../node_modules/@types/babel__generator/index.d.ts","../../../node_modules/@babel/parser/typings/babel-parser.d.ts","../../../node_modules/@types/babel__template/index.d.ts","../../../node_modules/@types/babel__traverse/index.d.ts","../../../node_modules/@types/babel__core/index.d.ts","../../../node_modules/@types/chai/index.d.ts","../../../node_modules/@types/chai-as-promised/index.d.ts","../../../node_modules/@types/chai-string/index.d.ts","../../../node_modules/@types/chai-subset/index.d.ts","../../../node_modules/@types/ms/index.d.ts","../../../node_modules/@types/debug/index.d.ts","../../../node_modules/@types/node/compatibility/disposable.d.ts","../../../node_modules/@types/node/compatibility/indexable.d.ts","../../../node_modules/@types/node/compatibility/iterators.d.ts","../../../node_modules/@types/node/compatibility/index.d.ts","../../../node_modules/@types/node/globals.typedarray.d.ts","../../../node_modules/@types/node/buffer.buffer.d.ts","../../../node_modules/buffer/index.d.ts","../../../node_modules/undici-types/header.d.ts","../../../node_modules/undici-types/readable.d.ts","../../../node_modules/undici-types/file.d.ts","../../../node_modules/undici-types/fetch.d.ts","../../../node_modules/undici-types/formdata.d.ts","../../../node_modules/undici-types/connector.d.ts","../../../node_modules/undici-types/client.d.ts","../../../node_modules/undici-types/errors.d.ts","../../../node_modules/undici-types/dispatcher.d.ts","../../../node_modules/undici-types/global-dispatcher.d.ts","../../../node_modules/undici-types/global-origin.d.ts","../../../node_modules/undici-types/pool-stats.d.ts","../../../node_modules/undici-types/pool.d.ts","../../../node_modules/undici-types/handlers.d.ts","../../../node_modules/undici-types/balanced-pool.d.ts","../../../node_modules/undici-types/agent.d.ts","../../../node_modules/undici-types/mock-interceptor.d.ts","../../../node_modules/undici-types/mock-agent.d.ts","../../../node_modules/undici-types/mock-client.d.ts","../../../node_modules/undici-types/mock-pool.d.ts","../../../node_modules/undici-types/mock-errors.d.ts","../../../node_modules/undici-types/proxy-agent.d.ts","../../../node_modules/undici-types/env-http-proxy-agent.d.ts","../../../node_modules/undici-types/retry-handler.d.ts","../../../node_modules/undici-types/retry-agent.d.ts","../../../node_modules/undici-types/api.d.ts","../../../node_modules/undici-types/interceptors.d.ts","../../../node_modules/undici-types/util.d.ts","../../../node_modules/undici-types/cookies.d.ts","../../../node_modules/undici-types/patch.d.ts","../../../node_modules/undici-types/websocket.d.ts","../../../node_modules/undici-types/eventsource.d.ts","../../../node_modules/undici-types/filereader.d.ts","../../../node_modules/undici-types/diagnostics-channel.d.ts","../../../node_modules/undici-types/content-type.d.ts","../../../node_modules/undici-types/cache.d.ts","../../../node_modules/undici-types/index.d.ts","../../../node_modules/@types/node/globals.d.ts","../../../node_modules/@types/node/assert.d.ts","../../../node_modules/@types/node/assert/strict.d.ts","../../../node_modules/@types/node/async_hooks.d.ts","../../../node_modules/@types/node/buffer.d.ts","../../../node_modules/@types/node/child_process.d.ts","../../../node_modules/@types/node/cluster.d.ts","../../../node_modules/@types/node/console.d.ts","../../../node_modules/@types/node/constants.d.ts","../../../node_modules/@types/node/crypto.d.ts","../../../node_modules/@types/node/dgram.d.ts","../../../node_modules/@types/node/diagnostics_channel.d.ts","../../../node_modules/@types/node/dns.d.ts","../../../node_modules/@types/node/dns/promises.d.ts","../../../node_modules/@types/node/domain.d.ts","../../../node_modules/@types/node/dom-events.d.ts","../../../node_modules/@types/node/events.d.ts","../../../node_modules/@types/node/fs.d.ts","../../../node_modules/@types/node/fs/promises.d.ts","../../../node_modules/@types/node/http.d.ts","../../../node_modules/@types/node/http2.d.ts","../../../node_modules/@types/node/https.d.ts","../../../node_modules/@types/node/inspector.d.ts","../../../node_modules/@types/node/module.d.ts","../../../node_modules/@types/node/net.d.ts","../../../node_modules/@types/node/os.d.ts","../../../node_modules/@types/node/path.d.ts","../../../node_modules/@types/node/perf_hooks.d.ts","../../../node_modules/@types/node/process.d.ts","../../../node_modules/@types/node/punycode.d.ts","../../../node_modules/@types/node/querystring.d.ts","../../../node_modules/@types/node/readline.d.ts","../../../node_modules/@types/node/readline/promises.d.ts","../../../node_modules/@types/node/repl.d.ts","../../../node_modules/@types/node/sea.d.ts","../../../node_modules/@types/node/sqlite.d.ts","../../../node_modules/@types/node/stream.d.ts","../../../node_modules/@types/node/stream/promises.d.ts","../../../node_modules/@types/node/stream/consumers.d.ts","../../../node_modules/@types/node/stream/web.d.ts","../../../node_modules/@types/node/string_decoder.d.ts","../../../node_modules/@types/node/test.d.ts","../../../node_modules/@types/node/timers.d.ts","../../../node_modules/@types/node/timers/promises.d.ts","../../../node_modules/@types/node/tls.d.ts","../../../node_modules/@types/node/trace_events.d.ts","../../../node_modules/@types/node/tty.d.ts","../../../node_modules/@types/node/url.d.ts","../../../node_modules/@types/node/util.d.ts","../../../node_modules/@types/node/v8.d.ts","../../../node_modules/@types/node/vm.d.ts","../../../node_modules/@types/node/wasi.d.ts","../../../node_modules/@types/node/worker_threads.d.ts","../../../node_modules/@types/node/zlib.d.ts","../../../node_modules/@types/node/index.d.ts","../../../node_modules/@types/dns-packet/index.d.ts","../../../node_modules/@types/estree/index.d.ts","../../../node_modules/@types/graceful-fs/index.d.ts","../../../node_modules/@types/unist/index.d.ts","../../../node_modules/@types/hast/index.d.ts","../../../node_modules/@types/http-cache-semantics/index.d.ts","../../../node_modules/@types/istanbul-lib-coverage/index.d.ts","../../../node_modules/@types/istanbul-lib-report/index.d.ts","../../../node_modules/@types/istanbul-reports/index.d.ts","../../../node_modules/@types/json-schema/index.d.ts","../../../node_modules/@types/json5/index.d.ts","../../../node_modules/@types/linkify-it/build/index.cjs.d.ts","../../../node_modules/@types/linkify-it/index.d.ts","../../../node_modules/@types/lodash/common/common.d.ts","../../../node_modules/@types/lodash/common/array.d.ts","../../../node_modules/@types/lodash/common/collection.d.ts","../../../node_modules/@types/lodash/common/date.d.ts","../../../node_modules/@types/lodash/common/function.d.ts","../../../node_modules/@types/lodash/common/lang.d.ts","../../../node_modules/@types/lodash/common/math.d.ts","../../../node_modules/@types/lodash/common/number.d.ts","../../../node_modules/@types/lodash/common/object.d.ts","../../../node_modules/@types/lodash/common/seq.d.ts","../../../node_modules/@types/lodash/common/string.d.ts","../../../node_modules/@types/lodash/common/util.d.ts","../../../node_modules/@types/lodash/index.d.ts","../../../node_modules/@types/lodash.random/index.d.ts","../../../node_modules/@types/lodash.range/index.d.ts","../../../node_modules/@types/mdurl/build/index.cjs.d.ts","../../../node_modules/@types/markdown-it/dist/index.cjs.d.ts","../../../node_modules/@types/markdown-it/index.d.ts","../../../node_modules/@types/mdast/index.d.ts","../../../node_modules/@types/mdurl/index.d.ts","../../../node_modules/@types/minimatch/index.d.ts","../../../node_modules/@types/minimist/index.d.ts","../../../node_modules/@types/mocha/index.d.ts","../../../node_modules/@types/multicast-dns/index.d.ts","../../../node_modules/@types/netmask/index.d.ts","../../../node_modules/@types/normalize-package-data/index.d.ts","../../../node_modules/@types/parse-json/index.d.ts","../../../node_modules/@types/retry/index.d.ts","../../../node_modules/@types/sinonjs__fake-timers/index.d.ts","../../../node_modules/@types/sinon/index.d.ts","../../../node_modules/@types/stack-utils/index.d.ts","../../../node_modules/@types/strip-bom/index.d.ts","../../../node_modules/@types/strip-json-comments/index.d.ts","../../../node_modules/@types/tdigest/index.d.ts","../../../node_modules/@types/which/index.d.ts","../../../node_modules/@types/ws/index.d.ts","../../../node_modules/@types/xsalsa20/index.d.ts","../../../node_modules/@types/yargs-parser/index.d.ts","../../../node_modules/@types/yargs/index.d.ts","../../../node_modules/@types/yauzl/index.d.ts"],"fileIdsList":[[114,131,174],[131,174],[84,85,131,174],[84,131,174],[82,83,86,131,174],[90,131,174],[81,86,88,89,131,174],[86,88,90,131,174],[87,90,131,174],[114,115,116,117,118,131,174],[114,116,131,174],[120,131,174],[124,131,174],[131,174,224],[131,174,187,224],[131,174,228],[131,174,231],[131,174,232],[131,174,236],[131,174,250],[131,174,238,240,241,242,243,244,245,246,247,248,249,250],[131,174,238,239,241,242,243,244,245,246,247,248,249,250],[131,174,239,240,241,242,243,244,245,246,247,248,249,250],[131,174,238,239,240,242,243,244,245,246,247,248,249,250],[131,174,238,239,240,241,243,244,245,246,247,248,249,250],[131,174,238,239,240,241,242,244,245,246,247,248,249,250],[131,174,238,239,240,241,242,243,245,246,247,248,249,250],[131,174,238,239,240,241,242,243,244,246,247,248,249,250],[131,174,238,239,240,241,242,243,244,245,247,248,249,250],[131,174,238,239,240,241,242,243,244,245,246,248,249,250],[131,174,238,239,240,241,242,243,244,245,246,247,249,250],[131,174,238,239,240,241,242,243,244,245,246,247,248,250],[131,174,238,239,240,241,242,243,244,245,246,247,248,249],[131,174,236,253],[131,174,254],[131,174,253],[131,174,180,186,224,225],[131,171,174],[131,173,174],[174],[131,174,179,209],[131,174,175,180,186,187,194,206,217],[131,174,175,176,186,194],[126,127,128,131,174],[131,174,177,218],[131,174,178,179,187,195],[131,174,179,206,214],[131,174,180,182,186,194],[131,173,174,181],[131,174,182,183],[131,174,186],[131,174,184,186],[131,173,174,186],[131,174,186,187,188,206,217],[131,174,186,187,188,201,206,209],[131,169,174,222],[131,169,174,182,186,189,194,206,217],[131,174,186,187,189,190,194,206,214,217],[131,174,189,191,206,214,217],[129,130,131,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223],[131,174,186,192],[131,174,193,217],[131,174,182,186,194,206],[131,174,195],[131,174,196],[131,173,174,197],[131,171,172,173,174,175,176,177,178,179,180,181,182,183,184,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223],[131,174,199],[131,174,200],[131,174,186,201,202],[131,174,201,203,218,220],[131,174,186,206,207,209],[131,174,208,209],[131,174,206,207],[131,174,209],[131,174,210],[131,171,174,206],[131,174,186,212,213],[131,174,212,213],[131,174,179,194,206,214],[131,174,215],[131,174,194,216],[131,174,189,200,217],[131,174,179,218],[131,174,206,219],[131,174,193,220],[131,174,221],[131,174,179,186,188,197,206,217,220,222],[131,174,206,223],[131,174,266],[131,174,186,189,191,194,206,214,217,223,224],[131,174,275],[131,174,186,206,224],[76,77,131,174],[76,131,174],[73,74,75,131,174],[131,141,145,174,217],[131,141,174,206,217],[131,136,174],[131,138,141,174,214,217],[131,174,194,214],[131,136,174,224],[131,138,141,174,194,217],[131,133,134,137,140,174,186,206,217],[131,141,148,174],[131,133,139,174],[131,141,162,163,174],[131,137,141,174,209,217,224],[131,162,174,224],[131,135,136,174,224],[131,141,174],[131,135,136,137,138,139,140,141,142,143,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,163,164,165,166,167,168,174],[131,141,156,174],[131,141,148,149,174],[131,139,141,149,150,174],[131,140,174],[131,133,136,141,174],[131,141,145,149,150,174],[131,145,174],[131,139,141,144,174,217],[131,133,138,141,148,174],[131,174,206],[131,136,141,162,174,222,224],[78,80,101,110,111,131,174],[80,90,111,131,174],[78,80,90,101,110,131,174],[77,91,110,131,174],[93,131,174],[79,80,85,90,91,92,93,94,95,96,97,98,99,100,102,103,104,105,107,108,109,111,112,131,174],[75,77,78,110,131,174],[111,131,174],[91,94,131,174],[75,77,79,131,174],[80,90,131,174],[80,91,110,131,174],[79,80,90,91,110,131,174],[78,79,80,94,106,111,131,174],[78,79,131,174],[110,111,131,174],[78,101,110,111,131,174],[80,111,131,174],[85,90,94,102,110,111,131,174]],"fileInfos":[{"version":"69684132aeb9b5642cbcd9e22dff7818ff0ee1aa831728af0ecf97d3364d5546","affectsGlobalScope":true,"impliedFormat":1},{"version":"45b7ab580deca34ae9729e97c13cfd999df04416a79116c3bfb483804f85ded4","impliedFormat":1},{"version":"3facaf05f0c5fc569c5649dd359892c98a85557e3e0c847964caeb67076f4d75","impliedFormat":1},{"version":"e44bb8bbac7f10ecc786703fe0a6a4b952189f908707980ba8f3c8975a760962","impliedFormat":1},{"version":"5e1c4c362065a6b95ff952c0eab010f04dcd2c3494e813b493ecfd4fcb9fc0d8","impliedFormat":1},{"version":"68d73b4a11549f9c0b7d352d10e91e5dca8faa3322bfb77b661839c42b1ddec7","impliedFormat":1},{"version":"5efce4fc3c29ea84e8928f97adec086e3dc876365e0982cc8479a07954a3efd4","impliedFormat":1},{"version":"feecb1be483ed332fad555aff858affd90a48ab19ba7272ee084704eb7167569","impliedFormat":1},{"version":"ee7bad0c15b58988daa84371e0b89d313b762ab83cb5b31b8a2d1162e8eb41c2","impliedFormat":1},{"version":"27bdc30a0e32783366a5abeda841bc22757c1797de8681bbe81fbc735eeb1c10","impliedFormat":1},{"version":"8fd575e12870e9944c7e1d62e1f5a73fcf23dd8d3a321f2a2c74c20d022283fe","impliedFormat":1},{"version":"092c2bfe125ce69dbb1223c85d68d4d2397d7d8411867b5cc03cec902c233763","affectsGlobalScope":true,"impliedFormat":1},{"version":"07f073f19d67f74d732b1adea08e1dc66b1b58d77cb5b43931dee3d798a2fd53","affectsGlobalScope":true,"impliedFormat":1},{"version":"8ea22b76493fc658fe9b76a84e64c9618823608076ecee5ed3f93f7f0dde904e","affectsGlobalScope":true,"impliedFormat":1},{"version":"c57796738e7f83dbc4b8e65132f11a377649c00dd3eee333f672b8f0a6bea671","affectsGlobalScope":true,"impliedFormat":1},{"version":"dc2df20b1bcdc8c2d34af4926e2c3ab15ffe1160a63e58b7e09833f616efff44","affectsGlobalScope":true,"impliedFormat":1},{"version":"515d0b7b9bea2e31ea4ec968e9edd2c39d3eebf4a2d5cbd04e88639819ae3b71","affectsGlobalScope":true,"impliedFormat":1},{"version":"0559b1f683ac7505ae451f9a96ce4c3c92bdc71411651ca6ddb0e88baaaad6a3","affectsGlobalScope":true,"impliedFormat":1},{"version":"0dc1e7ceda9b8b9b455c3a2d67b0412feab00bd2f66656cd8850e8831b08b537","affectsGlobalScope":true,"impliedFormat":1},{"version":"ce691fb9e5c64efb9547083e4a34091bcbe5bdb41027e310ebba8f7d96a98671","affectsGlobalScope":true,"impliedFormat":1},{"version":"8d697a2a929a5fcb38b7a65594020fcef05ec1630804a33748829c5ff53640d0","affectsGlobalScope":true,"impliedFormat":1},{"version":"4ff2a353abf8a80ee399af572debb8faab2d33ad38c4b4474cff7f26e7653b8d","affectsGlobalScope":true,"impliedFormat":1},{"version":"936e80ad36a2ee83fc3caf008e7c4c5afe45b3cf3d5c24408f039c1d47bdc1df","affectsGlobalScope":true,"impliedFormat":1},{"version":"d15bea3d62cbbdb9797079416b8ac375ae99162a7fba5de2c6c505446486ac0a","affectsGlobalScope":true,"impliedFormat":1},{"version":"68d18b664c9d32a7336a70235958b8997ebc1c3b8505f4f1ae2b7e7753b87618","affectsGlobalScope":true,"impliedFormat":1},{"version":"eb3d66c8327153d8fa7dd03f9c58d351107fe824c79e9b56b462935176cdf12a","affectsGlobalScope":true,"impliedFormat":1},{"version":"38f0219c9e23c915ef9790ab1d680440d95419ad264816fa15009a8851e79119","affectsGlobalScope":true,"impliedFormat":1},{"version":"69ab18c3b76cd9b1be3d188eaf8bba06112ebbe2f47f6c322b5105a6fbc45a2e","affectsGlobalScope":true,"impliedFormat":1},{"version":"fef8cfad2e2dc5f5b3d97a6f4f2e92848eb1b88e897bb7318cef0e2820bceaab","affectsGlobalScope":true,"impliedFormat":1},{"version":"2f11ff796926e0832f9ae148008138ad583bd181899ab7dd768a2666700b1893","affectsGlobalScope":true,"impliedFormat":1},{"version":"4de680d5bb41c17f7f68e0419412ca23c98d5749dcaaea1896172f06435891fc","affectsGlobalScope":true,"impliedFormat":1},{"version":"954296b30da6d508a104a3a0b5d96b76495c709785c1d11610908e63481ee667","affectsGlobalScope":true,"impliedFormat":1},{"version":"ac9538681b19688c8eae65811b329d3744af679e0bdfa5d842d0e32524c73e1c","affectsGlobalScope":true,"impliedFormat":1},{"version":"0a969edff4bd52585473d24995c5ef223f6652d6ef46193309b3921d65dd4376","affectsGlobalScope":true,"impliedFormat":1},{"version":"9e9fbd7030c440b33d021da145d3232984c8bb7916f277e8ffd3dc2e3eae2bdb","affectsGlobalScope":true,"impliedFormat":1},{"version":"811ec78f7fefcabbda4bfa93b3eb67d9ae166ef95f9bff989d964061cbf81a0c","affectsGlobalScope":true,"impliedFormat":1},{"version":"717937616a17072082152a2ef351cb51f98802fb4b2fdabd32399843875974ca","affectsGlobalScope":true,"impliedFormat":1},{"version":"d7e7d9b7b50e5f22c915b525acc5a49a7a6584cf8f62d0569e557c5cfc4b2ac2","affectsGlobalScope":true,"impliedFormat":1},{"version":"71c37f4c9543f31dfced6c7840e068c5a5aacb7b89111a4364b1d5276b852557","affectsGlobalScope":true,"impliedFormat":1},{"version":"576711e016cf4f1804676043e6a0a5414252560eb57de9faceee34d79798c850","affectsGlobalScope":true,"impliedFormat":1},{"version":"89c1b1281ba7b8a96efc676b11b264de7a8374c5ea1e6617f11880a13fc56dc6","affectsGlobalScope":true,"impliedFormat":1},{"version":"74f7fa2d027d5b33eb0471c8e82a6c87216223181ec31247c357a3e8e2fddc5b","affectsGlobalScope":true,"impliedFormat":1},{"version":"d6d7ae4d1f1f3772e2a3cde568ed08991a8ae34a080ff1151af28b7f798e22ca","affectsGlobalScope":true,"impliedFormat":1},{"version":"063600664504610fe3e99b717a1223f8b1900087fab0b4cad1496a114744f8df","affectsGlobalScope":true,"impliedFormat":1},{"version":"934019d7e3c81950f9a8426d093458b65d5aff2c7c1511233c0fd5b941e608ab","affectsGlobalScope":true,"impliedFormat":1},{"version":"52ada8e0b6e0482b728070b7639ee42e83a9b1c22d205992756fe020fd9f4a47","affectsGlobalScope":true,"impliedFormat":1},{"version":"3bdefe1bfd4d6dee0e26f928f93ccc128f1b64d5d501ff4a8cf3c6371200e5e6","affectsGlobalScope":true,"impliedFormat":1},{"version":"59fb2c069260b4ba00b5643b907ef5d5341b167e7d1dbf58dfd895658bda2867","affectsGlobalScope":true,"impliedFormat":1},{"version":"639e512c0dfc3fad96a84caad71b8834d66329a1f28dc95e3946c9b58176c73a","affectsGlobalScope":true,"impliedFormat":1},{"version":"368af93f74c9c932edd84c58883e736c9e3d53cec1fe24c0b0ff451f529ceab1","affectsGlobalScope":true,"impliedFormat":1},{"version":"af3dd424cf267428f30ccfc376f47a2c0114546b55c44d8c0f1d57d841e28d74","affectsGlobalScope":true,"impliedFormat":1},{"version":"995c005ab91a498455ea8dfb63aa9f83fa2ea793c3d8aa344be4a1678d06d399","affectsGlobalScope":true,"impliedFormat":1},{"version":"959d36cddf5e7d572a65045b876f2956c973a586da58e5d26cde519184fd9b8a","affectsGlobalScope":true,"impliedFormat":1},{"version":"965f36eae237dd74e6cca203a43e9ca801ce38824ead814728a2807b1910117d","affectsGlobalScope":true,"impliedFormat":1},{"version":"3925a6c820dcb1a06506c90b1577db1fdbf7705d65b62b99dce4be75c637e26b","affectsGlobalScope":true,"impliedFormat":1},{"version":"0a3d63ef2b853447ec4f749d3f368ce642264246e02911fcb1590d8c161b8005","affectsGlobalScope":true,"impliedFormat":1},{"version":"b5ce7a470bc3628408429040c4e3a53a27755022a32fd05e2cb694e7015386c7","affectsGlobalScope":true,"impliedFormat":1},{"version":"8444af78980e3b20b49324f4a16ba35024fef3ee069a0eb67616ea6ca821c47a","affectsGlobalScope":true,"impliedFormat":1},{"version":"3287d9d085fbd618c3971944b65b4be57859f5415f495b33a6adc994edd2f004","affectsGlobalScope":true,"impliedFormat":1},{"version":"b4b67b1a91182421f5df999988c690f14d813b9850b40acd06ed44691f6727ad","affectsGlobalScope":true,"impliedFormat":1},{"version":"df83c2a6c73228b625b0beb6669c7ee2a09c914637e2d35170723ad49c0f5cd4","affectsGlobalScope":true,"impliedFormat":1},{"version":"436aaf437562f276ec2ddbee2f2cdedac7664c1e4c1d2c36839ddd582eeb3d0a","affectsGlobalScope":true,"impliedFormat":1},{"version":"8e3c06ea092138bf9fa5e874a1fdbc9d54805d074bee1de31b99a11e2fec239d","affectsGlobalScope":true,"impliedFormat":1},{"version":"87dc0f382502f5bbce5129bdc0aea21e19a3abbc19259e0b43ae038a9fc4e326","affectsGlobalScope":true,"impliedFormat":1},{"version":"b1cb28af0c891c8c96b2d6b7be76bd394fddcfdb4709a20ba05a7c1605eea0f9","affectsGlobalScope":true,"impliedFormat":1},{"version":"2fef54945a13095fdb9b84f705f2b5994597640c46afeb2ce78352fab4cb3279","affectsGlobalScope":true,"impliedFormat":1},{"version":"ac77cb3e8c6d3565793eb90a8373ee8033146315a3dbead3bde8db5eaf5e5ec6","affectsGlobalScope":true,"impliedFormat":1},{"version":"56e4ed5aab5f5920980066a9409bfaf53e6d21d3f8d020c17e4de584d29600ad","affectsGlobalScope":true,"impliedFormat":1},{"version":"4ece9f17b3866cc077099c73f4983bddbcb1dc7ddb943227f1ec070f529dedd1","affectsGlobalScope":true,"impliedFormat":1},{"version":"0a6282c8827e4b9a95f4bf4f5c205673ada31b982f50572d27103df8ceb8013c","affectsGlobalScope":true,"impliedFormat":1},{"version":"8e7f8264d0fb4c5339605a15daadb037bf238c10b654bb3eee14208f860a32ea","affectsGlobalScope":true,"impliedFormat":1},{"version":"782dec38049b92d4e85c1585fbea5474a219c6984a35b004963b00beb1aab538","affectsGlobalScope":true,"impliedFormat":1},{"version":"4a3605bef1a5ef29fd5a1696dd95b0b4e2259e2d07a4d88fac79f3a9765c44a2","impliedFormat":99},{"version":"370079895f1acdd4bb5194a403c85bf60cfbb2654bced9430a6c7210e7246be8","impliedFormat":99},{"version":"90240231e730deed31569f6c686766a538e4a024bbc33ea1738fe924f477ba61","impliedFormat":99},{"version":"552223520e823223ee13c5764e9b69b1819c985818a8bcda435d8d1dbd909bee","impliedFormat":99},{"version":"49b7c3ddd683c09aa437dd92681699387441f522524b14d2331ce494a9bf2f27","impliedFormat":99},{"version":"d35b5db21a04a45ae6323c4d4b25acc983dfe2870fc670fd05249eb19d839a5e","impliedFormat":99},{"version":"366620bbfa224be12190845d6bac03dcca52816e7e0727613057b80c0793700a","signature":"197aa368373dd863eb69d976e8cae70bb4dca02ca2622907c6710faff52f2b02","impliedFormat":99},{"version":"e2349a55404a3f045e423c81701f9498da1c35c3dde48e36a6c92c851d02b5c9","signature":"72b129e625a479942a4f9e8a1bc12c45c09bbbf6ebae147418584441eb9fba18","impliedFormat":99},{"version":"5212dd78d1d63ab33332c8846a0ea5ce248159e74033cde16de48373036b4704","impliedFormat":99},{"version":"954b3c04ee9f94ca1e262f3e5a6e833b0da0066514b3d4b97b92b7f0c85f8700","impliedFormat":99},{"version":"a2fc9ce1ae5bed7068d701d8aeebf13321de0f42c217dc2e10f1622dcaa53a7f","impliedFormat":99},{"version":"8e81f220cb935d551e88cff11541d5e89d3a3494a52fe6247e98016a9dbd4c2d","impliedFormat":99},{"version":"6b2576a04253626ba41b7dc7ec5977bec07f3b6952b16249d9fa8a3a0d79901c","impliedFormat":99},{"version":"9de17491f2bfbccea92500e174079d53bdedae34dbebe5d4a12a06ab09814710","impliedFormat":99},{"version":"e88481085a8576fa52efc913e631c1a833d16179486469b8538d8c4fab2f7381","impliedFormat":99},{"version":"cc8c0bbe9fa2399c83e9f5492f82c55fe184380a371dd6fa462586c6563b054b","impliedFormat":99},{"version":"d71577e78c7a4257074aaf82f595724175210c89e8b467ef82f949a6cbd891bc","impliedFormat":99},{"version":"52e78315d331eeec07e0fabb68af969e7cdb28eafeeda17fca75897764a53f0b","impliedFormat":99},{"version":"1cb5d525b16ee479f41c1fa05a8f8cd155a98ae5ce395a058b653635d4034843","signature":"c7bdf13966d47b3b3cf9de4ce1647184717579990cc7143602f02ab224e9bfc6","impliedFormat":99},{"version":"a7eb1d433105da0bc9d89c6b38e60c9ff64ad690b75829400c9aee49ee871213","signature":"2df70ce5ac08695f7c18c4f06771ce367c12167f5868028c81912217ac87902f","impliedFormat":99},{"version":"3f9020b43de6f2c8607165262e82eaee59ec59caf943420136604f34ed08c472","signature":"6a99ac72e356885b8aab17cc8b50e63583447a1b39cd77db49916d37bd61fca2","impliedFormat":99},{"version":"fec1d4cb0c4a12cb6afb6d862f16b1738896a59e963bb3090a829915fc0f7662","signature":"31df5ef75bd58d593d86b8a6b8453f91edcfb0028619d12013df5072491f2584","impliedFormat":99},{"version":"306dfffe8d4d6961fdcd2198c91c9cdac1031c8e36170a52ac8279638c6dc0a2","signature":"f3a9711898711a33db517fd5d0749c5c73e9d23004473cd698e7e14f9a26c768","impliedFormat":99},{"version":"bd3124b8df0808a16bb3c6c0225b4fa71184b01b6bf3920c106179047a251cd3","signature":"bca17571cb28cda192676b35856905550ec82495f6f782dfb6c34b5611317f36","impliedFormat":99},{"version":"f4f627fba89df330c3458f05d9c7fafa46ef69675cb9321832b45b888384a94d","signature":"6297f414e045d1384c4483632e4bf99dd0282333a04c07519c23280684a879ad","impliedFormat":99},{"version":"4f9902e9b75af5a19451c7940478c18df4e5430c011a1088075c549a81879269","signature":"0f02789a4cd141f719fcfa7d9bb2aa01fcc88ea1ff2527884976ff0be6885d2c","impliedFormat":99},{"version":"c7a666e74c021c69a5abffe65307052eea21ab8101940acf80c899b8c4f632ed","signature":"08a5781a5e2d662e96b7f899f2f894849e1ccb1930d4fdb6e23704ba035344fa","impliedFormat":99},{"version":"30842631a0f529d07174c7e0b4a430339f7d75742876a39aea461be15ead454f","signature":"1bc5eadd83cdb0931e3ee2de0734acc9e003f44ac799b20b9673c540c8cd4373","impliedFormat":99},{"version":"c84146dbc9d2e5f43d2cbf15485a4eabf90219dbb66c0d481f20f12d3851bffc","impliedFormat":99},{"version":"65ded090fa63aa0706babe446e5ff4721efa3ea90a695197aacd2f966638dfd4","signature":"44fa41130045a0256c73b8f94d0885d1a170063b543ddf7324293b21af4b18b6","impliedFormat":99},{"version":"550bb25aa237ac60304f9b4cd32778f8ca2595f9f63a0bf4ca9a08dc23e7d5ad","signature":"7e6167b95acf6613ec23123174cb521adb4a304e649df53aaea7bf761df999c8","impliedFormat":99},{"version":"ba9cbd5649ad759d474525704df5542024260cc641d1e63a1650966a8a870437","signature":"89346453b46aeb38468711a4880156f29b1eea4eab823bd53802965b3d3fc27d","impliedFormat":99},{"version":"16158af8d99d6a04ec596f096eb995e33557df03059c1ae6793ea5fa2e8f3fed","signature":"1e271966c873756f8e1d666998c491b5dc12af5d74d533e47c5e5e279e18274e","impliedFormat":99},{"version":"fac83d4c6898d5bf90c508cc84409ded40fdc14611cf42d7fb750fb2c7847979","impliedFormat":99},{"version":"edab67d41617f12c64be2a342b905aca013a6de3fc0d2b89c6c954c1bb97453e","signature":"da80121bd71df51319f3105d60a9dac23e1e391ef3a58e223c722af526bcb3f4","impliedFormat":99},{"version":"a6e7ff1a55abe78052f07be52dc02610db2b4c9403dace464e646c3dd2f59592","signature":"30a3b1f1188c219ea516f1705f6ed50a9729981e8afffc37cd99c9282bb353c9","impliedFormat":99},{"version":"471f218819c7f4b22a6887cf013c5028918ad204ef2347b7fe0fe64010548620","signature":"c0c00b990b4f0c26f00090df7e566344fea8df23421d674c1597ea678625b961","impliedFormat":99},{"version":"ad6b24adf978df98ef4a8ab924b6eea1551867d340db38adb0e01d3ea9c90431","signature":"4e12f75592a04f1f127950507cb392ebf9a3a1178b1eead7c1a285403e837b7b","impliedFormat":99},{"version":"5a756ccc9781bfd35687385ef65ecbbaf670ffdafce432fdf1ae9e946a28b2e5","signature":"99e58b8cfcc96db650fc7ee19e343d0a51bd3359dc149f7394448c17f191a545","impliedFormat":99},{"version":"4a1ccb23537b7ee2d39e1a737d3e1d3b1ba6f3054063995be97d428f6476257f","signature":"cb367da7004cc13870f5108858262bcebbae4d57ede1506769a0f06823509050","impliedFormat":99},{"version":"ab987b128fbff1ea035d39a35673a29425639e2076aea1d1eab1aedd60e06c45","signature":"fd32d5cf13129d82f4dd788261d58f66303a4235adc8bc9ad41bb389a0ca1d20","impliedFormat":99},{"version":"d88b3dc8b7055665059ea06ffafce9467fc4bdfa7cb2d7a6f4262556bb482b0d","impliedFormat":1},{"version":"b6d03c9cfe2cf0ba4c673c209fcd7c46c815b2619fd2aad59fc4229aaef2ed43","impliedFormat":1},{"version":"32ddc6ad753ae79571bbf28cebff7a383bf7f562ac5ef5d25c94ef7f71609d49","impliedFormat":1},{"version":"670a76db379b27c8ff42f1ba927828a22862e2ab0b0908e38b671f0e912cc5ed","impliedFormat":1},{"version":"81df92841a7a12d551fcbc7e4e83dbb7d54e0c73f33a82162d13e9ae89700079","impliedFormat":1},{"version":"069bebfee29864e3955378107e243508b163e77ab10de6a5ee03ae06939f0bb9","impliedFormat":1},{"version":"eef204f061321360559bd19235ea32a9d55b3ec22a362cc78d14ef50d4db4490","affectsGlobalScope":true,"impliedFormat":1},{"version":"86e56d97b13ef0a58bc9c59aee782ae7d47d63802b5b32129ec5e5d62c20dbfa","affectsGlobalScope":true,"impliedFormat":1},{"version":"7cf1027da9599f056355b46bbea31dbf7f715f797dffb9cbb3402d4490c503e5","affectsGlobalScope":true,"impliedFormat":1},{"version":"54db406753da16e177f094aa66da79840f447de6d87ddd1543a80c9418c52545","affectsGlobalScope":true,"impliedFormat":1},{"version":"fb893a0dfc3c9fb0f9ca93d0648694dd95f33cbad2c0f2c629f842981dfd4e2e","impliedFormat":1},{"version":"3eb11dbf3489064a47a2e1cf9d261b1f100ef0b3b50ffca6c44dd99d6dd81ac1","impliedFormat":1},{"version":"70521b6ab0dcba37539e5303104f29b721bfb2940b2776da4cc818c07e1fefc1","affectsGlobalScope":true,"impliedFormat":1},{"version":"030e350db2525514580ed054f712ffb22d273e6bc7eddc1bb7eda1e0ba5d395e","affectsGlobalScope":true,"impliedFormat":1},{"version":"d153a11543fd884b596587ccd97aebbeed950b26933ee000f94009f1ab142848","affectsGlobalScope":true,"impliedFormat":1},{"version":"21d819c173c0cf7cc3ce57c3276e77fd9a8a01d35a06ad87158781515c9a438a","impliedFormat":1},{"version":"a79e62f1e20467e11a904399b8b18b18c0c6eea6b50c1168bf215356d5bebfaf","affectsGlobalScope":true,"impliedFormat":1},{"version":"d802f0e6b5188646d307f070d83512e8eb94651858de8a82d1e47f60fb6da4e2","affectsGlobalScope":true,"impliedFormat":1},{"version":"4967529644e391115ca5592184d4b63980569adf60ee685f968fd59ab1557188","impliedFormat":1},{"version":"5929864ce17fba74232584d90cb721a89b7ad277220627cc97054ba15a98ea8f","impliedFormat":1},{"version":"763fe0f42b3d79b440a9b6e51e9ba3f3f91352469c1e4b3b67bfa4ff6352f3f4","impliedFormat":1},{"version":"25c8056edf4314820382a5fdb4bb7816999acdcb929c8f75e3f39473b87e85bc","impliedFormat":1},{"version":"c464d66b20788266e5353b48dc4aa6bc0dc4a707276df1e7152ab0c9ae21fad8","impliedFormat":1},{"version":"78d0d27c130d35c60b5e5566c9f1e5be77caf39804636bc1a40133919a949f21","impliedFormat":1},{"version":"c6fd2c5a395f2432786c9cb8deb870b9b0e8ff7e22c029954fabdd692bff6195","impliedFormat":1},{"version":"1d6e127068ea8e104a912e42fc0a110e2aa5a66a356a917a163e8cf9a65e4a75","impliedFormat":1},{"version":"5ded6427296cdf3b9542de4471d2aa8d3983671d4cac0f4bf9c637208d1ced43","impliedFormat":1},{"version":"7f182617db458e98fc18dfb272d40aa2fff3a353c44a89b2c0ccb3937709bfb5","impliedFormat":1},{"version":"cadc8aced301244057c4e7e73fbcae534b0f5b12a37b150d80e5a45aa4bebcbd","impliedFormat":1},{"version":"385aab901643aa54e1c36f5ef3107913b10d1b5bb8cbcd933d4263b80a0d7f20","impliedFormat":1},{"version":"9670d44354bab9d9982eca21945686b5c24a3f893db73c0dae0fd74217a4c219","impliedFormat":1},{"version":"0b8a9268adaf4da35e7fa830c8981cfa22adbbe5b3f6f5ab91f6658899e657a7","impliedFormat":1},{"version":"11396ed8a44c02ab9798b7dca436009f866e8dae3c9c25e8c1fbc396880bf1bb","impliedFormat":1},{"version":"ba7bc87d01492633cb5a0e5da8a4a42a1c86270e7b3d2dea5d156828a84e4882","impliedFormat":1},{"version":"4893a895ea92c85345017a04ed427cbd6a1710453338df26881a6019432febdd","impliedFormat":1},{"version":"c21dc52e277bcfc75fac0436ccb75c204f9e1b3fa5e12729670910639f27343e","impliedFormat":1},{"version":"13f6f39e12b1518c6650bbb220c8985999020fe0f21d818e28f512b7771d00f9","impliedFormat":1},{"version":"9b5369969f6e7175740bf51223112ff209f94ba43ecd3bb09eefff9fd675624a","impliedFormat":1},{"version":"4fe9e626e7164748e8769bbf74b538e09607f07ed17c2f20af8d680ee49fc1da","impliedFormat":1},{"version":"24515859bc0b836719105bb6cc3d68255042a9f02a6022b3187948b204946bd2","impliedFormat":1},{"version":"ea0148f897b45a76544ae179784c95af1bd6721b8610af9ffa467a518a086a43","impliedFormat":1},{"version":"24c6a117721e606c9984335f71711877293a9651e44f59f3d21c1ea0856f9cc9","impliedFormat":1},{"version":"dd3273ead9fbde62a72949c97dbec2247ea08e0c6952e701a483d74ef92d6a17","impliedFormat":1},{"version":"405822be75ad3e4d162e07439bac80c6bcc6dbae1929e179cf467ec0b9ee4e2e","impliedFormat":1},{"version":"0db18c6e78ea846316c012478888f33c11ffadab9efd1cc8bcc12daded7a60b6","impliedFormat":1},{"version":"e61be3f894b41b7baa1fbd6a66893f2579bfad01d208b4ff61daef21493ef0a8","impliedFormat":1},{"version":"bd0532fd6556073727d28da0edfd1736417a3f9f394877b6d5ef6ad88fba1d1a","impliedFormat":1},{"version":"89167d696a849fce5ca508032aabfe901c0868f833a8625d5a9c6e861ef935d2","impliedFormat":1},{"version":"615ba88d0128ed16bf83ef8ccbb6aff05c3ee2db1cc0f89ab50a4939bfc1943f","impliedFormat":1},{"version":"a4d551dbf8746780194d550c88f26cf937caf8d56f102969a110cfaed4b06656","impliedFormat":1},{"version":"8bd86b8e8f6a6aa6c49b71e14c4ffe1211a0e97c80f08d2c8cc98838006e4b88","impliedFormat":1},{"version":"317e63deeb21ac07f3992f5b50cdca8338f10acd4fbb7257ebf56735bf52ab00","impliedFormat":1},{"version":"4732aec92b20fb28c5fe9ad99521fb59974289ed1e45aecb282616202184064f","impliedFormat":1},{"version":"2e85db9e6fd73cfa3d7f28e0ab6b55417ea18931423bd47b409a96e4a169e8e6","impliedFormat":1},{"version":"c46e079fe54c76f95c67fb89081b3e399da2c7d109e7dca8e4b58d83e332e605","impliedFormat":1},{"version":"bf67d53d168abc1298888693338cb82854bdb2e69ef83f8a0092093c2d562107","impliedFormat":1},{"version":"88d9a77d2abc23a7d26625dd6dae5b57199a8693b85c9819355651c9d9bab90f","affectsGlobalScope":true,"impliedFormat":1},{"version":"a38efe83ff77c34e0f418a806a01ca3910c02ee7d64212a59d59bca6c2c38fa1","impliedFormat":1},{"version":"7394959e5a741b185456e1ef5d64599c36c60a323207450991e7a42e08911419","impliedFormat":1},{"version":"3fe4022ba1e738034e38ad9afacbf0f1f16b458ed516326f5bf9e4a31e9be1dc","impliedFormat":1},{"version":"a957197054b074bcdf5555d26286e8461680c7c878040d0f4e2d5509a7524944","affectsGlobalScope":true,"impliedFormat":1},{"version":"4314c7a11517e221f7296b46547dbc4df047115b182f544d072bdccffa57fc72","impliedFormat":1},{"version":"e9b97d69510658d2f4199b7d384326b7c4053b9e6645f5c19e1c2a54ede427fc","impliedFormat":1},{"version":"c2510f124c0293ab80b1777c44d80f812b75612f297b9857406468c0f4dafe29","affectsGlobalScope":true,"impliedFormat":1},{"version":"5524481e56c48ff486f42926778c0a3cce1cc85dc46683b92b1271865bcf015a","impliedFormat":1},{"version":"f478f6f5902dc144c0d6d7bdc919c5177cac4d17a8ca8653c2daf6d7dc94317f","affectsGlobalScope":true,"impliedFormat":1},{"version":"19d5f8d3930e9f99aa2c36258bf95abbe5adf7e889e6181872d1cdba7c9a7dd5","impliedFormat":1},{"version":"b200675fd112ffef97c166d0341fb33f6e29e9f27660adde7868e95c5bc98beb","impliedFormat":1},{"version":"a6bf63d17324010ca1fbf0389cab83f93389bb0b9a01dc8a346d092f65b3605f","impliedFormat":1},{"version":"e009777bef4b023a999b2e5b9a136ff2cde37dc3f77c744a02840f05b18be8ff","impliedFormat":1},{"version":"1e0d1f8b0adfa0b0330e028c7941b5a98c08b600efe7f14d2d2a00854fb2f393","impliedFormat":1},{"version":"ee1ee365d88c4c6c0c0a5a5701d66ebc27ccd0bcfcfaa482c6e2e7fe7b98edf7","affectsGlobalScope":true,"impliedFormat":1},{"version":"88bc59b32d0d5b4e5d9632ac38edea23454057e643684c3c0b94511296f2998c","affectsGlobalScope":true,"impliedFormat":1},{"version":"a0a1dda070290b92da5a50113b73ecc4dd6bcbffad66e3c86503d483eafbadcf","impliedFormat":1},{"version":"59dcad36c4549175a25998f6a8b33c1df8e18df9c12ebad1dfb25af13fd4b1ce","impliedFormat":1},{"version":"206a70e72af3e24688397b81304358526ce70d020e4c2606c4acfd1fa1e81fb2","impliedFormat":1},{"version":"3f3edb8e44e3b9df3b7ca3219ab539710b6a7f4fe16bd884d441af207e03cd57","impliedFormat":1},{"version":"528b62e4272e3ddfb50e8eed9e359dedea0a4d171c3eb8f337f4892aac37b24b","impliedFormat":1},{"version":"d71535813e39c23baa113bc4a29a0e187b87d1105ccc8c5a6ebaca38d9a9bff2","impliedFormat":1},{"version":"8cf7e92bdb2862c2d28ba4535c43dc599cfbc0025db5ed9973d9b708dcbe3d98","affectsGlobalScope":true,"impliedFormat":1},{"version":"f72bc8fe16da67e4e3268599295797b202b95e54bd215a03f97e925dd1502a36","impliedFormat":1},{"version":"b1b6ee0d012aeebe11d776a155d8979730440082797695fc8e2a5c326285678f","impliedFormat":1},{"version":"45875bcae57270aeb3ebc73a5e3fb4c7b9d91d6b045f107c1d8513c28ece71c0","impliedFormat":1},{"version":"1dc73f8854e5c4506131c4d95b3a6c24d0c80336d3758e95110f4c7b5cb16397","affectsGlobalScope":true,"impliedFormat":1},{"version":"636302a00dfd1f9fe6e8e91e4e9350c6518dcc8d51a474e4fc3a9ba07135100b","affectsGlobalScope":true,"impliedFormat":1},{"version":"3f16a7e4deafa527ed9995a772bb380eb7d3c2c0fd4ae178c5263ed18394db2c","impliedFormat":1},{"version":"933921f0bb0ec12ef45d1062a1fc0f27635318f4d294e4d99de9a5493e618ca2","impliedFormat":1},{"version":"71a0f3ad612c123b57239a7749770017ecfe6b66411488000aba83e4546fde25","impliedFormat":1},{"version":"8145e07aad6da5f23f2fcd8c8e4c5c13fb26ee986a79d03b0829b8fce152d8b2","impliedFormat":1},{"version":"e1120271ebbc9952fdc7b2dd3e145560e52e06956345e6fdf91d70ca4886464f","impliedFormat":1},{"version":"814118df420c4e38fe5ae1b9a3bafb6e9c2aa40838e528cde908381867be6466","impliedFormat":1},{"version":"e1ce1d622f1e561f6cdf246372ead3bbc07ce0342024d0e9c7caf3136f712698","impliedFormat":1},{"version":"c878f74b6d10b267f6075c51ac1d8becd15b4aa6a58f79c0cfe3b24908357f60","impliedFormat":1},{"version":"37ba7b45141a45ce6e80e66f2a96c8a5ab1bcef0fc2d0f56bb58df96ec67e972","impliedFormat":1},{"version":"125d792ec6c0c0f657d758055c494301cc5fdb327d9d9d5960b3f129aff76093","impliedFormat":1},{"version":"27e4532aaaa1665d0dd19023321e4dc12a35a741d6b8e1ca3517fcc2544e0efe","affectsGlobalScope":true,"impliedFormat":1},{"version":"2754d8221d77c7b382096651925eb476f1066b3348da4b73fe71ced7801edada","impliedFormat":1},{"version":"8c2ad42d5d1a2e8e6112625767f8794d9537f1247907378543106f7ba6c7df90","affectsGlobalScope":true,"impliedFormat":1},{"version":"f0be1b8078cd549d91f37c30c222c2a187ac1cf981d994fb476a1adc61387b14","affectsGlobalScope":true,"impliedFormat":1},{"version":"0aaed1d72199b01234152f7a60046bc947f1f37d78d182e9ae09c4289e06a592","impliedFormat":1},{"version":"98ffdf93dfdd206516971d28e3e473f417a5cfd41172e46b4ce45008f640588e","impliedFormat":1},{"version":"66ba1b2c3e3a3644a1011cd530fb444a96b1b2dfe2f5e837a002d41a1a799e60","impliedFormat":1},{"version":"7e514f5b852fdbc166b539fdd1f4e9114f29911592a5eb10a94bb3a13ccac3c4","impliedFormat":1},{"version":"7d6ff413e198d25639f9f01f16673e7df4e4bd2875a42455afd4ecc02ef156da","affectsGlobalScope":true,"impliedFormat":1},{"version":"12e8ce658dd17662d82fb0509d2057afc5e6ee30369a2e9e0957eff725b1f11d","affectsGlobalScope":true,"impliedFormat":1},{"version":"74736930d108365d7bbe740c7154706ccfb1b2a3855a897963ab3e5c07ecbf19","impliedFormat":1},{"version":"858f999b3e4a45a4e74766d43030941466460bf8768361d254234d5870480a53","impliedFormat":1},{"version":"ac5ed35e649cdd8143131964336ab9076937fa91802ec760b3ea63b59175c10a","impliedFormat":1},{"version":"63b05afa6121657f25e99e1519596b0826cda026f09372c9100dfe21417f4bd6","affectsGlobalScope":true,"impliedFormat":1},{"version":"3797dd6f4ea3dc15f356f8cdd3128bfa18122213b38a80d6c1f05d8e13cbdad8","impliedFormat":1},{"version":"ad90122e1cb599b3bc06a11710eb5489101be678f2920f2322b0ac3e195af78d","impliedFormat":1},{"version":"bc222163edcb8df6ba9b506d053d6c5afcae50e85695151cf4636a3107deaba9","impliedFormat":1},{"version":"e2b48abff5a8adc6bb1cd13a702b9ef05e6045a98e7cfa95a8779b53b6d0e69d","impliedFormat":1},{"version":"afe73051ff6a03a9565cbd8ebb0e956ee3df5e913ad5c1ded64218aabfa3dcb5","impliedFormat":1},{"version":"89121c1bf2990f5219bfd802a3e7fc557de447c62058d6af68d6b6348d64499a","impliedFormat":1},{"version":"79b4369233a12c6fa4a07301ecb7085802c98f3a77cf9ab97eee27e1656f82e6","impliedFormat":1},{"version":"d7dbe0ad36bdca8a6ecf143422a48e72cc8927bab7b23a1a2485c2f78a7022c6","impliedFormat":1},{"version":"035a5df183489c2e22f3cf59fc1ed2b043d27f357eecc0eb8d8e840059d44245","impliedFormat":1},{"version":"a4809f4d92317535e6b22b01019437030077a76fec1d93b9881c9ed4738fcc54","impliedFormat":1},{"version":"5f53fa0bd22096d2a78533f94e02c899143b8f0f9891a46965294ee8b91a9434","impliedFormat":1},{"version":"f3d8c757e148ad968f0d98697987db363070abada5f503da3c06aefd9d4248c1","impliedFormat":1},{"version":"96d14f21b7652903852eef49379d04dbda28c16ed36468f8c9fa08f7c14c9538","impliedFormat":1},{"version":"742f21debb3937c3839a63245648238555bdab1ea095d43fd10c88a64029bf76","impliedFormat":1},{"version":"7cfdf3b9a5ba934a058bfc9390c074104dc7223b7e3c16fd5335206d789bc3d3","impliedFormat":1},{"version":"7220461ab7f6d600b313ce621346c315c3a0ebc65b5c6f268488c5c55b68d319","impliedFormat":1},{"version":"b14c272987c82d49f0f12184c9d8d07a7f71767be99cb76faa125b777c70e962","impliedFormat":1},{"version":"fcf79300e5257a23ed3bacaa6861d7c645139c6f7ece134d15e6669447e5e6db","impliedFormat":1},{"version":"187119ff4f9553676a884e296089e131e8cc01691c546273b1d0089c3533ce42","impliedFormat":1},{"version":"aa2c18a1b5a086bbcaae10a4efba409cc95ba7287d8cf8f2591b53704fea3dea","impliedFormat":1},{"version":"b88749bdb18fc1398370e33aa72bc4f88274118f4960e61ce26605f9b33c5ba2","impliedFormat":1},{"version":"0aaef8cded245bf5036a7a40b65622dd6c4da71f7a35343112edbe112b348a1e","impliedFormat":1},{"version":"00baffbe8a2f2e4875367479489b5d43b5fc1429ecb4a4cc98cfc3009095f52a","impliedFormat":1},{"version":"a873c50d3e47c21aa09fbe1e2023d9a44efb07cc0cb8c72f418bf301b0771fd3","impliedFormat":1},{"version":"7c14ccd2eaa82619fffc1bfa877eb68a012e9fb723d07ee98db451fadb618906","impliedFormat":1},{"version":"49c36529ee09ea9ce19525af5bb84985ea8e782cb7ee8c493d9e36d027a3d019","impliedFormat":1},{"version":"df996e25faa505f85aeb294d15ebe61b399cf1d1e49959cdfaf2cc0815c203f9","impliedFormat":1},{"version":"4f6a12044ee6f458db11964153830abbc499e73d065c51c329ec97407f4b13dd","impliedFormat":1},{"version":"13e834b958fe7e9010d2161497f98916974a0618be7a773281a253a948da8b0d","impliedFormat":1},{"version":"dae5c8e0ca15779492744cb4071c5b3c94c2121940fbaefb43ca9a045557a0c9","impliedFormat":1},{"version":"0944f27ebff4b20646b71e7e3faaaae50a6debd40bc63e225de1320dd15c5795","impliedFormat":1},{"version":"8a7219b41d3c1c93f3f3b779146f313efade2404eeece88dcd366df7e2364977","impliedFormat":1},{"version":"a109c4289d59d9019cfe1eeab506fe57817ee549499b02a83a7e9d3bdf662d63","impliedFormat":1},{"version":"d4a22007b481fe2a2e6bfd3a42c00cd62d41edb36d30fc4697df2692e9891fc8","impliedFormat":1},{"version":"5d30565583300c9256072a013ac0318cc603ff769b4c5cafc222394ea93963e1","impliedFormat":1},{"version":"8841e2aa774b89bd23302dede20663306dc1b9902431ac64b24be8b8d0e3f649","impliedFormat":1},{"version":"fbca5ffaebf282ec3cdac47b0d1d4a138a8b0bb32105251a38acb235087d3318","impliedFormat":1},{"version":"29f72ec1289ae3aeda78bf14b38086d3d803262ac13904b400422941a26a3636","affectsGlobalScope":true,"impliedFormat":1},{"version":"62a8effc4dd17bbc2c05927b4ca5f67e73fdb458e203b128c041d0d70ffa6b55","impliedFormat":1},{"version":"d3213ac97e906cb1a935cf80061aacdb05a943a4d0316b469ab44565c34147f2","impliedFormat":1},{"version":"22293bd6fa12747929f8dfca3ec1684a3fe08638aa18023dd286ab337e88a592","impliedFormat":1},{"version":"916be7d770b0ae0406be9486ac12eb9825f21514961dd050594c4b250617d5a8","impliedFormat":1},{"version":"510616459e6edd01acbce333fb256e06bdffdad43ca233a9090164bf8bb83912","impliedFormat":1},{"version":"7d2a0ba1297be385a89b5515b88cd31b4a1eeef5236f710166dc1b36b1741e1b","impliedFormat":1},{"version":"6175dda01fddf3684d6261d97d169d86b024eceb2cc20041936c068789230f8f","impliedFormat":1},{"version":"ab82804a14454734010dcdcd43f564ff7b0389bee4c5692eec76ff5b30d4cf66","impliedFormat":1},{"version":"4006c872e38a2c4e09c593bc0cdd32b7b4f5c4843910bea0def631c483fff6c5","impliedFormat":1},{"version":"ab6aa3a65d473871ee093e3b7b71ed0f9c69e07d1d4295f45c9efd91a771241d","impliedFormat":1},{"version":"79eed264089715d6f0293e67d48cea5e9a6b34eb94d3a042daae6aabd96104da","impliedFormat":1},{"version":"d9a256f69f3956993e65efd88336644be8f8dd36d149e859c14704ef6c6c0eec","impliedFormat":1},{"version":"1ba59c8bbeed2cb75b239bb12041582fa3e8ef32f8d0bd0ec802e38442d3f317","impliedFormat":1},{"version":"5aac5efd20619b522faeeb0badf250834850c605ad8c5fb91c6502a54057f413","impliedFormat":1},{"version":"bae8d023ef6b23df7da26f51cea44321f95817c190342a36882e93b80d07a960","impliedFormat":1},{"version":"26a770cec4bd2e7dbba95c6e536390fffe83c6268b78974a93727903b515c4e7","impliedFormat":1},{"version":"74d5a87c3616cd5d8691059d531504403aa857e09cbaecb1c64dfb9ace0db185","impliedFormat":1}],"root":[79,80,[91,100],[102,105],[107,113]],"options":{"allowJs":true,"checkJs":true,"composite":true,"declaration":true,"declarationMap":true,"emitDeclarationOnly":false,"esModuleInterop":true,"module":101,"noEmitOnError":true,"outDir":"./","removeComments":false,"rewriteRelativeImportExtensions":true,"skipLibCheck":true,"sourceMap":true,"strict":true,"stripInternal":true,"target":11,"verbatimModuleSyntax":true},"referencedMap":[[116,1],[114,2],[86,3],[83,4],[82,4],[84,5],[89,6],[90,7],[81,6],[87,8],[88,9],[119,10],[115,1],[117,11],[118,1],[121,12],[122,12],[123,12],[120,2],[125,13],[225,14],[226,2],[227,15],[229,16],[230,2],[231,2],[232,17],[233,18],[234,2],[235,2],[236,2],[237,19],[251,20],[252,20],[239,21],[240,22],[238,23],[241,24],[242,25],[243,26],[244,27],[245,28],[246,29],[247,30],[248,31],[249,32],[250,33],[254,34],[255,35],[256,16],[253,2],[257,36],[258,2],[259,2],[260,2],[124,2],[261,37],[262,2],[171,38],[172,38],[173,39],[131,40],[174,41],[175,42],[176,43],[126,2],[129,44],[127,2],[128,2],[177,45],[178,46],[179,47],[180,48],[181,49],[182,50],[183,50],[185,51],[184,52],[186,53],[187,54],[188,55],[170,56],[130,2],[189,57],[190,58],[191,59],[224,60],[192,61],[193,62],[194,63],[195,64],[196,65],[197,66],[198,67],[199,68],[200,69],[201,70],[202,70],[203,71],[204,2],[205,2],[206,72],[208,73],[207,74],[209,75],[210,76],[211,77],[212,78],[213,79],[214,80],[215,81],[216,82],[217,83],[218,84],[219,85],[220,86],[221,87],[222,88],[223,89],[263,2],[264,2],[265,2],[267,90],[266,2],[268,2],[269,2],[270,2],[271,2],[228,2],[272,2],[273,91],[274,14],[275,2],[276,92],[277,93],[132,2],[106,2],[101,2],[73,2],[74,94],[77,95],[75,2],[76,96],[85,2],[71,2],[72,2],[12,2],[13,2],[16,2],[15,2],[2,2],[17,2],[18,2],[19,2],[20,2],[21,2],[22,2],[23,2],[24,2],[3,2],[25,2],[26,2],[4,2],[27,2],[31,2],[28,2],[29,2],[30,2],[32,2],[33,2],[34,2],[5,2],[35,2],[36,2],[37,2],[38,2],[6,2],[42,2],[39,2],[40,2],[41,2],[43,2],[7,2],[44,2],[49,2],[50,2],[45,2],[46,2],[47,2],[48,2],[8,2],[54,2],[51,2],[52,2],[53,2],[55,2],[9,2],[56,2],[57,2],[58,2],[60,2],[59,2],[61,2],[62,2],[10,2],[63,2],[64,2],[65,2],[11,2],[66,2],[67,2],[68,2],[69,2],[70,2],[1,2],[14,2],[78,2],[148,97],[158,98],[147,97],[168,99],[139,100],[138,101],[167,14],[161,102],[166,103],[141,104],[155,105],[140,106],[164,107],[136,108],[135,14],[165,109],[137,110],[142,111],[143,2],[146,111],[133,2],[169,112],[159,113],[150,114],[151,115],[153,116],[149,117],[152,118],[162,14],[144,119],[145,120],[154,121],[134,122],[157,113],[156,111],[160,2],[163,123],[112,124],[104,125],[111,126],[92,127],[109,2],[94,128],[113,2],[93,51],[110,129],[79,130],[95,131],[105,132],[80,133],[91,134],[96,135],[97,136],[107,137],[108,138],[98,2],[99,139],[102,140],[100,141],[103,142]],"latestChangedDtsFile":"./src/events.browser.d.ts","version":"5.8.3"}
\ No newline at end of file
diff --git a/node_modules/@libp2p/interface/dist/typedoc-urls.json b/node_modules/@libp2p/interface/dist/typedoc-urls.json
deleted file mode 100644
index 652b17d..0000000
--- a/node_modules/@libp2p/interface/dist/typedoc-urls.json
+++ /dev/null
@@ -1,223 +0,0 @@
-{
-  "FaultTolerance": "https://libp2p.github.io/js-libp2p/enums/_libp2p_interface.FaultTolerance.html",
-  "TopicValidatorResult": "https://libp2p.github.io/js-libp2p/enums/_libp2p_interface.TopicValidatorResult.html",
-  "AbortError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.AbortError.html",
-  "AlreadyStartedError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.AlreadyStartedError.html",
-  "ConnectionClosedError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.ConnectionClosedError.html",
-  "ConnectionClosingError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.ConnectionClosingError.html",
-  "ConnectionFailedError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.ConnectionFailedError.html",
-  "DialError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.DialError.html",
-  "InvalidCIDError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.InvalidCIDError.html",
-  "InvalidCryptoExchangeError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.InvalidCryptoExchangeError.html",
-  "InvalidMessageError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.InvalidMessageError.html",
-  "InvalidMultiaddrError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.InvalidMultiaddrError.html",
-  "InvalidMultihashError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.InvalidMultihashError.html",
-  "InvalidParametersError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.InvalidParametersError.html",
-  "InvalidPeerIdError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.InvalidPeerIdError.html",
-  "InvalidPrivateKeyError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.InvalidPrivateKeyError.html",
-  "InvalidPublicKeyError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.InvalidPublicKeyError.html",
-  "LimitedConnectionError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.LimitedConnectionError.html",
-  "ListenError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.ListenError.html",
-  "MuxerClosedError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.MuxerClosedError.html",
-  "NotFoundError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.NotFoundError.html",
-  "NotImplementedError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.NotImplementedError.html",
-  "NotStartedError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.NotStartedError.html",
-  "ProtocolError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.ProtocolError.html",
-  "StreamResetError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.StreamResetError.html",
-  "StreamStateError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.StreamStateError.html",
-  "TimeoutError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.TimeoutError.html",
-  "TooManyInboundProtocolStreamsError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.TooManyInboundProtocolStreamsError.html",
-  "TooManyOutboundProtocolStreamsError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.TooManyOutboundProtocolStreamsError.html",
-  "TypedEventEmitter": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.TypedEventEmitter.html",
-  "UnexpectedPeerError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.UnexpectedPeerError.html",
-  "UnsupportedKeyTypeError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.UnsupportedKeyTypeError.html",
-  "UnsupportedOperationError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.UnsupportedOperationError.html",
-  "UnsupportedProtocolError": "https://libp2p.github.io/js-libp2p/classes/_libp2p_interface.UnsupportedProtocolError.html",
-  "AbortOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.AbortOptions.html",
-  ".:AbortOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.AbortOptions.html",
-  "Address": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Address.html",
-  "AddressSorter": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.AddressSorter.html",
-  ".:AddressSorter": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.AddressSorter.html",
-  "CalculatedHistogramOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.CalculatedHistogramOptions.html",
-  "CalculatedMetricOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.CalculatedMetricOptions.html",
-  "CalculatedSummaryOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.CalculatedSummaryOptions.html",
-  "ClearableSignal": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.ClearableSignal.html",
-  ".:ClearableSignal": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.ClearableSignal.html",
-  "ComponentLogger": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.ComponentLogger.html",
-  ".:ComponentLogger": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.ComponentLogger.html",
-  "Connection": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Connection.html",
-  "ConnectionEncrypter": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.ConnectionEncrypter.html",
-  "ConnectionGater": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.ConnectionGater.html",
-  "ConnectionLimits": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.ConnectionLimits.html",
-  "ConnectionProtector": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.ConnectionProtector.html",
-  "ConnectionTimeline": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.ConnectionTimeline.html",
-  "ContentRouting": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.ContentRouting.html",
-  "ContentRoutingProvider": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.ContentRoutingProvider.html",
-  "Counter": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Counter.html",
-  "CounterGroup": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.CounterGroup.html",
-  "CreateListenerOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.CreateListenerOptions.html",
-  "DialOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.DialOptions.html",
-  ".:DialOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.DialOptions.html",
-  "DialProtocolOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.DialProtocolOptions.html",
-  ".:DialProtocolOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.DialProtocolOptions.html",
-  "DialTransportOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.DialTransportOptions.html",
-  "ECDSAPrivateKey": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.ECDSAPrivateKey.html",
-  "ECDSAPublicKey": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.ECDSAPublicKey.html",
-  "Ed25519PeerId": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Ed25519PeerId.html",
-  "Ed25519PrivateKey": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Ed25519PrivateKey.html",
-  "Ed25519PublicKey": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Ed25519PublicKey.html",
-  "Envelope": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Envelope.html",
-  "EventCallback": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.EventCallback.html",
-  "EventObject": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.EventObject.html",
-  "Histogram": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Histogram.html",
-  "HistogramGroup": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.HistogramGroup.html",
-  "HistogramOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.HistogramOptions.html",
-  "IdentifyResult": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.IdentifyResult.html",
-  ".:IdentifyResult": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.IdentifyResult.html",
-  "IncomingStreamData": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.IncomingStreamData.html",
-  "IsDialableOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.IsDialableOptions.html",
-  ".:IsDialableOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.IsDialableOptions.html",
-  "Libp2p": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Libp2p.html",
-  ".:Libp2p": "https://libp2p.github.io/js-libp2p/interfaces/libp2p.index.Libp2p.html",
-  "Libp2pEvents": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Libp2pEvents.html",
-  ".:Libp2pEvents": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Libp2pEvents.html",
-  "Listener": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Listener.html",
-  "ListenerEvents": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.ListenerEvents.html",
-  "Logger": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Logger.html",
-  ".:Logger": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Logger.html",
-  "LoggerOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.LoggerOptions.html",
-  ".:LoggerOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.LoggerOptions.html",
-  "Metric": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Metric.html",
-  "MetricGroup": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.MetricGroup.html",
-  "MetricOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.MetricOptions.html",
-  "Metrics": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Metrics.html",
-  "MultiaddrConnection": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.MultiaddrConnection.html",
-  "MultiaddrConnectionTimeline": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.MultiaddrConnectionTimeline.html",
-  "MultiaddrFilter": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.MultiaddrFilter.html",
-  "NewStreamOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.NewStreamOptions.html",
-  "NodeInfo": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.NodeInfo.html",
-  ".:NodeInfo": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.NodeInfo.html",
-  "Peer": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Peer.html",
-  "PeerData": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.PeerData.html",
-  "PeerDiscovery": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.PeerDiscovery.html",
-  "PeerDiscoveryEvents": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.PeerDiscoveryEvents.html",
-  "PeerDiscoveryProvider": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.PeerDiscoveryProvider.html",
-  "PeerInfo": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.PeerInfo.html",
-  "PeerQuery": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.PeerQuery.html",
-  "PeerQueryFilter": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.PeerQueryFilter.html",
-  "PeerQueryOrder": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.PeerQueryOrder.html",
-  "PeerRouting": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.PeerRouting.html",
-  "PeerRoutingProvider": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.PeerRoutingProvider.html",
-  "PeerStore": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.PeerStore.html",
-  "PeerStreamEvents": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.PeerStreamEvents.html",
-  "PeerStreams": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.PeerStreams.html",
-  "PeerUpdate": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.PeerUpdate.html",
-  ".:PeerUpdate": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.PeerUpdate.html",
-  "PendingDial": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.PendingDial.html",
-  ".:PendingDial": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.PendingDial.html",
-  "PublishResult": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.PublishResult.html",
-  "PubSub": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.PubSub.html",
-  "PubSubEvents": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.PubSubEvents.html",
-  "PubSubInit": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.PubSubInit.html",
-  "PubSubRPC": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.PubSubRPC.html",
-  "PubSubRPCMessage": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.PubSubRPCMessage.html",
-  "PubSubRPCSubscription": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.PubSubRPCSubscription.html",
-  "Record": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Record.html",
-  "RoutingOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.RoutingOptions.html",
-  ".:RoutingOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.RoutingOptions.html",
-  "RSAPeerId": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.RSAPeerId.html",
-  "RSAPrivateKey": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.RSAPrivateKey.html",
-  "RSAPublicKey": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.RSAPublicKey.html",
-  "Secp256k1PeerId": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Secp256k1PeerId.html",
-  "Secp256k1PrivateKey": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Secp256k1PrivateKey.html",
-  "Secp256k1PublicKey": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Secp256k1PublicKey.html",
-  "SecureConnectionOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.SecureConnectionOptions.html",
-  "SecuredConnection": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.SecuredConnection.html",
-  "SignedMessage": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.SignedMessage.html",
-  "SignedPeerRecord": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.SignedPeerRecord.html",
-  ".:SignedPeerRecord": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.SignedPeerRecord.html",
-  "Startable": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Startable.html",
-  "StopTimer": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.StopTimer.html",
-  "Stream": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Stream.html",
-  "StreamHandler": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.StreamHandler.html",
-  "StreamHandlerOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.StreamHandlerOptions.html",
-  "StreamHandlerRecord": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.StreamHandlerRecord.html",
-  "StreamMuxer": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.StreamMuxer.html",
-  "StreamMuxerFactory": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.StreamMuxerFactory.html",
-  "StreamMuxerInit": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.StreamMuxerInit.html",
-  "StreamTimeline": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.StreamTimeline.html",
-  "Subscription": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Subscription.html",
-  "SubscriptionChangeData": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.SubscriptionChangeData.html",
-  "Summary": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Summary.html",
-  "SummaryGroup": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.SummaryGroup.html",
-  "SummaryOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.SummaryOptions.html",
-  "Tag": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Tag.html",
-  "TagOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.TagOptions.html",
-  "TLSCertificate": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.TLSCertificate.html",
-  ".:TLSCertificate": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.TLSCertificate.html",
-  "TopicValidatorFn": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.TopicValidatorFn.html",
-  "Topology": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Topology.html",
-  "TopologyFilter": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.TopologyFilter.html",
-  "TraceFunctionOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.TraceFunctionOptions.html",
-  "TraceGeneratorFunctionOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.TraceGeneratorFunctionOptions.html",
-  "TraceOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.TraceOptions.html",
-  ".:TraceOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.TraceOptions.html",
-  "Transport": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Transport.html",
-  "TypedEventTarget": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.TypedEventTarget.html",
-  "UnsignedMessage": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.UnsignedMessage.html",
-  "Upgrader": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.Upgrader.html",
-  "UpgraderOptions": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.UpgraderOptions.html",
-  "URLPeerId": "https://libp2p.github.io/js-libp2p/interfaces/_libp2p_interface.URLPeerId.html",
-  "CalculateMetric": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.CalculateMetric.html",
-  "ConnectionStatus": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.ConnectionStatus.html",
-  "Direction": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.Direction.html",
-  "EventHandler": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.EventHandler.html",
-  "InboundConnectionUpgradeEvents": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.InboundConnectionUpgradeEvents.html",
-  "KeyType": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.KeyType.html",
-  "Libp2pStatus": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.Libp2pStatus.html",
-  ".:Libp2pStatus": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.Libp2pStatus.html",
-  "Message": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.Message.html",
-  "OpenConnectionProgressEvents": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.OpenConnectionProgressEvents.html",
-  ".:OpenConnectionProgressEvents": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.OpenConnectionProgressEvents.html",
-  "OutboundConnectionUpgradeEvents": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.OutboundConnectionUpgradeEvents.html",
-  "PeerId": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.PeerId.html",
-  "PeerIdType": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.PeerIdType.html",
-  "PendingDialStatus": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.PendingDialStatus.html",
-  ".:PendingDialStatus": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.PendingDialStatus.html",
-  "PrivateKey": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.PrivateKey.html",
-  "PublicKey": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.PublicKey.html",
-  "ReadStatus": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.ReadStatus.html",
-  "ServiceMap": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.ServiceMap.html",
-  ".:ServiceMap": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.ServiceMap.html",
-  "SignaturePolicy": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.SignaturePolicy.html",
-  "StreamStatus": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.StreamStatus.html",
-  "TraceAttributes": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.TraceAttributes.html",
-  "TransportManagerDialProgressEvents": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.TransportManagerDialProgressEvents.html",
-  ".:TransportManagerDialProgressEvents": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.TransportManagerDialProgressEvents.html",
-  "WriteStatus": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.WriteStatus.html",
-  "YieldType": "https://libp2p.github.io/js-libp2p/types/_libp2p_interface.YieldType.html",
-  "connectionSymbol": "https://libp2p.github.io/js-libp2p/variables/_libp2p_interface.connectionSymbol.html",
-  "contentRoutingSymbol": "https://libp2p.github.io/js-libp2p/variables/_libp2p_interface.contentRoutingSymbol.html",
-  "KEEP_ALIVE": "https://libp2p.github.io/js-libp2p/variables/_libp2p_interface.KEEP_ALIVE.html",
-  "peerDiscoverySymbol": "https://libp2p.github.io/js-libp2p/variables/_libp2p_interface.peerDiscoverySymbol.html",
-  "peerIdSymbol": "https://libp2p.github.io/js-libp2p/variables/_libp2p_interface.peerIdSymbol.html",
-  "peerRoutingSymbol": "https://libp2p.github.io/js-libp2p/variables/_libp2p_interface.peerRoutingSymbol.html",
-  "pubSubSymbol": "https://libp2p.github.io/js-libp2p/variables/_libp2p_interface.pubSubSymbol.html",
-  "serviceCapabilities": "https://libp2p.github.io/js-libp2p/variables/_libp2p_interface.serviceCapabilities.html",
-  ".:serviceCapabilities": "https://libp2p.github.io/js-libp2p/variables/_libp2p_interface.serviceCapabilities.html",
-  "serviceDependencies": "https://libp2p.github.io/js-libp2p/variables/_libp2p_interface.serviceDependencies.html",
-  ".:serviceDependencies": "https://libp2p.github.io/js-libp2p/variables/_libp2p_interface.serviceDependencies.html",
-  "setMaxListeners": "https://libp2p.github.io/js-libp2p/variables/_libp2p_interface.setMaxListeners.html",
-  "StrictNoSign": "https://libp2p.github.io/js-libp2p/variables/_libp2p_interface.StrictNoSign.html",
-  "StrictSign": "https://libp2p.github.io/js-libp2p/variables/_libp2p_interface.StrictSign.html",
-  "transportSymbol": "https://libp2p.github.io/js-libp2p/variables/_libp2p_interface.transportSymbol.html",
-  "isConnection": "https://libp2p.github.io/js-libp2p/functions/_libp2p_interface.isConnection.html",
-  "isPeerId": "https://libp2p.github.io/js-libp2p/functions/_libp2p_interface.isPeerId.html",
-  "isPrivateKey": "https://libp2p.github.io/js-libp2p/functions/_libp2p_interface.isPrivateKey.html",
-  "isPublicKey": "https://libp2p.github.io/js-libp2p/functions/_libp2p_interface.isPublicKey.html",
-  "isPubSub": "https://libp2p.github.io/js-libp2p/functions/_libp2p_interface.isPubSub.html",
-  "isStartable": "https://libp2p.github.io/js-libp2p/functions/_libp2p_interface.isStartable.html",
-  "isTransport": "https://libp2p.github.io/js-libp2p/functions/_libp2p_interface.isTransport.html",
-  "start": "https://libp2p.github.io/js-libp2p/functions/_libp2p_interface.start.html",
-  "stop": "https://libp2p.github.io/js-libp2p/functions/_libp2p_interface.stop.html"
-}
\ No newline at end of file
diff --git a/node_modules/@libp2p/interface/src/keys.ts b/node_modules/@libp2p/interface/src/keys.ts
index 2db1703..834bad5 100644
--- a/node_modules/@libp2p/interface/src/keys.ts
+++ b/node_modules/@libp2p/interface/src/keys.ts
@@ -1,6 +1,7 @@
 import type { CID } from 'multiformats/cid'
 import type { MultihashDigest } from 'multiformats/hashes/interface'
 import type { Uint8ArrayList } from 'uint8arraylist'
+import type { AbortOptions } from './index.ts'
 
 export type KeyType = 'RSA' | 'Ed25519' | 'secp256k1' | 'ECDSA'
 
@@ -44,7 +45,7 @@ export interface RSAPublicKey {
    * Verify the passed data was signed by the private key corresponding to this
    * public key
    */
-  verify(data: Uint8Array | Uint8ArrayList, sig: Uint8Array): boolean | Promise<boolean>
+  verify(data: Uint8Array | Uint8ArrayList, sig: Uint8Array, options?: AbortOptions): boolean | Promise<boolean>
 
   /**
    * Returns this key as a multihash with base58btc encoding
@@ -86,7 +87,7 @@ export interface Ed25519PublicKey {
    * Verify the passed data was signed by the private key corresponding to this
    * public key
    */
-  verify(data: Uint8Array | Uint8ArrayList, sig: Uint8Array): boolean | Promise<boolean>
+  verify(data: Uint8Array | Uint8ArrayList, sig: Uint8Array, options?: AbortOptions): boolean | Promise<boolean>
 
   /**
    * Returns this key as a multihash with base58btc encoding
@@ -128,7 +129,7 @@ export interface Secp256k1PublicKey {
    * Verify the passed data was signed by the private key corresponding to this
    * public key
    */
-  verify(data: Uint8Array | Uint8ArrayList, sig: Uint8Array): boolean | Promise<boolean>
+  verify(data: Uint8Array | Uint8ArrayList, sig: Uint8Array, options?: AbortOptions): boolean | Promise<boolean>
 
   /**
    * Returns this key as a multihash with base58btc encoding
@@ -175,7 +176,7 @@ export interface ECDSAPublicKey {
    * Verify the passed data was signed by the private key corresponding to this
    * public key
    */
-  verify(data: Uint8Array | Uint8ArrayList, sig: Uint8Array): boolean | Promise<boolean>
+  verify(data: Uint8Array | Uint8ArrayList, sig: Uint8Array, options?: AbortOptions): boolean | Promise<boolean>
 
   /**
    * Returns this key as a multihash with base58btc encoding
@@ -235,7 +236,7 @@ export interface RSAPrivateKey {
    * Sign the passed data with this private key and return the signature for
    * later verification
    */
-  sign(data: Uint8Array | Uint8ArrayList): Uint8Array | Promise<Uint8Array>
+  sign(data: Uint8Array | Uint8ArrayList, options?: AbortOptions): Uint8Array | Promise<Uint8Array>
 }
 
 export interface Ed25519PrivateKey {
@@ -263,7 +264,7 @@ export interface Ed25519PrivateKey {
    * Sign the passed data with this private key and return the signature for
    * later verification
    */
-  sign(data: Uint8Array | Uint8ArrayList): Uint8Array | Promise<Uint8Array>
+  sign(data: Uint8Array | Uint8ArrayList, options?: AbortOptions): Uint8Array | Promise<Uint8Array>
 }
 
 export interface Secp256k1PrivateKey {
@@ -291,7 +292,7 @@ export interface Secp256k1PrivateKey {
    * Sign the passed data with this private key and return the signature for
    * later verification
    */
-  sign(data: Uint8Array | Uint8ArrayList): Uint8Array | Promise<Uint8Array>
+  sign(data: Uint8Array | Uint8ArrayList, options?: AbortOptions): Uint8Array | Promise<Uint8Array>
 }
 
 export interface ECDSAPrivateKey {
@@ -324,7 +325,7 @@ export interface ECDSAPrivateKey {
    * Sign the passed data with this private key and return the signature for
    * later verification
    */
-  sign(data: Uint8Array | Uint8ArrayList): Uint8Array | Promise<Uint8Array>
+  sign(data: Uint8Array | Uint8ArrayList, options?: AbortOptions): Uint8Array | Promise<Uint8Array>
 }
 
 export type PrivateKey = RSAPrivateKey | Ed25519PrivateKey | Secp256k1PrivateKey | ECDSAPrivateKey
diff --git a/node_modules/@libp2p/interface/src/peer-store.ts b/node_modules/@libp2p/interface/src/peer-store.ts
index 50d8e28..e8f53de 100644
--- a/node_modules/@libp2p/interface/src/peer-store.ts
+++ b/node_modules/@libp2p/interface/src/peer-store.ts
@@ -1,3 +1,4 @@
+import type { AbortOptions } from './index.ts'
 import type { PublicKey } from './keys.js'
 import type { PeerId } from './peer-id.js'
 import type { PeerInfo } from './peer-info.js'
@@ -147,13 +148,17 @@ export interface PeerQueryOrder { (a: Peer, b: Peer): -1 | 0 | 1 }
 /**
  * A query for getting lists of peers
  */
-export interface PeerQuery {
+export interface PeerQuery extends AbortOptions {
   filters?: PeerQueryFilter[]
   orders?: PeerQueryOrder[]
   limit?: number
   offset?: number
 }
 
+export interface ConsumePeerRecordOptions extends AbortOptions {
+  expectedPeer?: PeerId
+}
+
 export interface PeerStore {
   /**
    * Loop over every peer - the looping is async because we read from a
@@ -201,7 +206,7 @@ export interface PeerStore {
    * // []
    * ```
    */
-  delete(peerId: PeerId): Promise<void>
+  delete(peerId: PeerId, options?: AbortOptions): Promise<void>
 
   /**
    * Returns true if the passed PeerId is in the peer store
@@ -216,7 +221,7 @@ export interface PeerStore {
    * // true
    * ```
    */
-  has(peerId: PeerId): Promise<boolean>
+  has(peerId: PeerId, options?: AbortOptions): Promise<boolean>
 
   /**
    * Returns all data stored for the passed PeerId
@@ -228,7 +233,7 @@ export interface PeerStore {
    * // { .. }
    * ```
    */
-  get(peerId: PeerId): Promise<Peer>
+  get(peerId: PeerId, options?: AbortOptions): Promise<Peer>
 
   /**
    * Returns a PeerInfo object for the passed peer id. This is similar to `get`
@@ -254,7 +259,7 @@ export interface PeerStore {
    * // }
    * ```
    */
-  getInfo (peerId: PeerId): Promise<PeerInfo>
+  getInfo (peerId: PeerId, options?: AbortOptions): Promise<PeerInfo>
 
   /**
    * Adds a peer to the peer store, overwriting any existing data
@@ -267,7 +272,7 @@ export interface PeerStore {
    * })
    * ```
    */
-  save(id: PeerId, data: PeerData): Promise<Peer>
+  save(id: PeerId, data: PeerData, options?: AbortOptions): Promise<Peer>
 
   /**
    * Adds a peer to the peer store, overwriting only the passed fields
@@ -280,7 +285,7 @@ export interface PeerStore {
    * })
    * ```
    */
-  patch(id: PeerId, data: PeerData): Promise<Peer>
+  patch(id: PeerId, data: PeerData, options?: AbortOptions): Promise<Peer>
 
   /**
    * Adds a peer to the peer store, deeply merging any existing data.
@@ -293,7 +298,7 @@ export interface PeerStore {
    * })
    * ```
    */
-  merge(id: PeerId, data: PeerData): Promise<Peer>
+  merge(id: PeerId, data: PeerData, options?: AbortOptions): Promise<Peer>
 
   /**
    * Unmarshal and verify a signed peer record, extract the multiaddrs and
@@ -308,5 +313,10 @@ export interface PeerStore {
    * await peerStore.consumePeerRecord(buf, expectedPeer)
    * ```
    */
-  consumePeerRecord(buf: Uint8Array, expectedPeer?: PeerId): Promise<boolean>
+  consumePeerRecord(buf: Uint8Array, options?: ConsumePeerRecordOptions): Promise<boolean>
+
+  /**
+   * @deprecated Pass `expectedPeer` as a property of `options` instead
+   */
+  consumePeerRecord(buf: Uint8Array, expectedPeer?: PeerId, options?: AbortOptions): Promise<boolean>
 }
diff --git a/node_modules/@libp2p/interface/src/stream-handler.ts b/node_modules/@libp2p/interface/src/stream-handler.ts
index 17450ef..39a087a 100644
--- a/node_modules/@libp2p/interface/src/stream-handler.ts
+++ b/node_modules/@libp2p/interface/src/stream-handler.ts
@@ -1,4 +1,5 @@
 import type { Connection, Stream } from './connection.js'
+import type { AbortOptions } from './index.ts'
 
 export interface IncomingStreamData {
   /**
@@ -19,7 +20,7 @@ export interface StreamHandler {
   (data: IncomingStreamData): void
 }
 
-export interface StreamHandlerOptions {
+export interface StreamHandlerOptions extends AbortOptions {
   /**
    * How many incoming streams can be open for this protocol at the same time on each connection
    *
