diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/index.min.js b/node_modules/@chainsafe/libp2p-yamux/dist/index.min.js
index 467e82e..3e1e7a4 100644
--- a/node_modules/@chainsafe/libp2p-yamux/dist/index.min.js
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/index.min.js
@@ -1,4 +1,4 @@
 (function (root, factory) {(typeof module === 'object' && module.exports) ? module.exports = factory() : root.ChainsafeLibp2PYamux = factory()}(typeof self !== 'undefined' ? self : this, function () {
-"use strict";var ChainsafeLibp2PYamux=(()=>{var tt=Object.defineProperty;var It=Object.getOwnPropertyDescriptor;var At=Object.getOwnPropertyNames;var Ct=Object.prototype.hasOwnProperty;var Lt=(s,t)=>{for(var e in t)tt(s,e,{get:t[e],enumerable:!0})},Dt=(s,t,e,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of At(t))!Ct.call(s,n)&&n!==e&&tt(s,n,{get:()=>t[n],enumerable:!(r=It(t,n))||r.enumerable});return s};var Wt=s=>Dt(tt({},"__esModule",{value:!0}),s);var zt={};Lt(zt,{GoAwayCode:()=>p,yamux:()=>Ft});var M=class extends Error{static name="AbortError";constructor(t="The operation was aborted"){super(t),this.name="AbortError"}};var m=class extends Error{static name="InvalidParametersError";constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}};var S=class extends Error{static name="MuxerClosedError";constructor(t="The muxer is closed"){super(t),this.name="MuxerClosedError"}},O=class extends Error{static name="StreamResetError";constructor(t="The stream has been reset"){super(t),this.name="StreamResetError"}},F=class extends Error{static name="StreamStateError";constructor(t="The stream is in an invalid state"){super(t),this.name="StreamStateError"}};var z=class extends Error{static name="TooManyOutboundProtocolStreamsError";constructor(t="Too many outbound protocol streams"){super(t),this.name="TooManyOutboundProtocolStreamsError"}};var ot=Symbol.for("@libp2p/service-capabilities"),qt=Symbol.for("@libp2p/service-dependencies");function V(s){if(s!=null){if(typeof s[Symbol.iterator]=="function")return s[Symbol.iterator]();if(typeof s[Symbol.asyncIterator]=="function")return s[Symbol.asyncIterator]();if(typeof s.next=="function")return s}throw new Error("argument is not an iterator or iterable")}function E(){let s={};return s.promise=new Promise((t,e)=>{s.resolve=t,s.reject=e}),s}var G=class{buffer;mask;top;btm;next;constructor(t){if(!(t>0)||(t-1&t)!==0)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(t),this.mask=t-1,this.top=0,this.btm=0,this.next=null}push(t){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=t,this.top=this.top+1&this.mask,!0)}shift(){let t=this.buffer[this.btm];if(t!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,t}isEmpty(){return this.buffer[this.btm]===void 0}},D=class{size;hwm;head;tail;constructor(t={}){this.hwm=t.splitLimit??16,this.head=new G(this.hwm),this.tail=this.head,this.size=0}calculateSize(t){return t?.byteLength!=null?t.byteLength:1}push(t){if(t?.value!=null&&(this.size+=this.calculateSize(t.value)),!this.head.push(t)){let e=this.head;this.head=e.next=new G(2*this.head.buffer.length),this.head.push(t)}}shift(){let t=this.tail.shift();if(t===void 0&&this.tail.next!=null){let e=this.tail.next;this.tail.next=null,this.tail=e,t=this.tail.shift()}return t?.value!=null&&(this.size-=this.calculateSize(t.value)),t}isEmpty(){return this.head.isEmpty()}};var et=class extends Error{type;code;constructor(t,e){super(t??"The operation was aborted"),this.type="aborted",this.code=e??"ABORT_ERR"}};function B(s={}){return kt(e=>{let r=e.shift();if(r==null)return{done:!0};if(r.error!=null)throw r.error;return{done:r.done===!0,value:r.value}},s)}function kt(s,t){t=t??{};let e=t.onEnd,r=new D,n,i,o,a=E(),l=async()=>{try{return r.isEmpty()?o?{done:!0}:await new Promise((c,A)=>{i=N=>{i=null,r.push(N);try{c(s(r))}catch(L){A(L)}return n}}):s(r)}finally{r.isEmpty()&&queueMicrotask(()=>{a.resolve(),a=E()})}},f=c=>i!=null?i(c):(r.push(c),n),b=c=>(r=new D,i!=null?i({error:c}):(r.push({error:c}),n)),d=c=>{if(o)return n;if(t?.objectMode!==!0&&c?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return f({done:!1,value:c})},y=c=>o?n:(o=!0,c!=null?b(c):f({done:!0})),T=()=>(r=new D,y(),{done:!0}),Et=c=>(y(c),{done:!0});if(n={[Symbol.asyncIterator](){return this},next:l,return:T,throw:Et,push:d,end:y,get readableLength(){return r.size},onEmpty:async c=>{let A=c?.signal;if(A?.throwIfAborted(),r.isEmpty())return;let N,L;A!=null&&(N=new Promise((Vt,vt)=>{L=()=>{vt(new et)},A.addEventListener("abort",L)}));try{await Promise.race([a.promise,N])}finally{L!=null&&A!=null&&A?.removeEventListener("abort",L)}}},e==null)return n;let C=n;return n={[Symbol.asyncIterator](){return this},next(){return C.next()},throw(c){return C.throw(c),e!=null&&(e(c),e=void 0),{done:!0}},return(){return C.return(),e!=null&&(e(),e=void 0),{done:!0}},push:d,end(c){return C.end(c),e!=null&&(e(c),e=void 0),n},get readableLength(){return C.readableLength},onEmpty:c=>C.onEmpty(c)},n}function x(s=0){return new Uint8Array(s)}function _(s=0){return new Uint8Array(s)}function rt(s,t){t==null&&(t=s.reduce((n,i)=>n+i.length,0));let e=_(t),r=0;for(let n of s)e.set(n,r),r+=n.length;return e}function at(s,t){if(s===t)return!0;if(s.byteLength!==t.byteLength)return!1;for(let e=0;e<s.byteLength;e++)if(s[e]!==t[e])return!1;return!0}var ct=Symbol.for("@achingbrain/uint8arraylist");function lt(s,t){if(t==null||t<0)throw new RangeError("index is out of bounds");let e=0;for(let r of s){let n=e+r.byteLength;if(t<n)return{buf:r,index:t-e};e=n}throw new RangeError("index is out of bounds")}function q(s){return!!s?.[ct]}var v=class s{bufs;length;[ct]=!0;constructor(...t){this.bufs=[],this.length=0,t.length>0&&this.appendAll(t)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...t){this.appendAll(t)}appendAll(t){let e=0;for(let r of t)if(r instanceof Uint8Array)e+=r.byteLength,this.bufs.push(r);else if(q(r))e+=r.byteLength,this.bufs.push(...r.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}prepend(...t){this.prependAll(t)}prependAll(t){let e=0;for(let r of t.reverse())if(r instanceof Uint8Array)e+=r.byteLength,this.bufs.unshift(r);else if(q(r))e+=r.byteLength,this.bufs.unshift(...r.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}get(t){let e=lt(this.bufs,t);return e.buf[e.index]}set(t,e){let r=lt(this.bufs,t);r.buf[r.index]=e}write(t,e=0){if(t instanceof Uint8Array)for(let r=0;r<t.length;r++)this.set(e+r,t[r]);else if(q(t))for(let r=0;r<t.length;r++)this.set(e+r,t.get(r));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(t){if(t=Math.trunc(t),!(Number.isNaN(t)||t<=0)){if(t===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(t>=this.bufs[0].byteLength)t-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(t),this.length-=t;break}}}slice(t,e){let{bufs:r,length:n}=this._subList(t,e);return rt(r,n)}subarray(t,e){let{bufs:r,length:n}=this._subList(t,e);return r.length===1?r[0]:rt(r,n)}sublist(t,e){let{bufs:r,length:n}=this._subList(t,e),i=new s;return i.length=n,i.bufs=[...r],i}_subList(t,e){if(t=t??0,e=e??this.length,t<0&&(t=this.length+t),e<0&&(e=this.length+e),t<0||e>this.length)throw new RangeError("index is out of bounds");if(t===e)return{bufs:[],length:0};if(t===0&&e===this.length)return{bufs:this.bufs,length:this.length};let r=[],n=0;for(let i=0;i<this.bufs.length;i++){let o=this.bufs[i],a=n,l=a+o.byteLength;if(n=l,t>=l)continue;let f=t>=a&&t<l,b=e>a&&e<=l;if(f&&b){if(t===a&&e===l){r.push(o);break}let d=t-a;r.push(o.subarray(d,d+(e-t)));break}if(f){if(t===0){r.push(o);continue}r.push(o.subarray(t-a));continue}if(b){if(e===l){r.push(o);break}r.push(o.subarray(0,e-a));break}r.push(o)}return{bufs:r,length:e-t}}indexOf(t,e=0){if(!q(t)&&!(t instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');let r=t instanceof Uint8Array?t:t.subarray();if(e=Number(e??0),isNaN(e)&&(e=0),e<0&&(e=this.length+e),e<0&&(e=0),t.length===0)return e>this.length?this.length:e;let n=r.byteLength;if(n===0)throw new TypeError("search must be at least 1 byte long");let i=256,o=new Int32Array(i);for(let d=0;d<i;d++)o[d]=-1;for(let d=0;d<n;d++)o[r[d]]=d;let a=o,l=this.byteLength-r.byteLength,f=r.byteLength-1,b;for(let d=e;d<=l;d+=b){b=0;for(let y=f;y>=0;y--){let T=this.get(d+y);if(r[y]!==T){b=Math.max(1,y-a[T]);break}}if(b===0)return d}return-1}getInt8(t){let e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getInt8(0)}setInt8(t,e){let r=_(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setInt8(0,e),this.write(r,t)}getInt16(t,e){let r=this.subarray(t,t+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt16(0,e)}setInt16(t,e,r){let n=x(2);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt16(0,e,r),this.write(n,t)}getInt32(t,e){let r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt32(0,e)}setInt32(t,e,r){let n=x(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt32(0,e,r),this.write(n,t)}getBigInt64(t,e){let r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigInt64(0,e)}setBigInt64(t,e,r){let n=x(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setBigInt64(0,e,r),this.write(n,t)}getUint8(t){let e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getUint8(0)}setUint8(t,e){let r=_(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setUint8(0,e),this.write(r,t)}getUint16(t,e){let r=this.subarray(t,t+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint16(0,e)}setUint16(t,e,r){let n=x(2);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint16(0,e,r),this.write(n,t)}getUint32(t,e){let r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint32(0,e)}setUint32(t,e,r){let n=x(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint32(0,e,r),this.write(n,t)}getBigUint64(t,e){let r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigUint64(0,e)}setBigUint64(t,e,r){let n=x(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setBigUint64(0,e,r),this.write(n,t)}getFloat32(t,e){let r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat32(0,e)}setFloat32(t,e,r){let n=x(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setFloat32(0,e,r),this.write(n,t)}getFloat64(t,e){let r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat64(0,e)}setFloat64(t,e,r){let n=x(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setFloat64(0,e,r),this.write(n,t)}equals(t){if(t==null||!(t instanceof s)||t.bufs.length!==this.bufs.length)return!1;for(let e=0;e<this.bufs.length;e++)if(!at(this.bufs[e],t.bufs[e]))return!1;return!0}static fromUint8Arrays(t,e){let r=new s;return r.bufs=t,e==null&&(e=t.reduce((n,i)=>n+i.byteLength,0)),r.length=e,r}};var w=class extends Error{static name="InvalidFrameError";constructor(t="The frame was invalid"){super(t),this.name="InvalidFrameError"}},W=class extends Error{static name="UnrequestedPingError";constructor(t="Unrequested ping error"){super(t),this.name="UnrequestedPingError"}},k=class extends Error{static name="NotMatchingPingError";constructor(t="Unrequested ping error"){super(t),this.name="NotMatchingPingError"}},Y=class extends Error{static name="InvalidStateError";constructor(t="Invalid state"){super(t),this.name="InvalidStateError"}},H=class extends Error{static name="StreamAlreadyExistsError";constructor(t="Strean already exists"){super(t),this.name="StreamAlreadyExistsError"}},K=class extends Error{static name="DecodeInvalidVersionError";constructor(t="Decode invalid version"){super(t),this.name="DecodeInvalidVersionError"}},$=class extends Error{static name="BothClientsError";constructor(t="Both clients"){super(t),this.name="BothClientsError"}},P=class extends Error{static name="ReceiveWindowExceededError";constructor(t="Receive window exceeded"){super(t),this.name="ReceiveWindowExceededError"}};var ut=new Set([w.name,W.name,k.name,H.name,K.name,$.name,P.name]),U=256*1024,ht=16*1024*1024;var dt={enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3,initialStreamWindowSize:U,maxStreamWindowSize:ht,maxMessageSize:64*1024};function ft(s){if(s.keepAliveInterval<=0)throw new m("keep-alive interval must be positive");if(s.maxInboundStreams<0)throw new m("max inbound streams must be larger or equal 0");if(s.maxOutboundStreams<0)throw new m("max outbound streams must be larger or equal 0");if(s.initialStreamWindowSize<U)throw new m("InitialStreamWindowSize must be larger or equal 256 kB");if(s.maxStreamWindowSize<s.initialStreamWindowSize)throw new m("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");if(s.maxStreamWindowSize>2**32-1)throw new m("MaxStreamWindowSize must be less than equal MAX_UINT32");if(s.maxMessageSize<1024)throw new m("MaxMessageSize must be greater than a kilobyte")}var h;(function(s){s[s.Data=0]="Data",s[s.WindowUpdate=1]="WindowUpdate",s[s.Ping=2]="Ping",s[s.GoAway=3]="GoAway"})(h||(h={}));var u;(function(s){s[s.SYN=1]="SYN",s[s.ACK=2]="ACK",s[s.FIN=4]="FIN",s[s.RST=8]="RST"})(u||(u={}));var Te=Object.values(u).filter(s=>typeof s!="string"),mt=0,p;(function(s){s[s.NormalTermination=0]="NormalTermination",s[s.ProtocolError=1]="ProtocolError",s[s.InternalError=2]="InternalError"})(p||(p={}));var I=12;var pt=2**24;function Pt(s){if(s[0]!==mt)throw new w("Invalid frame version");return{type:s[1],flag:(s[2]<<8)+s[3],streamID:s[4]*pt+(s[5]<<16)+(s[6]<<8)+s[7],length:s[8]*pt+(s[9]<<16)+(s[10]<<8)+s[11]}}var X=class{source;buffer;frameInProgress;constructor(t){this.source=_t(t),this.buffer=new v,this.frameInProgress=!1}async*emitFrames(){for await(let t of this.source)for(this.buffer.append(t);;){let e=this.readHeader();if(e===void 0)break;let{type:r,length:n}=e;r===h.Data?(this.frameInProgress=!0,yield{header:e,readData:this.readBytes.bind(this,n)}):yield{header:e}}}readHeader(){if(this.frameInProgress)throw new Y("decoding frame already in progress");if(this.buffer.length<I)return;let t=Pt(this.buffer.subarray(0,I));return this.buffer.consume(I),t}async readBytes(t){if(this.buffer.length<t){for await(let r of this.source)if(this.buffer.append(r),this.buffer.length>=t)break}let e=this.buffer.sublist(0,t);return this.buffer.consume(t),this.frameInProgress=!1,e}};function _t(s){if(s[Symbol.iterator]!==void 0){let t=s[Symbol.iterator]();return t.return=void 0,{[Symbol.iterator](){return t}}}else if(s[Symbol.asyncIterator]!==void 0){let t=s[Symbol.asyncIterator]();return t.return=void 0,{[Symbol.asyncIterator](){return t}}}else throw new Error("a source must be either an iterable or an async iterable")}function st(s){let t=new Uint8Array(I);return t[1]=s.type,t[2]=s.flag>>>8,t[3]=s.flag,t[4]=s.streamID>>>24,t[5]=s.streamID>>>16,t[6]=s.streamID>>>8,t[7]=s.streamID,t[8]=s.length>>>24,t[9]=s.length>>>16,t[10]=s.length>>>8,t[11]=s.length,t}var j=class extends Error{type;code;constructor(t,e,r){super(t??"The operation was aborted"),this.type="aborted",this.name=r??"AbortError",this.code=e??"ABORT_ERR"}};async function R(s,t,e){if(t==null)return s;if(t.aborted)return s.catch(()=>{}),Promise.reject(new j(e?.errorMessage,e?.errorCode,e?.errorName));let r,n=new j(e?.errorMessage,e?.errorCode,e?.errorName);try{return await Promise.race([s,new Promise((i,o)=>{r=()=>{o(n)},t.addEventListener("abort",r)})])}finally{r!=null&&t.removeEventListener("abort",r)}}function gt(s){return s==null?!1:typeof s.then=="function"&&typeof s.catch=="function"&&typeof s.finally=="function"}function wt(s,t){let e=V(s).return?.();gt(e)&&e.catch(r=>{t.error("could not cause iterator to return",r)})}var Ut=5e3;function nt(s){return s==null?!1:typeof s.then=="function"&&typeof s.catch=="function"&&typeof s.finally=="function"}var J=class{id;direction;timeline;protocol;metadata;source;status;readStatus;writeStatus;log;sinkController;sinkEnd;closed;endErr;streamSource;onEnd;onCloseRead;onCloseWrite;onReset;onAbort;sendCloseWriteTimeout;sendingData;constructor(t){this.sinkController=new AbortController,this.sinkEnd=E(),this.closed=E(),this.log=t.log,this.status="open",this.readStatus="ready",this.writeStatus="ready",this.id=t.id,this.metadata=t.metadata??{},this.direction=t.direction,this.timeline={open:Date.now()},this.sendCloseWriteTimeout=t.sendCloseWriteTimeout??Ut,this.onEnd=t.onEnd,this.onCloseRead=t.onCloseRead,this.onCloseWrite=t.onCloseWrite,this.onReset=t.onReset,this.onAbort=t.onAbort,this.source=this.streamSource=B({onEnd:e=>{e!=null?this.log.trace("source ended with error",e):this.log.trace("source ended"),this.onSourceEnd(e)}}),this.sink=this.sink.bind(this)}async sink(t){if(this.writeStatus!=="ready")throw new F(`writable end state is "${this.writeStatus}" not "ready"`);try{this.writeStatus="writing";let e={signal:this.sinkController.signal};if(this.direction==="outbound"){let n=this.sendNewStream(e);nt(n)&&await n}let r=()=>{wt(t,this.log)};try{this.sinkController.signal.addEventListener("abort",r),this.log.trace("sink reading from source");for await(let n of t){n=n instanceof Uint8Array?new v(n):n;let i=this.sendData(n,e);nt(i)&&(this.sendingData=E(),await i,this.sendingData.resolve(),this.sendingData=void 0)}}finally{this.sinkController.signal.removeEventListener("abort",r)}this.log.trace('sink finished reading from source, write status is "%s"',this.writeStatus),this.writeStatus==="writing"&&(this.writeStatus="closing",this.log.trace("send close write to remote"),await this.sendCloseWrite({signal:AbortSignal.timeout(this.sendCloseWriteTimeout)}),this.writeStatus="closed"),this.onSinkEnd()}catch(e){throw this.log.trace("sink ended with error, calling abort with error",e),this.abort(e),e}finally{this.log.trace("resolve sink end"),this.sinkEnd.resolve()}}onSourceEnd(t){this.timeline.closeRead==null&&(this.timeline.closeRead=Date.now(),this.readStatus="closed",t!=null&&this.endErr==null&&(this.endErr=t),this.onCloseRead?.(),this.timeline.closeWrite!=null?(this.log.trace("source and sink ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("source ended, waiting for sink to end"))}onSinkEnd(t){this.timeline.closeWrite==null&&(this.timeline.closeWrite=Date.now(),this.writeStatus="closed",t!=null&&this.endErr==null&&(this.endErr=t),this.onCloseWrite?.(),this.timeline.closeRead!=null?(this.log.trace("sink and source ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("sink ended, waiting for source to end"))}async close(t){this.status==="open"&&(this.log.trace("closing gracefully"),this.status="closing",await R(Promise.all([this.closeWrite(t),this.closeRead(t),this.closed.promise]),t?.signal),this.status="closed",this.log.trace("closed gracefully"))}async closeRead(t={}){if(this.readStatus==="closing"||this.readStatus==="closed")return;this.log.trace('closing readable end of stream with starting read status "%s"',this.readStatus);let e=this.readStatus;this.readStatus="closing",this.status!=="reset"&&this.status!=="aborted"&&this.timeline.closeRead==null&&(this.log.trace("send close read to remote"),await this.sendCloseRead(t)),e==="ready"&&(this.log.trace("ending internal source queue with %d queued bytes",this.streamSource.readableLength),this.streamSource.end()),this.log.trace("closed readable end of stream")}async closeWrite(t={}){this.writeStatus==="closing"||this.writeStatus==="closed"||(this.log.trace('closing writable end of stream with starting write status "%s"',this.writeStatus),this.writeStatus==="ready"&&(this.log.trace("sink was never sunk, sink an empty array"),await R(this.sink([]),t.signal)),this.writeStatus==="writing"&&(this.sendingData!=null&&await R(this.sendingData.promise,t.signal),this.log.trace("aborting source passed to .sink"),this.sinkController.abort(),await R(this.sinkEnd.promise,t.signal)),this.writeStatus="closed",this.log.trace("closed writable end of stream"))}abort(t){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;this.log("abort with error",t),this.log("try to send reset to remote");let e=this.sendReset();nt(e)&&e.catch(r=>{this.log.error("error sending reset message",r)}),this.status="aborted",this.timeline.abort=Date.now(),this._closeSinkAndSource(t),this.onAbort?.(t)}reset(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;let t=new O("stream reset");this.status="reset",this.timeline.reset=Date.now(),this._closeSinkAndSource(t),this.onReset?.()}_closeSinkAndSource(t){this._closeSink(t),this._closeSource(t)}_closeSink(t){this.writeStatus==="writing"&&(this.log.trace("end sink source"),this.sinkController.abort()),this.onSinkEnd(t)}_closeSource(t){this.readStatus!=="closing"&&this.readStatus!=="closed"&&(this.log.trace("ending source with %d bytes to be read by consumer",this.streamSource.readableLength),this.readStatus="closing",this.streamSource.end(t))}remoteCloseWrite(){if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("received remote close write but local source is already closed");return}this.log.trace("remote close write"),this._closeSource()}remoteCloseRead(){if(this.writeStatus==="closing"||this.writeStatus==="closed"){this.log("received remote close read but local sink is already closed");return}this.log.trace("remote close read"),this._closeSink()}destroy(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset"){this.log("received destroy but we are already closed");return}this.log.trace("stream destroyed"),this._closeSinkAndSource()}sourcePush(t){this.streamSource.push(t)}sourceReadableLength(){return this.streamSource.readableLength}};function Rt(s){let[t,e]=s[Symbol.asyncIterator]!=null?[s[Symbol.asyncIterator](),Symbol.asyncIterator]:[s[Symbol.iterator](),Symbol.iterator],r=[];return{peek:()=>t.next(),push:n=>{r.push(n)},next:()=>r.length>0?{done:!1,value:r.shift()}:t.next(),[e](){return this}}}var bt=Rt;function Tt(s){return s[Symbol.asyncIterator]!=null}function yt(s){return s?.then!=null}function Nt(s,t){let e=0;if(Tt(s))return async function*(){for await(let l of s){let f=t(l,e++);yt(f)&&await f,yield l}}();let r=bt(s),{value:n,done:i}=r.next();if(i===!0)return function*(){}();if(typeof t(n,e++)?.then=="function")return async function*(){yield n;for(let l of r){let f=t(l,e++);yt(f)&&await f,yield l}}();let a=t;return function*(){yield n;for(let l of r)a(l,e++),yield l}()}var xt=Nt;var g;(function(s){s[s.Init=0]="Init",s[s.SYNSent=1]="SYNSent",s[s.SYNReceived=2]="SYNReceived",s[s.Established=3]="Established",s[s.Finished=4]="Finished"})(g||(g={}));var Q=class extends J{name;state;config;_id;sendWindowCapacity;sendWindowCapacityUpdate;recvWindow;recvWindowCapacity;epochStart;getRTT;sendFrame;constructor(t){super({...t,onEnd:e=>{this.state=g.Finished,t.onEnd?.(e)}}),this.config=t.config,this._id=parseInt(t.id,10),this.name=t.name,this.state=t.state,this.sendWindowCapacity=U,this.recvWindow=this.config.initialStreamWindowSize,this.recvWindowCapacity=this.recvWindow,this.epochStart=Date.now(),this.getRTT=t.getRTT,this.sendFrame=t.sendFrame,this.source=xt(this.source,()=>{this.sendWindowUpdate()})}async sendNewStream(){}async sendData(t,e={}){for(t=t.sublist();t.byteLength!==0;){if(this.sendWindowCapacity===0&&(this.log?.trace("wait for send window capacity, status %s",this.status),await this.waitForSendWindowCapacity(e),this.status==="closed"||this.status==="aborted"||this.status==="reset")){this.log?.trace("%s while waiting for send window capacity",this.status);return}let r=Math.min(this.sendWindowCapacity,this.config.maxMessageSize-I,t.length),n=this.getSendFlags();this.sendFrame({type:h.Data,flag:n,streamID:this._id,length:r},t.sublist(0,r)),this.sendWindowCapacity-=r,t.consume(r)}}async sendReset(){this.sendFrame({type:h.WindowUpdate,flag:u.RST,streamID:this._id,length:0})}async sendCloseWrite(){let t=this.getSendFlags()|u.FIN;this.sendFrame({type:h.WindowUpdate,flag:t,streamID:this._id,length:0})}async sendCloseRead(){}async waitForSendWindowCapacity(t={}){if(this.sendWindowCapacity>0)return;let e,r,n=()=>{this.status==="open"||this.status==="closing"?r(new M("Stream aborted")):e()};t.signal?.addEventListener("abort",n);try{await new Promise((i,o)=>{this.sendWindowCapacityUpdate=()=>{i()},r=o,e=i})}finally{t.signal?.removeEventListener("abort",n)}}handleWindowUpdate(t){this.log?.trace("stream received window update id=%s",this._id),this.processFlags(t.flag);let e=this.sendWindowCapacity;this.sendWindowCapacity+=t.length,e===0&&t.length>0&&this.sendWindowCapacityUpdate?.()}async handleData(t,e){if(this.log?.trace("stream received data id=%s",this._id),this.processFlags(t.flag),this.recvWindowCapacity<t.length)throw new P("Receive window exceeded");let r=await e();this.recvWindowCapacity-=t.length,this.sourcePush(r)}processFlags(t){(t&u.ACK)===u.ACK&&this.state===g.SYNSent&&(this.state=g.Established),(t&u.FIN)===u.FIN&&this.remoteCloseWrite(),(t&u.RST)===u.RST&&this.reset()}getSendFlags(){switch(this.state){case g.Init:return this.state=g.SYNSent,u.SYN;case g.SYNReceived:return this.state=g.Established,u.ACK;default:return 0}}sendWindowUpdate(){let t=this.getSendFlags(),e=Date.now(),r=this.getRTT();if(t===0&&r>-1&&e-this.epochStart<r*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.config.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&t===0)return;let n=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=e,this.sendFrame({type:h.WindowUpdate,flag:t,streamID:this._id,length:n})}};var St="/yamux/1.0.0",Mt=500,Z=class{protocol=St;_components;_init;constructor(t,e={}){this._components=t,this._init=e}[Symbol.toStringTag]="@chainsafe/libp2p-yamux";[ot]=["@libp2p/stream-multiplexing"];createStreamMuxer(t){return new it(this._components,{...this._init,...t})}},it=class{protocol=St;source;sink;config;log;logger;closeController;nextStreamID;_streams;nextPingID;activePing;rtt;client;localGoAway;remoteGoAway;numInboundStreams;numOutboundStreams;onIncomingStream;onStreamEnd;constructor(t,e){this.client=e.direction==="outbound",this.config={...dt,...e},this.logger=t.logger,this.log=this.logger.forComponent("libp2p:yamux"),ft(this.config),this.closeController=new AbortController,this.closeController.signal,this.onIncomingStream=e.onIncomingStream,this.onStreamEnd=e.onStreamEnd,this._streams=new Map,this.source=B({onEnd:()=>{this.log?.trace("muxer source ended"),this._streams.forEach(r=>{r.destroy()})}}),this.sink=async r=>{let n=()=>{let a=V(r);if(a.return!=null){let l=a.return();Ot(l)&&l.catch(f=>{this.log?.("could not cause sink source to return",f)})}},i,o;try{let a=new X(r);try{this.closeController.signal.addEventListener("abort",n);for await(let l of a.emitFrames())await this.handleFrame(l.header,l.readData)}finally{this.closeController.signal.removeEventListener("abort",n)}i=p.NormalTermination}catch(a){ut.has(a.name)?(this.log?.error("protocol error in sink",a),i=p.ProtocolError):(this.log?.error("internal error in sink",a),i=p.InternalError),o=a}this.log?.trace("muxer sink ended"),o!=null?this.abort(o,i):await this.close({reason:i})},this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=-1,this.log?.trace("muxer created"),this.config.enableKeepAlive&&this.keepAliveLoop().catch(r=>this.log?.error("keepalive error: %s",r)),this.ping().catch(r=>this.log?.error("ping error: %s",r))}get streams(){return Array.from(this._streams.values())}newStream(t){if(this.remoteGoAway!==void 0)throw new S("Muxer closed remotely");if(this.localGoAway!==void 0)throw new S("Muxer closed locally");let e=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.config.maxOutboundStreams)throw new z("max outbound streams exceeded");this.log?.trace("new outgoing stream id=%s",e);let r=this._newStream(e,t,g.Init,"outbound");return this._streams.set(e,r),this.numOutboundStreams++,r.sendWindowUpdate(),r}async ping(){if(this.remoteGoAway!==void 0)throw new S("Muxer closed remotely");if(this.localGoAway!==void 0)throw new S("Muxer closed locally");if(this.activePing===void 0){let t=()=>{};this.activePing={id:this.nextPingID++,promise:new Promise((n,i)=>{let o=()=>{i(new S("Muxer closed locally"))};this.closeController.signal.addEventListener("abort",o,{once:!0}),t=()=>{this.closeController.signal.removeEventListener("abort",o),n()}}),resolve:t};let e=Date.now();this.sendPing(this.activePing.id);try{await this.activePing.promise}finally{delete this.activePing}let r=Date.now();this.rtt=r-e}else await this.activePing.promise;return this.rtt}getRTT(){return this.rtt}async close(t={}){if(this.closeController.signal.aborted)return;let e=t?.reason??p.NormalTermination;if(this.log?.trace("muxer close reason=%s",e),t.signal==null){let r=AbortSignal.timeout(Mt);t={...t,signal:r}}try{await Promise.all([...this._streams.values()].map(async r=>r.close(t))),this.sendGoAway(e),this._closeMuxer()}catch(r){this.abort(r)}}abort(t,e){if(!this.closeController.signal.aborted){e=e??p.InternalError,this.log?.error("muxer abort reason=%s error=%s",e,t);for(let r of this._streams.values())r.abort(t);this.sendGoAway(e),this._closeMuxer()}}isClosed(){return this.closeController.signal.aborted}_closeMuxer(){this.closeController.abort(),this.source.end()}_newStream(t,e,r,n){if(this._streams.get(t)!=null)throw new m("Stream already exists with that id");let i=new Q({id:t.toString(),name:e,state:r,direction:n,sendFrame:this.sendFrame.bind(this),onEnd:()=>{this.closeStream(t),this.onStreamEnd?.(i)},log:this.logger.forComponent(`libp2p:yamux:${n}:${t}`),config:this.config,getRTT:this.getRTT.bind(this)});return i}closeStream(t){this.client===(t%2===0)?this.numInboundStreams--:this.numOutboundStreams--,this._streams.delete(t)}async keepAliveLoop(){let t=new Promise((e,r)=>{this.closeController.signal.addEventListener("abort",r,{once:!0})});for(this.log?.trace("muxer keepalive enabled interval=%s",this.config.keepAliveInterval);;){let e;try{await Promise.race([t,new Promise(r=>{e=setTimeout(r,this.config.keepAliveInterval)})]),this.ping().catch(r=>this.log?.error("ping error: %s",r))}catch{clearInterval(e);return}}}async handleFrame(t,e){let{streamID:r,type:n,length:i}=t;if(this.log?.trace("received frame %o",t),r===0)switch(n){case h.Ping:{this.handlePing(t);return}case h.GoAway:{this.handleGoAway(i);return}default:throw new w("Invalid frame type")}else switch(t.type){case h.Data:case h.WindowUpdate:{await this.handleStreamMessage(t,e);return}default:throw new w("Invalid frame type")}}handlePing(t){if(t.flag===u.SYN)this.log?.trace("received ping request pingId=%s",t.length),this.sendPing(t.length,u.ACK);else if(t.flag===u.ACK)this.log?.trace("received ping response pingId=%s",t.length),this.handlePingResponse(t.length);else throw new w("Invalid frame flag")}handlePingResponse(t){if(this.activePing===void 0)throw new W("ping not requested");if(this.activePing.id!==t)throw new k("ping doesn't match our id");this.activePing.resolve()}handleGoAway(t){this.log?.trace("received GoAway reason=%s",p[t]??"unknown"),this.remoteGoAway=t;for(let e of this._streams.values())e.reset();this._closeMuxer()}async handleStreamMessage(t,e){let{streamID:r,flag:n,type:i}=t;(n&u.SYN)===u.SYN&&this.incomingStream(r);let o=this._streams.get(r);if(o===void 0){if(i===h.Data){if(this.log?.("discarding data for stream id=%s",r),e===void 0)throw new Error("unreachable");await e()}else this.log?.trace("frame for missing stream id=%s",r);return}switch(i){case h.WindowUpdate:{o.handleWindowUpdate(t);return}case h.Data:{if(e===void 0)throw new Error("unreachable");await o.handleData(t,e);return}default:throw new Error("unreachable")}}incomingStream(t){if(this.client!==(t%2===0))throw new m("Both endpoints are clients");if(this._streams.has(t))return;if(this.log?.trace("new incoming stream id=%s",t),this.localGoAway!==void 0){this.sendFrame({type:h.WindowUpdate,flag:u.RST,streamID:t,length:0});return}if(this.numInboundStreams>=this.config.maxInboundStreams){this.log?.("maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:h.WindowUpdate,flag:u.RST,streamID:t,length:0});return}let e=this._newStream(t,void 0,g.SYNReceived,"inbound");this.numInboundStreams++,this._streams.set(t,e),this.onIncomingStream?.(e)}sendFrame(t,e){if(this.log?.trace("sending frame %o",t),t.type===h.Data){if(e===void 0)throw new w("Invalid frame");this.source.push(new v(st(t),e))}else this.source.push(st(t))}sendPing(t,e=u.SYN){e===u.SYN?this.log?.trace("sending ping request pingId=%s",t):this.log?.trace("sending ping response pingId=%s",t),this.sendFrame({type:h.Ping,flag:e,streamID:0,length:t})}sendGoAway(t=p.NormalTermination){this.log?.("sending GoAway reason=%s",p[t]),this.localGoAway=t,this.sendFrame({type:h.GoAway,flag:0,streamID:0,length:t})}};function Ot(s){return s!=null&&typeof s.then=="function"}function Ft(s={}){return t=>new Z(t,s)}return Wt(zt);})();
+"use strict";var ChainsafeLibp2PYamux=(()=>{var tt=Object.defineProperty;var It=Object.getOwnPropertyDescriptor;var At=Object.getOwnPropertyNames;var Ct=Object.prototype.hasOwnProperty;var Lt=(s,t)=>{for(var e in t)tt(s,e,{get:t[e],enumerable:!0})},Dt=(s,t,e,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of At(t))!Ct.call(s,n)&&n!==e&&tt(s,n,{get:()=>t[n],enumerable:!(r=It(t,n))||r.enumerable});return s};var Wt=s=>Dt(tt({},"__esModule",{value:!0}),s);var zt={};Lt(zt,{GoAwayCode:()=>p,yamux:()=>Ft});var M=class extends Error{static name="AbortError";constructor(t="The operation was aborted"){super(t),this.name="AbortError"}};var m=class extends Error{static name="InvalidParametersError";constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}};var S=class extends Error{static name="MuxerClosedError";constructor(t="The muxer is closed"){super(t),this.name="MuxerClosedError"}},O=class extends Error{static name="StreamResetError";constructor(t="The stream has been reset"){super(t),this.name="StreamResetError"}},F=class extends Error{static name="StreamStateError";constructor(t="The stream is in an invalid state"){super(t),this.name="StreamStateError"}};var z=class extends Error{static name="TooManyOutboundProtocolStreamsError";constructor(t="Too many outbound protocol streams"){super(t),this.name="TooManyOutboundProtocolStreamsError"}};var ot=Symbol.for("@libp2p/service-capabilities"),qt=Symbol.for("@libp2p/service-dependencies");function V(s){if(s!=null){if(typeof s[Symbol.iterator]=="function")return s[Symbol.iterator]();if(typeof s[Symbol.asyncIterator]=="function")return s[Symbol.asyncIterator]();if(typeof s.next=="function")return s}throw new Error("argument is not an iterator or iterable")}function E(){let s={};return s.promise=new Promise((t,e)=>{s.resolve=t,s.reject=e}),s}var G=class{buffer;mask;top;btm;next;constructor(t){if(!(t>0)||(t-1&t)!==0)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(t),this.mask=t-1,this.top=0,this.btm=0,this.next=null}push(t){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=t,this.top=this.top+1&this.mask,!0)}shift(){let t=this.buffer[this.btm];if(t!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,t}isEmpty(){return this.buffer[this.btm]===void 0}},W=class{size;hwm;head;tail;constructor(t={}){this.hwm=t.splitLimit??16,this.head=new G(this.hwm),this.tail=this.head,this.size=0}calculateSize(t){return t?.byteLength!=null?t.byteLength:1}push(t){if(t?.value!=null&&(this.size+=this.calculateSize(t.value)),!this.head.push(t)){let e=this.head;this.head=e.next=new G(2*this.head.buffer.length),this.head.push(t)}}shift(){let t=this.tail.shift();if(t===void 0&&this.tail.next!=null){let e=this.tail.next;this.tail.next=null,this.tail=e,t=this.tail.shift()}return t?.value!=null&&(this.size-=this.calculateSize(t.value)),t}isEmpty(){return this.head.isEmpty()}};var et=class extends Error{type;code;constructor(t,e){super(t??"The operation was aborted"),this.type="aborted",this.code=e??"ABORT_ERR"}};function B(s={}){return kt(e=>{let r=e.shift();if(r==null)return{done:!0};if(r.error!=null)throw r.error;return{done:r.done===!0,value:r.value}},s)}function kt(s,t){t=t??{};let e=t.onEnd,r=new W,n,i,o,a=E(),l=async()=>{try{return r.isEmpty()?o?{done:!0}:await new Promise((c,A)=>{i=N=>{i=null,r.push(N);try{c(s(r))}catch(D){A(D)}return n}}):s(r)}finally{r.isEmpty()&&queueMicrotask(()=>{a.resolve(),a=E()})}},f=c=>i!=null?i(c):(r.push(c),n),b=c=>(r=new W,i!=null?i({error:c}):(r.push({error:c}),n)),d=c=>{if(o)return n;if(t?.objectMode!==!0&&c?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return f({done:!1,value:c})},y=c=>o?n:(o=!0,c!=null?b(c):f({done:!0})),T=()=>(r=new W,y(),{done:!0}),Et=c=>(y(c),{done:!0});if(n={[Symbol.asyncIterator](){return this},next:l,return:T,throw:Et,push:d,end:y,get readableLength(){return r.size},onEmpty:async c=>{let A=c?.signal;if(A?.throwIfAborted(),r.isEmpty())return;let N,D;A!=null&&(N=new Promise((Vt,vt)=>{D=()=>{vt(new et)},A.addEventListener("abort",D)}));try{await Promise.race([a.promise,N])}finally{D!=null&&A!=null&&A?.removeEventListener("abort",D)}}},e==null)return n;let L=n;return n={[Symbol.asyncIterator](){return this},next(){return L.next()},throw(c){return L.throw(c),e!=null&&(e(c),e=void 0),{done:!0}},return(){return L.return(),e!=null&&(e(),e=void 0),{done:!0}},push:d,end(c){return L.end(c),e!=null&&(e(c),e=void 0),n},get readableLength(){return L.readableLength},onEmpty:c=>L.onEmpty(c)},n}var q=class extends Error{type;code;constructor(t,e,r){super(t??"The operation was aborted"),this.type="aborted",this.name=r??"AbortError",this.code=e??"ABORT_ERR"}};async function C(s,t,e){if(t==null)return s;if(t.aborted)return s.catch(()=>{}),Promise.reject(new q(e?.errorMessage,e?.errorCode,e?.errorName));let r,n=new q(e?.errorMessage,e?.errorCode,e?.errorName);try{return await Promise.race([s,new Promise((i,o)=>{r=()=>{o(n)},t.addEventListener("abort",r)})])}finally{r!=null&&t.removeEventListener("abort",r)}}function x(s=0){return new Uint8Array(s)}function P(s=0){return new Uint8Array(s)}function rt(s,t){t==null&&(t=s.reduce((n,i)=>n+i.length,0));let e=P(t),r=0;for(let n of s)e.set(n,r),r+=n.length;return e}function at(s,t){if(s===t)return!0;if(s.byteLength!==t.byteLength)return!1;for(let e=0;e<s.byteLength;e++)if(s[e]!==t[e])return!1;return!0}var ct=Symbol.for("@achingbrain/uint8arraylist");function lt(s,t){if(t==null||t<0)throw new RangeError("index is out of bounds");let e=0;for(let r of s){let n=e+r.byteLength;if(t<n)return{buf:r,index:t-e};e=n}throw new RangeError("index is out of bounds")}function Y(s){return!!s?.[ct]}var v=class s{bufs;length;[ct]=!0;constructor(...t){this.bufs=[],this.length=0,t.length>0&&this.appendAll(t)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...t){this.appendAll(t)}appendAll(t){let e=0;for(let r of t)if(r instanceof Uint8Array)e+=r.byteLength,this.bufs.push(r);else if(Y(r))e+=r.byteLength,this.bufs.push(...r.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}prepend(...t){this.prependAll(t)}prependAll(t){let e=0;for(let r of t.reverse())if(r instanceof Uint8Array)e+=r.byteLength,this.bufs.unshift(r);else if(Y(r))e+=r.byteLength,this.bufs.unshift(...r.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}get(t){let e=lt(this.bufs,t);return e.buf[e.index]}set(t,e){let r=lt(this.bufs,t);r.buf[r.index]=e}write(t,e=0){if(t instanceof Uint8Array)for(let r=0;r<t.length;r++)this.set(e+r,t[r]);else if(Y(t))for(let r=0;r<t.length;r++)this.set(e+r,t.get(r));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(t){if(t=Math.trunc(t),!(Number.isNaN(t)||t<=0)){if(t===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(t>=this.bufs[0].byteLength)t-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(t),this.length-=t;break}}}slice(t,e){let{bufs:r,length:n}=this._subList(t,e);return rt(r,n)}subarray(t,e){let{bufs:r,length:n}=this._subList(t,e);return r.length===1?r[0]:rt(r,n)}sublist(t,e){let{bufs:r,length:n}=this._subList(t,e),i=new s;return i.length=n,i.bufs=[...r],i}_subList(t,e){if(t=t??0,e=e??this.length,t<0&&(t=this.length+t),e<0&&(e=this.length+e),t<0||e>this.length)throw new RangeError("index is out of bounds");if(t===e)return{bufs:[],length:0};if(t===0&&e===this.length)return{bufs:this.bufs,length:this.length};let r=[],n=0;for(let i=0;i<this.bufs.length;i++){let o=this.bufs[i],a=n,l=a+o.byteLength;if(n=l,t>=l)continue;let f=t>=a&&t<l,b=e>a&&e<=l;if(f&&b){if(t===a&&e===l){r.push(o);break}let d=t-a;r.push(o.subarray(d,d+(e-t)));break}if(f){if(t===0){r.push(o);continue}r.push(o.subarray(t-a));continue}if(b){if(e===l){r.push(o);break}r.push(o.subarray(0,e-a));break}r.push(o)}return{bufs:r,length:e-t}}indexOf(t,e=0){if(!Y(t)&&!(t instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');let r=t instanceof Uint8Array?t:t.subarray();if(e=Number(e??0),isNaN(e)&&(e=0),e<0&&(e=this.length+e),e<0&&(e=0),t.length===0)return e>this.length?this.length:e;let n=r.byteLength;if(n===0)throw new TypeError("search must be at least 1 byte long");let i=256,o=new Int32Array(i);for(let d=0;d<i;d++)o[d]=-1;for(let d=0;d<n;d++)o[r[d]]=d;let a=o,l=this.byteLength-r.byteLength,f=r.byteLength-1,b;for(let d=e;d<=l;d+=b){b=0;for(let y=f;y>=0;y--){let T=this.get(d+y);if(r[y]!==T){b=Math.max(1,y-a[T]);break}}if(b===0)return d}return-1}getInt8(t){let e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getInt8(0)}setInt8(t,e){let r=P(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setInt8(0,e),this.write(r,t)}getInt16(t,e){let r=this.subarray(t,t+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt16(0,e)}setInt16(t,e,r){let n=x(2);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt16(0,e,r),this.write(n,t)}getInt32(t,e){let r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt32(0,e)}setInt32(t,e,r){let n=x(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt32(0,e,r),this.write(n,t)}getBigInt64(t,e){let r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigInt64(0,e)}setBigInt64(t,e,r){let n=x(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setBigInt64(0,e,r),this.write(n,t)}getUint8(t){let e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getUint8(0)}setUint8(t,e){let r=P(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setUint8(0,e),this.write(r,t)}getUint16(t,e){let r=this.subarray(t,t+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint16(0,e)}setUint16(t,e,r){let n=x(2);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint16(0,e,r),this.write(n,t)}getUint32(t,e){let r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint32(0,e)}setUint32(t,e,r){let n=x(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint32(0,e,r),this.write(n,t)}getBigUint64(t,e){let r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigUint64(0,e)}setBigUint64(t,e,r){let n=x(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setBigUint64(0,e,r),this.write(n,t)}getFloat32(t,e){let r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat32(0,e)}setFloat32(t,e,r){let n=x(4);new DataView(n.buffer,n.byteOffset,n.byteLength).setFloat32(0,e,r),this.write(n,t)}getFloat64(t,e){let r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat64(0,e)}setFloat64(t,e,r){let n=x(8);new DataView(n.buffer,n.byteOffset,n.byteLength).setFloat64(0,e,r),this.write(n,t)}equals(t){if(t==null||!(t instanceof s)||t.bufs.length!==this.bufs.length)return!1;for(let e=0;e<this.bufs.length;e++)if(!at(this.bufs[e],t.bufs[e]))return!1;return!0}static fromUint8Arrays(t,e){let r=new s;return r.bufs=t,e==null&&(e=t.reduce((n,i)=>n+i.byteLength,0)),r.length=e,r}};var w=class extends Error{static name="InvalidFrameError";constructor(t="The frame was invalid"){super(t),this.name="InvalidFrameError"}},k=class extends Error{static name="UnrequestedPingError";constructor(t="Unrequested ping error"){super(t),this.name="UnrequestedPingError"}},U=class extends Error{static name="NotMatchingPingError";constructor(t="Unrequested ping error"){super(t),this.name="NotMatchingPingError"}},H=class extends Error{static name="InvalidStateError";constructor(t="Invalid state"){super(t),this.name="InvalidStateError"}},K=class extends Error{static name="StreamAlreadyExistsError";constructor(t="Strean already exists"){super(t),this.name="StreamAlreadyExistsError"}},$=class extends Error{static name="DecodeInvalidVersionError";constructor(t="Decode invalid version"){super(t),this.name="DecodeInvalidVersionError"}},X=class extends Error{static name="BothClientsError";constructor(t="Both clients"){super(t),this.name="BothClientsError"}},_=class extends Error{static name="ReceiveWindowExceededError";constructor(t="Receive window exceeded"){super(t),this.name="ReceiveWindowExceededError"}};var ut=new Set([w.name,k.name,U.name,K.name,$.name,X.name,_.name]),R=256*1024,ht=16*1024*1024;var dt={enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3,initialStreamWindowSize:R,maxStreamWindowSize:ht,maxMessageSize:64*1024};function ft(s){if(s.keepAliveInterval<=0)throw new m("keep-alive interval must be positive");if(s.maxInboundStreams<0)throw new m("max inbound streams must be larger or equal 0");if(s.maxOutboundStreams<0)throw new m("max outbound streams must be larger or equal 0");if(s.initialStreamWindowSize<R)throw new m("InitialStreamWindowSize must be larger or equal 256 kB");if(s.maxStreamWindowSize<s.initialStreamWindowSize)throw new m("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");if(s.maxStreamWindowSize>2**32-1)throw new m("MaxStreamWindowSize must be less than equal MAX_UINT32");if(s.maxMessageSize<1024)throw new m("MaxMessageSize must be greater than a kilobyte")}var h;(function(s){s[s.Data=0]="Data",s[s.WindowUpdate=1]="WindowUpdate",s[s.Ping=2]="Ping",s[s.GoAway=3]="GoAway"})(h||(h={}));var u;(function(s){s[s.SYN=1]="SYN",s[s.ACK=2]="ACK",s[s.FIN=4]="FIN",s[s.RST=8]="RST"})(u||(u={}));var Ne=Object.values(u).filter(s=>typeof s!="string"),mt=0,p;(function(s){s[s.NormalTermination=0]="NormalTermination",s[s.ProtocolError=1]="ProtocolError",s[s.InternalError=2]="InternalError"})(p||(p={}));var I=12;var pt=2**24;function Ut(s){if(s[0]!==mt)throw new w("Invalid frame version");return{type:s[1],flag:(s[2]<<8)+s[3],streamID:s[4]*pt+(s[5]<<16)+(s[6]<<8)+s[7],length:s[8]*pt+(s[9]<<16)+(s[10]<<8)+s[11]}}var j=class{source;buffer;frameInProgress;constructor(t){this.source=_t(t),this.buffer=new v,this.frameInProgress=!1}async*emitFrames(){for await(let t of this.source)for(this.buffer.append(t);;){let e=this.readHeader();if(e===void 0)break;let{type:r,length:n}=e;r===h.Data?(this.frameInProgress=!0,yield{header:e,readData:this.readBytes.bind(this,n)}):yield{header:e}}}readHeader(){if(this.frameInProgress)throw new H("decoding frame already in progress");if(this.buffer.length<I)return;let t=Ut(this.buffer.subarray(0,I));return this.buffer.consume(I),t}async readBytes(t){if(this.buffer.length<t){for await(let r of this.source)if(this.buffer.append(r),this.buffer.length>=t)break}let e=this.buffer.sublist(0,t);return this.buffer.consume(t),this.frameInProgress=!1,e}};function _t(s){if(s[Symbol.iterator]!==void 0){let t=s[Symbol.iterator]();return t.return=void 0,{[Symbol.iterator](){return t}}}else if(s[Symbol.asyncIterator]!==void 0){let t=s[Symbol.asyncIterator]();return t.return=void 0,{[Symbol.asyncIterator](){return t}}}else throw new Error("a source must be either an iterable or an async iterable")}function st(s){let t=new Uint8Array(I);return t[1]=s.type,t[2]=s.flag>>>8,t[3]=s.flag,t[4]=s.streamID>>>24,t[5]=s.streamID>>>16,t[6]=s.streamID>>>8,t[7]=s.streamID,t[8]=s.length>>>24,t[9]=s.length>>>16,t[10]=s.length>>>8,t[11]=s.length,t}function gt(s){return s==null?!1:typeof s.then=="function"&&typeof s.catch=="function"&&typeof s.finally=="function"}function wt(s,t){let e=V(s).return?.();gt(e)&&e.catch(r=>{t.error("could not cause iterator to return",r)})}var Pt=5e3;function nt(s){return s==null?!1:typeof s.then=="function"&&typeof s.catch=="function"&&typeof s.finally=="function"}var J=class{id;direction;timeline;protocol;metadata;source;status;readStatus;writeStatus;log;sinkController;sinkEnd;closed;endErr;streamSource;onEnd;onCloseRead;onCloseWrite;onReset;onAbort;sendCloseWriteTimeout;sendingData;constructor(t){this.sinkController=new AbortController,this.sinkEnd=E(),this.closed=E(),this.log=t.log,this.status="open",this.readStatus="ready",this.writeStatus="ready",this.id=t.id,this.metadata=t.metadata??{},this.direction=t.direction,this.timeline={open:Date.now()},this.sendCloseWriteTimeout=t.sendCloseWriteTimeout??Pt,this.onEnd=t.onEnd,this.onCloseRead=t.onCloseRead,this.onCloseWrite=t.onCloseWrite,this.onReset=t.onReset,this.onAbort=t.onAbort,this.source=this.streamSource=B({onEnd:e=>{e!=null?this.log.trace("source ended with error",e):this.log.trace("source ended"),this.onSourceEnd(e)}}),this.sink=this.sink.bind(this)}async sink(t){if(this.writeStatus!=="ready")throw new F(`writable end state is "${this.writeStatus}" not "ready"`);try{this.writeStatus="writing";let e={signal:this.sinkController.signal};if(this.direction==="outbound"){let n=this.sendNewStream(e);nt(n)&&await n}let r=()=>{wt(t,this.log)};try{this.sinkController.signal.addEventListener("abort",r),this.log.trace("sink reading from source");for await(let n of t){n=n instanceof Uint8Array?new v(n):n;let i=this.sendData(n,e);nt(i)&&(this.sendingData=E(),await i,this.sendingData.resolve(),this.sendingData=void 0)}}finally{this.sinkController.signal.removeEventListener("abort",r)}this.log.trace('sink finished reading from source, write status is "%s"',this.writeStatus),this.writeStatus==="writing"&&(this.writeStatus="closing",this.log.trace("send close write to remote"),await this.sendCloseWrite({signal:AbortSignal.timeout(this.sendCloseWriteTimeout)}),this.writeStatus="closed"),this.onSinkEnd()}catch(e){throw this.log.trace("sink ended with error, calling abort with error",e),this.abort(e),e}finally{this.log.trace("resolve sink end"),this.sinkEnd.resolve()}}onSourceEnd(t){this.timeline.closeRead==null&&(this.timeline.closeRead=Date.now(),this.readStatus="closed",t!=null&&this.endErr==null&&(this.endErr=t),this.onCloseRead?.(),this.timeline.closeWrite!=null?(this.log.trace("source and sink ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("source ended, waiting for sink to end"))}onSinkEnd(t){this.timeline.closeWrite==null&&(this.timeline.closeWrite=Date.now(),this.writeStatus="closed",t!=null&&this.endErr==null&&(this.endErr=t),this.onCloseWrite?.(),this.timeline.closeRead!=null?(this.log.trace("sink and source ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("sink ended, waiting for source to end"))}async close(t){this.status==="open"&&(this.log.trace("closing gracefully"),this.status="closing",await C(Promise.all([this.closeWrite(t),this.closeRead(t),this.closed.promise]),t?.signal),this.status="closed",this.log.trace("closed gracefully"))}async closeRead(t={}){if(this.readStatus==="closing"||this.readStatus==="closed")return;this.log.trace('closing readable end of stream with starting read status "%s"',this.readStatus);let e=this.readStatus;this.readStatus="closing",this.status!=="reset"&&this.status!=="aborted"&&this.timeline.closeRead==null&&(this.log.trace("send close read to remote"),await this.sendCloseRead(t)),e==="ready"&&(this.log.trace("ending internal source queue with %d queued bytes",this.streamSource.readableLength),this.streamSource.end()),this.log.trace("closed readable end of stream")}async closeWrite(t={}){this.writeStatus==="closing"||this.writeStatus==="closed"||(this.log.trace('closing writable end of stream with starting write status "%s"',this.writeStatus),this.writeStatus==="ready"&&(this.log.trace("sink was never sunk, sink an empty array"),await C(this.sink([]),t.signal)),this.writeStatus==="writing"&&(this.sendingData!=null&&await C(this.sendingData.promise,t.signal),this.log.trace("aborting source passed to .sink"),this.sinkController.abort(),await C(this.sinkEnd.promise,t.signal)),this.writeStatus="closed",this.log.trace("closed writable end of stream"))}abort(t){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;this.log("abort with error",t),this.log("try to send reset to remote");let e=this.sendReset();nt(e)&&e.catch(r=>{this.log.error("error sending reset message",r)}),this.status="aborted",this.timeline.abort=Date.now(),this._closeSinkAndSource(t),this.onAbort?.(t)}reset(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;let t=new O("stream reset");this.status="reset",this.timeline.reset=Date.now(),this._closeSinkAndSource(t),this.onReset?.()}_closeSinkAndSource(t){this._closeSink(t),this._closeSource(t)}_closeSink(t){this.writeStatus==="writing"&&(this.log.trace("end sink source"),this.sinkController.abort()),this.onSinkEnd(t)}_closeSource(t){this.readStatus!=="closing"&&this.readStatus!=="closed"&&(this.log.trace("ending source with %d bytes to be read by consumer",this.streamSource.readableLength),this.readStatus="closing",this.streamSource.end(t))}remoteCloseWrite(){if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("received remote close write but local source is already closed");return}this.log.trace("remote close write"),this._closeSource()}remoteCloseRead(){if(this.writeStatus==="closing"||this.writeStatus==="closed"){this.log("received remote close read but local sink is already closed");return}this.log.trace("remote close read"),this._closeSink()}destroy(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset"){this.log("received destroy but we are already closed");return}this.log.trace("stream destroyed"),this._closeSinkAndSource()}sourcePush(t){this.streamSource.push(t)}sourceReadableLength(){return this.streamSource.readableLength}};function Rt(s){let[t,e]=s[Symbol.asyncIterator]!=null?[s[Symbol.asyncIterator](),Symbol.asyncIterator]:[s[Symbol.iterator](),Symbol.iterator],r=[];return{peek:()=>t.next(),push:n=>{r.push(n)},next:()=>r.length>0?{done:!1,value:r.shift()}:t.next(),[e](){return this}}}var bt=Rt;function Tt(s){return s[Symbol.asyncIterator]!=null}function yt(s){return s?.then!=null}function Nt(s,t){let e=0;if(Tt(s))return async function*(){for await(let l of s){let f=t(l,e++);yt(f)&&await f,yield l}}();let r=bt(s),{value:n,done:i}=r.next();if(i===!0)return function*(){}();if(typeof t(n,e++)?.then=="function")return async function*(){yield n;for(let l of r){let f=t(l,e++);yt(f)&&await f,yield l}}();let a=t;return function*(){yield n;for(let l of r)a(l,e++),yield l}()}var xt=Nt;var g;(function(s){s[s.Init=0]="Init",s[s.SYNSent=1]="SYNSent",s[s.SYNReceived=2]="SYNReceived",s[s.Established=3]="Established",s[s.Finished=4]="Finished"})(g||(g={}));var Q=class extends J{name;state;config;_id;sendWindowCapacity;sendWindowCapacityUpdate;recvWindow;recvWindowCapacity;epochStart;getRTT;sendFrame;constructor(t){super({...t,onEnd:e=>{this.state=g.Finished,t.onEnd?.(e)}}),this.config=t.config,this._id=parseInt(t.id,10),this.name=t.name,this.state=t.state,this.sendWindowCapacity=R,this.recvWindow=this.config.initialStreamWindowSize,this.recvWindowCapacity=this.recvWindow,this.epochStart=Date.now(),this.getRTT=t.getRTT,this.sendFrame=t.sendFrame,this.source=xt(this.source,()=>{this.sendWindowUpdate()})}async sendNewStream(){}async sendData(t,e={}){for(t=t.sublist();t.byteLength!==0;){if(this.sendWindowCapacity===0&&(this.log?.trace("wait for send window capacity, status %s",this.status),await this.waitForSendWindowCapacity(e),this.status==="closed"||this.status==="aborted"||this.status==="reset")){this.log?.trace("%s while waiting for send window capacity",this.status);return}let r=Math.min(this.sendWindowCapacity,this.config.maxMessageSize-I,t.length),n=this.getSendFlags();this.sendFrame({type:h.Data,flag:n,streamID:this._id,length:r},t.sublist(0,r)),this.sendWindowCapacity-=r,t.consume(r)}}async sendReset(){this.sendFrame({type:h.WindowUpdate,flag:u.RST,streamID:this._id,length:0})}async sendCloseWrite(){let t=this.getSendFlags()|u.FIN;this.sendFrame({type:h.WindowUpdate,flag:t,streamID:this._id,length:0})}async sendCloseRead(){}async waitForSendWindowCapacity(t={}){if(this.sendWindowCapacity>0)return;let e,r,n=()=>{this.status==="open"||this.status==="closing"?r(new M("Stream aborted")):e()};t.signal?.addEventListener("abort",n);try{await new Promise((i,o)=>{this.sendWindowCapacityUpdate=()=>{i()},r=o,e=i})}finally{t.signal?.removeEventListener("abort",n)}}handleWindowUpdate(t){this.log?.trace("stream received window update id=%s",this._id),this.processFlags(t.flag);let e=this.sendWindowCapacity;this.sendWindowCapacity+=t.length,e===0&&t.length>0&&this.sendWindowCapacityUpdate?.()}async handleData(t,e){if(this.log?.trace("stream received data id=%s",this._id),this.processFlags(t.flag),this.recvWindowCapacity<t.length)throw new _("Receive window exceeded");let r=await e();this.recvWindowCapacity-=t.length,this.sourcePush(r)}processFlags(t){(t&u.ACK)===u.ACK&&this.state===g.SYNSent&&(this.state=g.Established),(t&u.FIN)===u.FIN&&this.remoteCloseWrite(),(t&u.RST)===u.RST&&this.reset()}getSendFlags(){switch(this.state){case g.Init:return this.state=g.SYNSent,u.SYN;case g.SYNReceived:return this.state=g.Established,u.ACK;default:return 0}}sendWindowUpdate(){let t=this.getSendFlags(),e=Date.now(),r=this.getRTT();if(t===0&&r>-1&&e-this.epochStart<r*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.config.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&t===0)return;let n=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=e,this.sendFrame({type:h.WindowUpdate,flag:t,streamID:this._id,length:n})}};var St="/yamux/1.0.0",Mt=500,Z=class{protocol=St;_components;_init;constructor(t,e={}){this._components=t,this._init=e}[Symbol.toStringTag]="@chainsafe/libp2p-yamux";[ot]=["@libp2p/stream-multiplexing"];createStreamMuxer(t){return new it(this._components,{...this._init,...t})}},it=class{protocol=St;source;sink;config;log;logger;closeController;nextStreamID;_streams;nextPingID;activePing;rtt;client;localGoAway;remoteGoAway;numInboundStreams;numOutboundStreams;onIncomingStream;onStreamEnd;constructor(t,e){this.client=e.direction==="outbound",this.config={...dt,...e},this.logger=t.logger,this.log=this.logger.forComponent("libp2p:yamux"),ft(this.config),this.closeController=new AbortController,this.closeController.signal,this.onIncomingStream=e.onIncomingStream,this.onStreamEnd=e.onStreamEnd,this._streams=new Map,this.source=B({onEnd:()=>{this.log?.trace("muxer source ended"),this._streams.forEach(r=>{r.destroy()})}}),this.sink=async r=>{let n=()=>{let a=V(r);if(a.return!=null){let l=a.return();Ot(l)&&l.catch(f=>{this.log?.("could not cause sink source to return",f)})}},i,o;try{let a=new j(r);try{this.closeController.signal.addEventListener("abort",n);for await(let l of a.emitFrames())await this.handleFrame(l.header,l.readData)}finally{this.closeController.signal.removeEventListener("abort",n)}i=p.NormalTermination}catch(a){ut.has(a.name)?(this.log?.error("protocol error in sink",a),i=p.ProtocolError):(this.log?.error("internal error in sink",a),i=p.InternalError),o=a}this.log?.trace("muxer sink ended"),o!=null?this.abort(o,i):await this.close({reason:i})},this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=-1,this.log?.trace("muxer created"),this.config.enableKeepAlive&&this.keepAliveLoop().catch(r=>this.log?.error("keepalive error: %s",r)),this.ping().catch(r=>this.log?.error("ping error: %s",r))}get streams(){return Array.from(this._streams.values())}newStream(t){if(this.remoteGoAway!==void 0)throw new S("Muxer closed remotely");if(this.localGoAway!==void 0)throw new S("Muxer closed locally");let e=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.config.maxOutboundStreams)throw new z("max outbound streams exceeded");this.log?.trace("new outgoing stream id=%s",e);let r=this._newStream(e,t,g.Init,"outbound");return this._streams.set(e,r),this.numOutboundStreams++,r.sendWindowUpdate(),r}async ping(){if(this.remoteGoAway!==void 0)throw new S("Muxer closed remotely");if(this.localGoAway!==void 0)throw new S("Muxer closed locally");if(this.activePing===void 0){let t=()=>{};this.activePing={id:this.nextPingID++,promise:new Promise((n,i)=>{let o=()=>{i(new S("Muxer closed locally"))};this.closeController.signal.addEventListener("abort",o,{once:!0}),t=()=>{this.closeController.signal.removeEventListener("abort",o),n()}}),resolve:t};let e=Date.now();this.sendPing(this.activePing.id);try{await this.activePing.promise}finally{delete this.activePing}let r=Date.now();this.rtt=r-e}else await this.activePing.promise;return this.rtt}getRTT(){return this.rtt}async close(t={}){if(this.closeController.signal.aborted)return;let e=t?.reason??p.NormalTermination;if(this.log?.trace("muxer close reason=%s",e),t.signal==null){let r=AbortSignal.timeout(Mt);t={...t,signal:r}}try{await Promise.all([...this._streams.values()].map(async r=>r.close(t))),this.sendGoAway(e),this._closeMuxer()}catch(r){this.abort(r)}}abort(t,e){if(!this.closeController.signal.aborted){e=e??p.InternalError,this.log?.error("muxer abort reason=%s error=%s",e,t);for(let r of this._streams.values())r.abort(t);this.sendGoAway(e),this._closeMuxer()}}isClosed(){return this.closeController.signal.aborted}_closeMuxer(){this.closeController.abort(),this.source.end()}_newStream(t,e,r,n){if(this._streams.get(t)!=null)throw new m("Stream already exists with that id");let i=new Q({id:t.toString(),name:e,state:r,direction:n,sendFrame:this.sendFrame.bind(this),onEnd:()=>{this.closeStream(t),this.onStreamEnd?.(i)},log:this.logger.forComponent(`libp2p:yamux:${n}:${t}`),config:this.config,getRTT:this.getRTT.bind(this)});return i}closeStream(t){this.client===(t%2===0)?this.numInboundStreams--:this.numOutboundStreams--,this._streams.delete(t)}async keepAliveLoop(){for(this.log?.trace("muxer keepalive enabled interval=%s",this.config.keepAliveInterval);;){let t;try{await C(new Promise(e=>{t=setTimeout(e,this.config.keepAliveInterval)}),this.closeController.signal),this.ping().catch(e=>this.log?.error("ping error: %s",e))}catch{clearInterval(t);return}}}async handleFrame(t,e){let{streamID:r,type:n,length:i}=t;if(this.log?.trace("received frame %o",t),r===0)switch(n){case h.Ping:{this.handlePing(t);return}case h.GoAway:{this.handleGoAway(i);return}default:throw new w("Invalid frame type")}else switch(t.type){case h.Data:case h.WindowUpdate:{await this.handleStreamMessage(t,e);return}default:throw new w("Invalid frame type")}}handlePing(t){if(t.flag===u.SYN)this.log?.trace("received ping request pingId=%s",t.length),this.sendPing(t.length,u.ACK);else if(t.flag===u.ACK)this.log?.trace("received ping response pingId=%s",t.length),this.handlePingResponse(t.length);else throw new w("Invalid frame flag")}handlePingResponse(t){if(this.activePing===void 0)throw new k("ping not requested");if(this.activePing.id!==t)throw new U("ping doesn't match our id");this.activePing.resolve()}handleGoAway(t){this.log?.trace("received GoAway reason=%s",p[t]??"unknown"),this.remoteGoAway=t;for(let e of this._streams.values())e.reset();this._closeMuxer()}async handleStreamMessage(t,e){let{streamID:r,flag:n,type:i}=t;(n&u.SYN)===u.SYN&&this.incomingStream(r);let o=this._streams.get(r);if(o===void 0){if(i===h.Data){if(this.log?.("discarding data for stream id=%s",r),e===void 0)throw new Error("unreachable");await e()}else this.log?.trace("frame for missing stream id=%s",r);return}switch(i){case h.WindowUpdate:{o.handleWindowUpdate(t);return}case h.Data:{if(e===void 0)throw new Error("unreachable");await o.handleData(t,e);return}default:throw new Error("unreachable")}}incomingStream(t){if(this.client!==(t%2===0))throw new m("Both endpoints are clients");if(this._streams.has(t))return;if(this.log?.trace("new incoming stream id=%s",t),this.localGoAway!==void 0){this.sendFrame({type:h.WindowUpdate,flag:u.RST,streamID:t,length:0});return}if(this.numInboundStreams>=this.config.maxInboundStreams){this.log?.("maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:h.WindowUpdate,flag:u.RST,streamID:t,length:0});return}let e=this._newStream(t,void 0,g.SYNReceived,"inbound");this.numInboundStreams++,this._streams.set(t,e),this.onIncomingStream?.(e)}sendFrame(t,e){if(this.log?.trace("sending frame %o",t),t.type===h.Data){if(e===void 0)throw new w("Invalid frame");this.source.push(new v(st(t),e))}else this.source.push(st(t))}sendPing(t,e=u.SYN){e===u.SYN?this.log?.trace("sending ping request pingId=%s",t):this.log?.trace("sending ping response pingId=%s",t),this.sendFrame({type:h.Ping,flag:e,streamID:0,length:t})}sendGoAway(t=p.NormalTermination){this.log?.("sending GoAway reason=%s",p[t]),this.localGoAway=t,this.sendFrame({type:h.GoAway,flag:0,streamID:0,length:t})}};function Ot(s){return s!=null&&typeof s.then=="function"}function Ft(s={}){return t=>new Z(t,s)}return Wt(zt);})();
 return ChainsafeLibp2PYamux}));
 //# sourceMappingURL=index.min.js.map
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/index.min.js.map b/node_modules/@chainsafe/libp2p-yamux/dist/index.min.js.map
index 6b67010..bf61beb 100644
--- a/node_modules/@chainsafe/libp2p-yamux/dist/index.min.js.map
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/index.min.js.map
@@ -1,7 +1,7 @@
 {
   "version": 3,
-  "sources": ["../src/index.ts", "../node_modules/@libp2p/interface/src/errors.ts", "../node_modules/@libp2p/interface/src/index.ts", "../node_modules/get-iterator/src/index.ts", "../node_modules/p-defer/index.js", "../node_modules/it-pushable/src/fifo.ts", "../node_modules/it-pushable/src/index.ts", "../node_modules/uint8arrays/src/alloc.ts", "../node_modules/uint8arrays/src/concat.ts", "../node_modules/uint8arrays/src/equals.ts", "../node_modules/uint8arraylist/src/index.ts", "../src/errors.ts", "../src/constants.ts", "../src/config.ts", "../src/frame.ts", "../src/decode.ts", "../src/encode.ts", "../node_modules/race-signal/src/index.ts", "../node_modules/@libp2p/utils/src/is-promise.ts", "../node_modules/@libp2p/utils/src/close-source.ts", "../node_modules/@libp2p/utils/src/abstract-stream.ts", "../node_modules/it-peekable/src/index.ts", "../node_modules/it-foreach/src/index.ts", "../src/stream.ts", "../src/muxer.ts"],
-  "sourcesContent": ["/**\n * @packageDocumentation\n *\n * This module is a JavaScript implementation of [Yamux from Hashicorp](https://github.com/hashicorp/yamux/blob/master/spec.md) designed to be used with [js-libp2p](https://github.com/libp2p/js-libp2p).\n *\n * @example Configure libp2p with Yamux\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n * import { yamux } from '@chainsafe/libp2p-yamux'\n *\n * const node = await createLibp2p({\n *   // ... other options\n *   streamMuxers: [\n *     yamux()\n *   ]\n * })\n * ```\n *\n * @example Using the low-level API\n *\n * ```js\n * import { yamux } from '@chainsafe/libp2p-yamux'\n * import { pipe } from 'it-pipe'\n * import { duplexPair } from 'it-pair/duplex'\n * import all from 'it-all'\n *\n * // Connect two yamux muxers to demo basic stream multiplexing functionality\n *\n * const clientMuxer = yamux({\n *   client: true,\n *   onIncomingStream: stream => {\n *     // echo data on incoming streams\n *     pipe(stream, stream)\n *   },\n *   onStreamEnd: stream => {\n *     // do nothing\n *   }\n * })()\n *\n * const serverMuxer = yamux({\n *   client: false,\n *   onIncomingStream: stream => {\n *     // echo data on incoming streams\n *     pipe(stream, stream)\n *   },\n *   onStreamEnd: stream => {\n *     // do nothing\n *   }\n * })()\n *\n * // `p` is our \"connections\", what we use to connect the two sides\n * // In a real application, a connection is usually to a remote computer\n * const p = duplexPair()\n *\n * // connect the muxers together\n * pipe(p[0], clientMuxer, p[0])\n * pipe(p[1], serverMuxer, p[1])\n *\n * // now either side can open streams\n * const stream0 = clientMuxer.newStream()\n * const stream1 = serverMuxer.newStream()\n *\n * // Send some data to the other side\n * const encoder = new TextEncoder()\n * const data = [encoder.encode('hello'), encoder.encode('world')]\n * pipe(data, stream0)\n *\n * // Receive data back\n * const result = await pipe(stream0, all)\n *\n * // close a stream\n * stream1.close()\n *\n * // close the muxer\n * clientMuxer.close()\n * ```\n */\n\nimport { Yamux } from './muxer.js'\nimport type { YamuxMuxerInit } from './muxer.js'\nimport type { ComponentLogger, StreamMuxerFactory } from '@libp2p/interface'\n\nexport { GoAwayCode, type FrameHeader, type FrameType } from './frame.js'\nexport type { YamuxMuxerInit }\n\nexport interface YamuxMuxerComponents {\n  logger: ComponentLogger\n}\n\nexport function yamux (init: YamuxMuxerInit = {}): (components: YamuxMuxerComponents) => StreamMuxerFactory {\n  return (components) => new Yamux(components, init)\n}\n", "/**\n * When this error is thrown it means an operation was aborted,\n * usually in response to the `abort` event being emitted by an\n * AbortSignal.\n */\nexport class AbortError extends Error {\n  static name = 'AbortError'\n\n  constructor (message: string = 'The operation was aborted') {\n    super(message)\n    this.name = 'AbortError'\n  }\n}\n\n/**\n * Thrown when a remote Peer ID does not match the expected one\n */\nexport class UnexpectedPeerError extends Error {\n  static name = 'UnexpectedPeerError'\n\n  constructor (message = 'Unexpected Peer') {\n    super(message)\n    this.name = 'UnexpectedPeerError'\n  }\n}\n\n/**\n * Thrown when a crypto exchange fails\n */\nexport class InvalidCryptoExchangeError extends Error {\n  static name = 'InvalidCryptoExchangeError'\n\n  constructor (message = 'Invalid crypto exchange') {\n    super(message)\n    this.name = 'InvalidCryptoExchangeError'\n  }\n}\n\n/**\n * Thrown when invalid parameters are passed to a function or method call\n */\nexport class InvalidParametersError extends Error {\n  static name = 'InvalidParametersError'\n\n  constructor (message = 'Invalid parameters') {\n    super(message)\n    this.name = 'InvalidParametersError'\n  }\n}\n\n/**\n * Thrown when a public key is invalid\n */\nexport class InvalidPublicKeyError extends Error {\n  static name = 'InvalidPublicKeyError'\n\n  constructor (message = 'Invalid public key') {\n    super(message)\n    this.name = 'InvalidPublicKeyError'\n  }\n}\n\n/**\n * Thrown when a private key is invalid\n */\nexport class InvalidPrivateKeyError extends Error {\n  static name = 'InvalidPrivateKeyError'\n\n  constructor (message = 'Invalid private key') {\n    super(message)\n    this.name = 'InvalidPrivateKeyError'\n  }\n}\n\n/**\n * Thrown when a operation is unsupported\n */\nexport class UnsupportedOperationError extends Error {\n  static name = 'UnsupportedOperationError'\n\n  constructor (message = 'Unsupported operation') {\n    super(message)\n    this.name = 'UnsupportedOperationError'\n  }\n}\n\n/**\n * Thrown when a connection is closing\n */\nexport class ConnectionClosingError extends Error {\n  static name = 'ConnectionClosingError'\n\n  constructor (message = 'The connection is closing') {\n    super(message)\n    this.name = 'ConnectionClosingError'\n  }\n}\n\n/**\n * Thrown when a connection is closed\n */\nexport class ConnectionClosedError extends Error {\n  static name = 'ConnectionClosedError'\n\n  constructor (message = 'The connection is closed') {\n    super(message)\n    this.name = 'ConnectionClosedError'\n  }\n}\n\n/**\n * Thrown when a connection fails\n */\nexport class ConnectionFailedError extends Error {\n  static name = 'ConnectionFailedError'\n\n  constructor (message = 'Connection failed') {\n    super(message)\n    this.name = 'ConnectionFailedError'\n  }\n}\n\n/**\n * Thrown when the muxer is closed and an attempt to open a stream occurs\n */\nexport class MuxerClosedError extends Error {\n  static name = 'MuxerClosedError'\n\n  constructor (message = 'The muxer is closed') {\n    super(message)\n    this.name = 'MuxerClosedError'\n  }\n}\n\n/**\n * Thrown when a protocol stream is reset by the remote muxer\n */\nexport class StreamResetError extends Error {\n  static name = 'StreamResetError'\n\n  constructor (message = 'The stream has been reset') {\n    super(message)\n    this.name = 'StreamResetError'\n  }\n}\n\n/**\n * Thrown when a stream is in an invalid state\n */\nexport class StreamStateError extends Error {\n  static name = 'StreamStateError'\n\n  constructor (message = 'The stream is in an invalid state') {\n    super(message)\n    this.name = 'StreamStateError'\n  }\n}\n\n/**\n * Thrown when a value could not be found\n */\nexport class NotFoundError extends Error {\n  static name = 'NotFoundError'\n\n  constructor (message = 'Not found') {\n    super(message)\n    this.name = 'NotFoundError'\n  }\n}\n\n/**\n * Thrown when an invalid peer ID is encountered\n */\nexport class InvalidPeerIdError extends Error {\n  static name = 'InvalidPeerIdError'\n\n  constructor (message = 'Invalid PeerID') {\n    super(message)\n    this.name = 'InvalidPeerIdError'\n  }\n}\n\n/**\n * Thrown when an invalid multiaddr is encountered\n */\nexport class InvalidMultiaddrError extends Error {\n  static name = 'InvalidMultiaddrError'\n\n  constructor (message = 'Invalid multiaddr') {\n    super(message)\n    this.name = 'InvalidMultiaddrError'\n  }\n}\n\n/**\n * Thrown when an invalid CID is encountered\n */\nexport class InvalidCIDError extends Error {\n  static name = 'InvalidCIDError'\n\n  constructor (message = 'Invalid CID') {\n    super(message)\n    this.name = 'InvalidCIDError'\n  }\n}\n\n/**\n * Thrown when an invalid multihash is encountered\n */\nexport class InvalidMultihashError extends Error {\n  static name = 'InvalidMultihashError'\n\n  constructor (message = 'Invalid Multihash') {\n    super(message)\n    this.name = 'InvalidMultihashError'\n  }\n}\n\n/**\n * Thrown when a protocol is not supported\n */\nexport class UnsupportedProtocolError extends Error {\n  static name = 'UnsupportedProtocolError'\n\n  constructor (message = 'Unsupported protocol error') {\n    super(message)\n    this.name = 'UnsupportedProtocolError'\n  }\n}\n\n/**\n * An invalid or malformed message was encountered during a protocol exchange\n */\nexport class InvalidMessageError extends Error {\n  static name = 'InvalidMessageError'\n\n  constructor (message = 'Invalid message') {\n    super(message)\n    this.name = 'InvalidMessageError'\n  }\n}\n\n/**\n * Thrown when a remote peer sends a structurally valid message that does not\n * comply with the protocol\n */\nexport class ProtocolError extends Error {\n  static name = 'ProtocolError'\n\n  constructor (message = 'Protocol error') {\n    super(message)\n    this.name = 'ProtocolError'\n  }\n}\n\n/**\n * Throw when an operation times out\n */\nexport class TimeoutError extends Error {\n  static name = 'TimeoutError'\n\n  constructor (message = 'Timed out') {\n    super(message)\n    this.name = 'TimeoutError'\n  }\n}\n\n/**\n * Thrown when a startable component is interacted with but it has not been\n * started yet\n */\nexport class NotStartedError extends Error {\n  static name = 'NotStartedError'\n\n  constructor (message = 'Not started') {\n    super(message)\n    this.name = 'NotStartedError'\n  }\n}\n\n/**\n * Thrown when a component is started that has already been started\n */\nexport class AlreadyStartedError extends Error {\n  static name = 'AlreadyStartedError'\n\n  constructor (message = 'Already started') {\n    super(message)\n    this.name = 'AlreadyStartedError'\n  }\n}\n\n/**\n * Thrown when dialing an address failed\n */\nexport class DialError extends Error {\n  static name = 'DialError'\n\n  constructor (message = 'Dial error') {\n    super(message)\n    this.name = 'DialError'\n  }\n}\n\n/**\n * Thrown when listening on an address failed\n */\nexport class ListenError extends Error {\n  static name = 'ListenError'\n\n  constructor (message = 'Listen error') {\n    super(message)\n    this.name = 'ListenError'\n  }\n}\n\n/**\n * This error is thrown when a limited connection is encountered, i.e. if the\n * user tried to open a stream on a connection for a protocol that is not\n * configured to run over limited connections.\n */\nexport class LimitedConnectionError extends Error {\n  static name = 'LimitedConnectionError'\n\n  constructor (message = 'Limited connection') {\n    super(message)\n    this.name = 'LimitedConnectionError'\n  }\n}\n\n/**\n * This error is thrown where there are too many inbound protocols streams open\n */\nexport class TooManyInboundProtocolStreamsError extends Error {\n  static name = 'TooManyInboundProtocolStreamsError'\n\n  constructor (message = 'Too many inbound protocol streams') {\n    super(message)\n    this.name = 'TooManyInboundProtocolStreamsError'\n  }\n}\n\n/**\n * This error is thrown where there are too many outbound protocols streams open\n */\nexport class TooManyOutboundProtocolStreamsError extends Error {\n  static name = 'TooManyOutboundProtocolStreamsError'\n\n  constructor (message = 'Too many outbound protocol streams') {\n    super(message)\n    this.name = 'TooManyOutboundProtocolStreamsError'\n  }\n}\n\n/**\n * Thrown when an attempt to operate on an unsupported key was made\n */\nexport class UnsupportedKeyTypeError extends Error {\n  static name = 'UnsupportedKeyTypeError'\n\n  constructor (message = 'Unsupported key type') {\n    super(message)\n    this.name = 'UnsupportedKeyTypeError'\n  }\n}\n\n/**\n * Thrown when an operation has not been implemented\n */\nexport class NotImplementedError extends Error {\n  static name = 'NotImplementedError'\n\n  constructor (message = 'Not implemented') {\n    super(message)\n    this.name = 'NotImplementedError'\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Exports a `Libp2p` type for modules to use as a type argument.\n *\n * @example\n *\n * ```typescript\n * import type { Libp2p } from '@libp2p/interface'\n *\n * function doSomethingWithLibp2p (node: Libp2p) {\n *   // ...\n * }\n * ```\n */\n\nimport type { Connection, NewStreamOptions, Stream } from './connection.js'\nimport type { ContentRouting } from './content-routing.js'\nimport type { Ed25519PublicKey, PublicKey, RSAPublicKey, Secp256k1PublicKey } from './keys.js'\nimport type { Metrics } from './metrics.js'\nimport type { Ed25519PeerId, PeerId, RSAPeerId, Secp256k1PeerId, URLPeerId } from './peer-id.js'\nimport type { PeerInfo } from './peer-info.js'\nimport type { PeerRouting } from './peer-routing.js'\nimport type { Address, Peer, PeerStore } from './peer-store.js'\nimport type { Startable } from './startable.js'\nimport type { StreamHandler, StreamHandlerOptions } from './stream-handler.js'\nimport type { Topology } from './topology.js'\nimport type { Listener, OutboundConnectionUpgradeEvents } from './transport.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { TypedEventTarget } from 'main-event'\nimport type { ProgressOptions, ProgressEvent } from 'progress-events'\n\n/**\n * Used by the connection manager to sort addresses into order before dialling\n */\nexport interface AddressSorter {\n  (a: Address, b: Address): -1 | 0 | 1\n}\n\n/**\n * Event detail emitted when peer data changes\n */\nexport interface PeerUpdate {\n  peer: Peer\n  previous?: Peer\n}\n\n/**\n * Peer data signed by the remote Peer's public key\n */\nexport interface SignedPeerRecord {\n  addresses: Multiaddr[]\n  seq: bigint\n}\n\n/**\n * A certificate that can be used to secure connections\n */\nexport interface TLSCertificate {\n  /**\n   * The private key that corresponds to the certificate in PEM format\n   */\n  key: string\n\n  /**\n   * The certificate chain in PEM format\n   */\n  cert: string\n}\n\n/**\n * Data returned from a successful identify response\n */\nexport interface IdentifyResult {\n  /**\n   * The remote Peer's PeerId\n   */\n  peerId: PeerId\n\n  /**\n   * The unsigned addresses they are listening on. Note - any multiaddrs present\n   * in the signed peer record should be preferred to the value here.\n   */\n  listenAddrs: Multiaddr[]\n\n  /**\n   * The protocols the remote peer supports\n   */\n  protocols: string[]\n\n  /**\n   * The remote protocol version\n   */\n  protocolVersion?: string\n\n  /**\n   * The remote agent version\n   */\n  agentVersion?: string\n\n  /**\n   * The public key part of the remote PeerId - this is only useful for older\n   * RSA-based PeerIds, the more modern Ed25519 and secp256k1 types have the\n   * public key embedded in them\n   */\n  publicKey?: Uint8Array\n\n  /**\n   * If set this is the address that the remote peer saw the identify request\n   * originate from\n   */\n  observedAddr?: Multiaddr\n\n  /**\n   * If sent by the remote peer this is the deserialized signed peer record\n   */\n  signedPeerRecord?: SignedPeerRecord\n\n  /**\n   * The connection that the identify protocol ran over\n   */\n  connection: Connection\n}\n\n/**\n * Logger component for libp2p\n */\nexport interface Logger {\n  (formatter: any, ...args: any[]): void\n  error(formatter: any, ...args: any[]): void\n  trace(formatter: any, ...args: any[]): void\n  enabled: boolean\n}\n\n/**\n * Peer logger component for libp2p. This can be used to create loggers that are\n * scoped to individual system components or services.\n *\n * To see logs, run your app with `DEBUG` set as an env var or for browsers, in\n * `localStorage`:\n *\n * ```console\n * $ DEBUG=libp2p* node index.js\n *  libp2p:my-service hello +0ms\n * ```\n */\nexport interface ComponentLogger {\n  /**\n   * Returns a logger for the specified component.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * import { ComponentLogger, Logger } from '@libp2p/interface'\n   *\n   * interface MyServiceComponents {\n   *   logger: ComponentLogger\n   * }\n   *\n   * class MyService {\n   *   private readonly log: Logger\n   *\n   *   constructor (components) {\n   *     this.log = components.logger.forComponent('libp2p:my-service')\n   *\n   *     this.log('hello')\n   *     // logs:\n   *     // libp2p:my-service hello +0ms\n   *   }\n   * }\n   * ```\n   */\n  forComponent(name: string): Logger\n}\n\n/**\n * Once you have a libp2p instance, you can listen to several events it emits,\n * so that you can be notified of relevant network events.\n *\n * Event names are `noun:verb` so the first part is the name of the object\n * being acted on and the second is the action.\n */\nexport interface Libp2pEvents<T extends ServiceMap = ServiceMap> {\n  /**\n   * This event is dispatched when a new network peer is discovered.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:discovery', (event) => {\n   *    const peerInfo = event.detail\n   *    // ...\n   * })\n   * ```\n   */\n  'peer:discovery': CustomEvent<PeerInfo>\n\n  /**\n   * This event will be triggered any time a new peer connects.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:connect', (event) => {\n   *   const peerId = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:connect': CustomEvent<PeerId>\n\n  /**\n   * This event will be triggered any time we are disconnected from another\n   * peer, regardless of the circumstances of that disconnection. If we happen\n   * to have multiple connections to a peer, this event will **only** be\n   * triggered when the last connection is closed.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:disconnect', (event) => {\n   *   const peerId = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:disconnect': CustomEvent<PeerId>\n\n  /**\n   * When a peer tagged with `keep-alive` disconnects, we will make multiple\n   * attempts to reconnect to it with a backoff factor (see the connection\n   * manager settings for details). If these all fail, the `keep-alive` tag will\n   * be removed and this event will be emitted.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:reconnect-failure', (event) => {\n   *   const peerId = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:reconnect-failure': CustomEvent<PeerId>\n\n  /**\n   * This event is dispatched after a remote peer has successfully responded to\n   * the identify protocol. Note that for this to be emitted, both peers must\n   * have an identify service configured.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:identify', (event) => {\n   *   const identifyResult = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:identify': CustomEvent<IdentifyResult>\n\n  /**\n   * This event is dispatched when the peer store data for a peer has been\n   * updated - e.g. their multiaddrs, protocols etc have changed.\n   *\n   * If they were previously known to this node, the old peer data will be\n   * set in the `previous` field.\n   *\n   * This may be in response to the identify protocol running, a manual\n   * update or some other event.\n   */\n  'peer:update': CustomEvent<PeerUpdate>\n\n  /**\n   * This event is dispatched when the current node's peer record changes -\n   * for example a transport started listening on a new address or a new\n   * protocol handler was registered.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('self:peer:update', (event) => {\n   *   const { peer } = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'self:peer:update': CustomEvent<PeerUpdate>\n\n  /**\n   * This event is dispatched when a transport begins listening on a new address\n   */\n  'transport:listening': CustomEvent<Listener>\n\n  /**\n   * This event is dispatched when a transport stops listening on an address\n   */\n  'transport:close': CustomEvent<Listener>\n\n  /**\n   * This event is dispatched when the connection manager has more than the\n   * configured allowable max connections and has closed some connections to\n   * bring the node back under the limit.\n   */\n  'connection:prune': CustomEvent<Connection[]>\n\n  /**\n   * This event notifies listeners when new incoming or outgoing connections\n   * are opened.\n   */\n  'connection:open': CustomEvent<Connection>\n\n  /**\n   * This event notifies listeners when incoming or outgoing connections are\n   * closed.\n   */\n  'connection:close': CustomEvent<Connection>\n\n  /**\n   * This event notifies listeners that a TLS certificate is available for use\n   */\n  'certificate:provision': CustomEvent<TLSCertificate>\n\n  /**\n   * This event notifies listeners that a new TLS certificate is available for\n   * use. Any previous certificate may no longer be valid.\n   */\n  'certificate:renew': CustomEvent<TLSCertificate>\n\n  /**\n   * This event notifies listeners that the node has started\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('start', (event) => {\n   *   console.info(libp2p.isStarted()) // true\n   * })\n   * ```\n   */\n  start: CustomEvent<Libp2p<T>>\n\n  /**\n   * This event notifies listeners that the node has stopped\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('stop', (event) => {\n   *   console.info(libp2p.isStarted()) // false\n   * })\n   * ```\n   */\n  stop: CustomEvent<Libp2p<T>>\n}\n\n/**\n * A map of user defined services available on the libp2p node via the\n * `services` key\n *\n * @example\n *\n * ```TypeScript\n * const node = await createLibp2p({\n *   // ...other options\n *   services: {\n *     myService: myService({\n *       // ...service options\n *     })\n *   }\n * })\n *\n * // invoke methods on the service\n * node.services.myService.anOperation()\n * ```\n */\nexport type ServiceMap = Record<string, unknown>\n\nexport type PendingDialStatus = 'queued' | 'active' | 'error' | 'success'\n\n/**\n * An item in the dial queue\n */\nexport interface PendingDial {\n  /**\n   * A unique identifier for this dial\n   */\n  id: string\n\n  /**\n   * The current status of the dial\n   */\n  status: PendingDialStatus\n\n  /**\n   * If known, this is the peer id that libp2p expects to be dialling\n   */\n  peerId?: PeerId\n\n  /**\n   * The list of multiaddrs that will be dialled. The returned connection will\n   * use the first address that succeeds, all other dials part of this pending\n   * dial will be cancelled.\n   */\n  multiaddrs: Multiaddr[]\n}\n\nexport type Libp2pStatus = 'starting' | 'started' | 'stopping' | 'stopped'\n\nexport interface IsDialableOptions extends AbortOptions {\n  /**\n   * If the dial attempt would open a protocol, and the multiaddr being dialed\n   * is a circuit relay address, passing true here would cause the test to fail\n   * because that protocol would not be allowed to run over a data/time limited\n   * connection.\n   */\n  runOnLimitedConnection?: boolean\n}\n\nexport type TransportManagerDialProgressEvents =\n  ProgressEvent<'transport-manager:selected-transport', string>\n\nexport type OpenConnectionProgressEvents =\n  TransportManagerDialProgressEvents |\n  ProgressEvent<'dial-queue:already-connected'> |\n  ProgressEvent<'dial-queue:already-in-dial-queue'> |\n  ProgressEvent<'dial-queue:add-to-dial-queue'> |\n  ProgressEvent<'dial-queue:start-dial'> |\n  ProgressEvent<'dial-queue:calculated-addresses', Address[]> |\n  OutboundConnectionUpgradeEvents\n\nexport interface DialOptions extends AbortOptions, ProgressOptions {\n  /**\n   * If true, open a new connection to the remote even if one already exists\n   */\n  force?: boolean\n}\n\nexport interface DialProtocolOptions extends NewStreamOptions {\n\n}\n\n/**\n * Libp2p nodes implement this interface.\n */\nexport interface Libp2p<T extends ServiceMap = ServiceMap> extends Startable, TypedEventTarget<Libp2pEvents<T>> {\n  /**\n   * The PeerId is a unique identifier for a node on the network.\n   *\n   * It is the hash of an RSA public key or, for Ed25519 or secp256k1 keys,\n   * the key itself.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * console.info(libp2p.peerId)\n   * // PeerId(12D3Foo...)\n   * ````\n   */\n  peerId: PeerId\n\n  /**\n   * The peer store holds information we know about other peers on the network.\n   * - multiaddrs, supported protocols, etc.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peer = await libp2p.peerStore.get(peerId)\n   * console.info(peer)\n   * // { id: PeerId(12D3Foo...), addresses: [] ... }\n   * ```\n   */\n  peerStore: PeerStore\n\n  /**\n   * The peer routing subsystem allows the user to find peers on the network\n   * or to find peers close to binary keys.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peerInfo = await libp2p.peerRouting.findPeer(peerId)\n   * console.info(peerInfo)\n   * // { id: PeerId(12D3Foo...), multiaddrs: [] ... }\n   * ```\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for await (const peerInfo of libp2p.peerRouting.getClosestPeers(key)) {\n   *   console.info(peerInfo)\n   *   // { id: PeerId(12D3Foo...), multiaddrs: [] ... }\n   * }\n   * ```\n   */\n  peerRouting: PeerRouting\n\n  /**\n   * The content routing subsystem allows the user to find providers for content,\n   * let the network know they are providers for content, and get/put values to\n   * the DHT.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for await (const peerInfo of libp2p.contentRouting.findProviders(cid)) {\n   *   console.info(peerInfo)\n   *   // { id: PeerId(12D3Foo...), multiaddrs: [] ... }\n   * }\n   * ```\n   */\n  contentRouting: ContentRouting\n\n  /**\n   * The metrics subsystem allows recording values to assess the health/performance\n   * of the running node.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const metric = libp2p.metrics.registerMetric({\n   *   'my-metric'\n   * })\n   *\n   * // later\n   * metric.update(5)\n   * ```\n   */\n  metrics?: Metrics\n\n  /**\n   * The logger used by this libp2p node\n   */\n  logger: ComponentLogger\n\n  /**\n   * The current status of the libp2p node\n   */\n  status: Libp2pStatus\n\n  /**\n   * Get a deduplicated list of peer advertising multiaddrs by concatenating\n   * the listen addresses used by transports with any configured\n   * announce addresses as well as observed addresses reported by peers.\n   *\n   * If Announce addrs are specified, configured listen addresses will be\n   * ignored though observed addresses will still be included.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const listenMa = libp2p.getMultiaddrs()\n   * // [ <Multiaddr 047f00000106f9ba - /ip4/127.0.0.1/tcp/63930> ]\n   * ```\n   */\n  getMultiaddrs(): Multiaddr[]\n\n  /**\n   * Returns a list of supported protocols\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const protocols = libp2p.getProtocols()\n   * // [ '/ipfs/ping/1.0.0', '/ipfs/id/1.0.0' ]\n   * ```\n   */\n  getProtocols(): string[]\n\n  /**\n   * Return a list of all connections this node has open, optionally filtering\n   * by a PeerId\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for (const connection of libp2p.getConnections()) {\n   *   console.log(peerId, connection.remoteAddr.toString())\n   *   // Logs the PeerId string and the observed remote multiaddr of each Connection\n   * }\n   * ```\n   */\n  getConnections(peerId?: PeerId): Connection[]\n\n  /**\n   * Return the list of dials currently in progress or queued to start\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for (const pendingDial of libp2p.getDialQueue()) {\n   *   console.log(pendingDial)\n   * }\n   * ```\n   */\n  getDialQueue(): PendingDial[]\n\n  /**\n   * Return a list of all peers we currently have a connection open to\n   */\n  getPeers(): PeerId[]\n\n  /**\n   * Dials to the provided peer. If successful, the known metadata of the\n   * peer will be added to the nodes `peerStore`.\n   *\n   * If a PeerId is passed as the first argument, the peer will need to have known multiaddrs for it in the PeerStore.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const conn = await libp2p.dial(remotePeerId)\n   *\n   * // create a new stream within the connection\n   * const stream = await conn.newStream(['/echo/1.1.0', '/echo/1.0.0'])\n   *\n   * // protocol negotiated: 'echo/1.0.0' means that the other party only supports the older version\n   *\n   * // ...\n   * await conn.close()\n   * ```\n   */\n  dial(peer: PeerId | Multiaddr | Multiaddr[], options?: DialOptions): Promise<Connection>\n\n  /**\n   * Dials to the provided peer and tries to handshake with the given protocols in order.\n   * If successful, the known metadata of the peer will be added to the nodes `peerStore`,\n   * and the `MuxedStream` will be returned together with the successful negotiated protocol.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * import { pipe } from 'it-pipe'\n   *\n   * const { stream, protocol } = await libp2p.dialProtocol(remotePeerId, protocols)\n   *\n   * // Use this new stream like any other duplex stream\n   * pipe([1, 2, 3], stream, consume)\n   * ```\n   */\n  dialProtocol(peer: PeerId | Multiaddr | Multiaddr[], protocols: string | string[], options?: DialProtocolOptions): Promise<Stream>\n\n  /**\n   * Attempts to gracefully close an open connection to the given peer. If the\n   * connection is not closed in the grace period, it will be forcefully closed.\n   *\n   * An AbortSignal can optionally be passed to control when the connection is\n   * forcefully closed.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * await libp2p.hangUp(remotePeerId)\n   * ```\n   */\n  hangUp(peer: PeerId | Multiaddr, options?: AbortOptions): Promise<void>\n\n  /**\n   * Sets up [multistream-select routing](https://github.com/multiformats/multistream-select) of protocols to their application handlers. Whenever a stream is opened on one of the provided protocols, the handler will be called. `handle` must be called in order to register a handler and support for a given protocol. This also informs other peers of the protocols you support.\n   *\n   * `libp2p.handle(protocols, handler, options)`\n   *\n   * In the event of a new handler for the same protocol being added and error\n   * will be thrown. Pass `force: true` to override this.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const handler = ({ connection, stream, protocol }) => {\n   *   // use stream or connection according to the needs\n   * }\n   *\n   * libp2p.handle('/echo/1.0.0', handler, {\n   *   maxInboundStreams: 5,\n   *   maxOutboundStreams: 5\n   * })\n   * ```\n   */\n  handle(protocol: string | string[], handler: StreamHandler, options?: StreamHandlerOptions): Promise<void>\n\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.unhandle(['/echo/1.0.0'])\n   * ```\n   */\n  unhandle(protocols: string[] | string, options?: AbortOptions): Promise<void>\n\n  /**\n   * Register a topology to be informed when peers are encountered that\n   * support the specified protocol\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const id = await libp2p.register('/echo/1.0.0', {\n   *   onConnect: (peer, connection) => {\n   *     // handle connect\n   *   },\n   *   onDisconnect: (peer, connection) => {\n   *     // handle disconnect\n   *   }\n   * })\n   * ```\n   */\n  register(protocol: string, topology: Topology, options?: AbortOptions): Promise<string>\n\n  /**\n   * Unregister topology to no longer be informed when peers connect or\n   * disconnect.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const id = await libp2p.register(...)\n   *\n   * libp2p.unregister(id)\n   * ```\n   */\n  unregister(id: string): void\n\n  /**\n   * Returns the public key for the passed PeerId. If the PeerId is of the 'RSA'\n   * type this may mean searching the routing if the peer's key is not present\n   * in the peer store.\n   */\n  getPublicKey(peer: Ed25519PeerId, options?: AbortOptions): Promise<Ed25519PublicKey>\n  getPublicKey(peer: Secp256k1PeerId, options?: AbortOptions): Promise<Secp256k1PublicKey>\n  getPublicKey(peer: RSAPeerId, options?: AbortOptions): Promise<RSAPublicKey>\n  getPublicKey(peer: URLPeerId, options?: AbortOptions): Promise<never>\n  getPublicKey(peer: PeerId, options?: AbortOptions): Promise<PublicKey>\n\n  /**\n   * Given the current node configuration, returns a promise of `true` or\n   * `false` if the node would attempt to dial the passed multiaddr.\n   *\n   * This means a relevant transport is configured, and the connection gater\n   * would not block the dial attempt.\n   *\n   * This may involve resolving DNS addresses so you should pass an AbortSignal.\n   */\n  isDialable(multiaddr: Multiaddr | Multiaddr[], options?: IsDialableOptions): Promise<boolean>\n\n  /**\n   * A set of user defined services\n   */\n  services: T\n}\n\n/**\n * Metadata about the current node\n */\nexport interface NodeInfo {\n  /**\n   * The implementation name\n   */\n  name: string\n\n  /**\n   * The implementation version\n   */\n  version: string\n\n  /**\n   * A string that contains information about the implementation and runtime\n   */\n  userAgent: string\n}\n\n/**\n * An object that contains an AbortSignal as\n * the optional `signal` property.\n *\n * @example\n *\n * ```TypeScript\n * const controller = new AbortController()\n *\n * aLongRunningOperation({\n *   signal: controller.signal\n * })\n *\n * // later\n *\n * controller.abort()\n */\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\n/**\n * An object that contains a Logger as the `log` property.\n */\nexport interface LoggerOptions {\n  log: Logger\n}\n\n/**\n * An object that includes a trace object that is passed onwards.\n *\n * This is used by metrics method tracing to link function calls together.\n */\nexport interface TraceOptions {\n  trace?: any\n}\n\n/**\n * A signal that needs to be cleared when no longer in use\n */\nexport interface ClearableSignal extends AbortSignal {\n  clear(): void\n}\n\n/**\n * When a routing operation involves reading values, these options allow\n * controlling where the values are read from. By default libp2p will check\n * local caches but may not use the network if a valid local value is found,\n * these options allow tuning that behavior.\n */\nexport interface RoutingOptions extends AbortOptions, ProgressOptions, TraceOptions {\n  /**\n   * Pass `false` to not use the network\n   *\n   * @default true\n   */\n  useNetwork?: boolean\n\n  /**\n   * Pass `false` to not use cached values\n   *\n   * @default true\n   */\n  useCache?: boolean\n}\n\n/**\n * This symbol is used by libp2p services to define the capabilities they can\n * provide to other libp2p services.\n *\n * The service should define a property with this symbol as the key and the\n * value should be a string array of provided capabilities.\n */\nexport const serviceCapabilities = Symbol.for('@libp2p/service-capabilities')\n\n/**\n * This symbol is used by libp2p services to define the capabilities they\n * require from other libp2p services.\n *\n * The service should define a property with this symbol as the key and the\n * value should be a string array of required capabilities.\n */\nexport const serviceDependencies = Symbol.for('@libp2p/service-dependencies')\n\nexport * from './connection.js'\nexport * from './connection-encrypter.js'\nexport * from './connection-gater.js'\nexport * from './content-routing.js'\nexport * from './keys.js'\nexport * from './metrics.js'\nexport * from './peer-discovery.js'\nexport * from './peer-id.js'\nexport * from './peer-info.js'\nexport * from './peer-routing.js'\nexport * from './peer-store.js'\nexport * from './pubsub.js'\nexport * from './record.js'\nexport * from './stream-handler.js'\nexport * from './stream-muxer.js'\nexport * from './topology.js'\nexport * from './transport.js'\nexport * from './errors.js'\nexport * from 'main-event'\nexport * from './startable.js'\n", "\n// If the passed object is an (async) iterable, then get the iterator\n// If it's probably an iterator already (i.e. has next function) return it\n// else throw\nexport function getIterator <T> (obj: AsyncIterable<T>): AsyncIterator<T>\nexport function getIterator <T> (obj: AsyncIterator<T>): AsyncIterator<T>\nexport function getIterator <T> (obj: Iterable<T>): Iterator<T>\nexport function getIterator <T> (obj: Iterator<T>): Iterator<T>\nexport function getIterator <T> (obj: any): AsyncIterator<T> | Iterator <T>\nexport function getIterator <T> (obj: any): AsyncIterator<T> | Iterator <T> {\n  if (obj != null) {\n    if (typeof obj[Symbol.iterator] === 'function') {\n      return obj[Symbol.iterator]()\n    }\n    if (typeof obj[Symbol.asyncIterator] === 'function') {\n      return obj[Symbol.asyncIterator]()\n    }\n    if (typeof obj.next === 'function') {\n      return obj // probably an iterator\n    }\n  }\n  throw new Error('argument is not an iterator or iterable')\n}\n", "export default function pDefer() {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n}\n", "// ported from https://www.npmjs.com/package/fast-fifo\n\nexport interface Next<T> {\n  done?: boolean\n  error?: Error\n  value?: T\n}\n\nclass FixedFIFO<T> {\n  public buffer: Array<Next<T> | undefined>\n  private readonly mask: number\n  private top: number\n  private btm: number\n  public next: FixedFIFO<T> | null\n\n  constructor (hwm: number) {\n    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) {\n      throw new Error('Max size for a FixedFIFO should be a power of two')\n    }\n\n    this.buffer = new Array(hwm)\n    this.mask = hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.next = null\n  }\n\n  push (data: Next<T>): boolean {\n    if (this.buffer[this.top] !== undefined) {\n      return false\n    }\n\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n\n    return true\n  }\n\n  shift (): Next<T> | undefined {\n    const last = this.buffer[this.btm]\n\n    if (last === undefined) {\n      return undefined\n    }\n\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    return last\n  }\n\n  isEmpty (): boolean {\n    return this.buffer[this.btm] === undefined\n  }\n}\n\nexport interface FIFOOptions {\n  /**\n   * When the queue reaches this size, it will be split into head/tail parts\n   */\n  splitLimit?: number\n}\n\nexport class FIFO<T> {\n  public size: number\n  private readonly hwm: number\n  private head: FixedFIFO<T>\n  private tail: FixedFIFO<T>\n\n  constructor (options: FIFOOptions = {}) {\n    this.hwm = options.splitLimit ?? 16\n    this.head = new FixedFIFO<T>(this.hwm)\n    this.tail = this.head\n    this.size = 0\n  }\n\n  calculateSize (obj: any): number {\n    if (obj?.byteLength != null) {\n      return obj.byteLength\n    }\n\n    return 1\n  }\n\n  push (val: Next<T>): void {\n    if (val?.value != null) {\n      this.size += this.calculateSize(val.value)\n    }\n\n    if (!this.head.push(val)) {\n      const prev = this.head\n      this.head = prev.next = new FixedFIFO<T>(2 * this.head.buffer.length)\n      this.head.push(val)\n    }\n  }\n\n  shift (): Next<T> | undefined {\n    let val = this.tail.shift()\n\n    if (val === undefined && (this.tail.next != null)) {\n      const next = this.tail.next\n      this.tail.next = null\n      this.tail = next\n      val = this.tail.shift()\n    }\n\n    if (val?.value != null) {\n      this.size -= this.calculateSize(val.value)\n    }\n\n    return val\n  }\n\n  isEmpty (): boolean {\n    return this.head.isEmpty()\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\n\nimport deferred from 'p-defer'\nimport { FIFO, type Next } from './fifo.js'\n\nexport class AbortError extends Error {\n  type: string\n  code: string\n\n  constructor (message?: string, code?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\ninterface BasePushable<T> {\n  /**\n   * End the iterable after all values in the buffer (if any) have been yielded. If an\n   * error is passed the buffer is cleared immediately and the next iteration will\n   * throw the passed error\n   */\n  end(err?: Error): this\n\n  /**\n   * Push a value into the iterable. Values are yielded from the iterable in the order\n   * they are pushed. Values not yet consumed from the iterable are buffered.\n   */\n  push(value: T): this\n\n  /**\n   * Returns a promise that resolves when the underlying queue becomes empty (e.g.\n   * this.readableLength === 0).\n   *\n   * If an AbortSignal is passed as an option and that signal aborts, it only\n   * causes the returned promise to reject - it does not end the pushable.\n   */\n  onEmpty(options?: AbortOptions): Promise<void>\n\n  /**\n   * This property contains the number of bytes (or objects) in the queue ready to be read.\n   *\n   * If `objectMode` is true, this is the number of objects in the queue, if false it's the\n   * total number of bytes in the queue.\n   */\n  readableLength: number\n}\n\n/**\n * An iterable that you can push values into.\n */\nexport interface Pushable<T, R = void, N = unknown> extends AsyncGenerator<T, R, N>, BasePushable<T> {}\n\n/**\n * Similar to `pushable`, except it yields multiple buffered chunks at a time. All values yielded from the iterable will be arrays.\n */\nexport interface PushableV<T, R = void, N = unknown> extends AsyncGenerator<T[], R, N>, BasePushable<T> {}\n\nexport interface Options {\n  /**\n   * A boolean value that means non-`Uint8Array`s will be passed to `.push`, default: `false`\n   */\n  objectMode?: boolean\n\n  /**\n   * A function called after *all* values have been yielded from the iterator (including\n   * buffered values). In the case when the iterator is ended with an error it will be\n   * passed the error as a parameter.\n   */\n  onEnd?(err?: Error): void\n}\n\nexport interface DoneResult { done: true }\nexport interface ValueResult<T> { done: false, value: T }\nexport type NextResult<T> = ValueResult<T> | DoneResult\n\ninterface getNext<T, V = T> { (buffer: FIFO<T>): NextResult<V> }\n\nexport interface ObjectPushableOptions extends Options {\n  objectMode: true\n}\n\nexport interface BytePushableOptions extends Options {\n  objectMode?: false\n}\n\n/**\n * Create a new async iterable. The values yielded from calls to `.next()`\n * or when used in a `for await of`loop are \"pushed\" into the iterable.\n * Returns an async iterable object with additional methods.\n */\nexport function pushable<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): Pushable<T>\nexport function pushable<T> (options: ObjectPushableOptions): Pushable<T>\nexport function pushable<T> (options: Options = {}): Pushable<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T> => {\n    const next: Next<T> | undefined = buffer.shift()\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    if (next.error != null) {\n      throw next.error\n    }\n\n    return {\n      done: next.done === true,\n      // @ts-expect-error if done is false, value will be present\n      value: next.value\n    }\n  }\n\n  return _pushable<T, T, Pushable<T>>(getNext, options)\n}\n\nexport function pushableV<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): PushableV<T>\nexport function pushableV<T> (options: ObjectPushableOptions): PushableV<T>\nexport function pushableV<T> (options: Options = {}): PushableV<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T[]> => {\n    let next: Next<T> | undefined\n    const values: T[] = []\n\n    while (!buffer.isEmpty()) {\n      next = buffer.shift()\n\n      if (next == null) {\n        break\n      }\n\n      if (next.error != null) {\n        throw next.error\n      }\n\n      if (next.done === false) {\n        // @ts-expect-error if done is false value should be pushed\n        values.push(next.value)\n      }\n    }\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    return {\n      done: next.done === true,\n      value: values\n    }\n  }\n\n  return _pushable<T, T[], PushableV<T>>(getNext, options)\n}\n\nfunction _pushable<PushType, ValueType, ReturnType> (getNext: getNext<PushType, ValueType>, options?: Options): ReturnType {\n  options = options ?? {}\n  let onEnd = options.onEnd\n  let buffer = new FIFO<PushType>()\n  let pushable: any\n  let onNext: ((next: Next<PushType>) => ReturnType) | null\n  let ended: boolean\n  let drain = deferred()\n\n  const waitNext = async (): Promise<NextResult<ValueType>> => {\n    try {\n      if (!buffer.isEmpty()) {\n        return getNext(buffer)\n      }\n\n      if (ended) {\n        return { done: true }\n      }\n\n      return await new Promise<NextResult<ValueType>>((resolve, reject) => {\n        onNext = (next: Next<PushType>) => {\n          onNext = null\n          buffer.push(next)\n\n          try {\n            resolve(getNext(buffer))\n          } catch (err) {\n            reject(err)\n          }\n\n          return pushable\n        }\n      })\n    } finally {\n      if (buffer.isEmpty()) {\n        // settle promise in the microtask queue to give consumers a chance to\n        // await after calling .push\n        queueMicrotask(() => {\n          drain.resolve()\n          drain = deferred()\n        })\n      }\n    }\n  }\n\n  const bufferNext = (next: Next<PushType>): ReturnType => {\n    if (onNext != null) {\n      return onNext(next)\n    }\n\n    buffer.push(next)\n    return pushable\n  }\n\n  const bufferError = (err: Error): ReturnType => {\n    buffer = new FIFO()\n\n    if (onNext != null) {\n      return onNext({ error: err })\n    }\n\n    buffer.push({ error: err })\n    return pushable\n  }\n\n  const push = (value: PushType): ReturnType => {\n    if (ended) {\n      return pushable\n    }\n\n    // @ts-expect-error `byteLength` is not declared on PushType\n    if (options?.objectMode !== true && value?.byteLength == null) {\n      throw new Error('objectMode was not true but tried to push non-Uint8Array value')\n    }\n\n    return bufferNext({ done: false, value })\n  }\n  const end = (err?: Error): ReturnType => {\n    if (ended) return pushable\n    ended = true\n\n    return (err != null) ? bufferError(err) : bufferNext({ done: true })\n  }\n  const _return = (): DoneResult => {\n    buffer = new FIFO()\n    end()\n\n    return { done: true }\n  }\n  const _throw = (err: Error): DoneResult => {\n    end(err)\n\n    return { done: true }\n  }\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next: waitNext,\n    return: _return,\n    throw: _throw,\n    push,\n    end,\n    get readableLength (): number {\n      return buffer.size\n    },\n    onEmpty: async (options?: AbortOptions) => {\n      const signal = options?.signal\n      signal?.throwIfAborted()\n\n      if (buffer.isEmpty()) {\n        return\n      }\n\n      let cancel: Promise<void> | undefined\n      let listener: (() => void) | undefined\n\n      if (signal != null) {\n        cancel = new Promise((resolve, reject) => {\n          listener = () => {\n            reject(new AbortError())\n          }\n\n          signal.addEventListener('abort', listener)\n        })\n      }\n\n      try {\n        await Promise.race([\n          drain.promise,\n          cancel\n        ])\n      } finally {\n        if (listener != null && signal != null) {\n          signal?.removeEventListener('abort', listener)\n        }\n      }\n    }\n  }\n\n  if (onEnd == null) {\n    return pushable\n  }\n\n  const _pushable = pushable\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next () {\n      return _pushable.next()\n    },\n    throw (err: Error) {\n      _pushable.throw(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    return () {\n      _pushable.return()\n\n      if (onEnd != null) {\n        onEnd()\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    push,\n    end (err: Error) {\n      _pushable.end(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return pushable\n    },\n    get readableLength () {\n      return _pushable.readableLength\n    },\n    onEmpty: (opts?: AbortOptions) => {\n      return _pushable.onEmpty(opts)\n    }\n  }\n\n  return pushable\n}\n", "/**\n * Returns a `Uint8Array` of the requested size. Referenced memory will\n * be initialized to 0.\n */\nexport function alloc (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n", "import { allocUnsafe } from '#alloc'\nimport { asUint8Array } from '#util/as-uint8array'\n\n/**\n * Returns a new Uint8Array created by concatenating the passed Uint8Arrays\n */\nexport function concat (arrays: Uint8Array[], length?: number): Uint8Array {\n  if (length == null) {\n    length = arrays.reduce((acc, curr) => acc + curr.length, 0)\n  }\n\n  const output = allocUnsafe(length)\n  let offset = 0\n\n  for (const arr of arrays) {\n    output.set(arr, offset)\n    offset += arr.length\n  }\n\n  return asUint8Array(output)\n}\n", "/**\n * Returns true if the two passed Uint8Arrays have the same content\n */\nexport function equals (a: Uint8Array, b: Uint8Array): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (a.byteLength !== b.byteLength) {\n    return false\n  }\n\n  for (let i = 0; i < a.byteLength; i++) {\n    if (a[i] !== b[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n", "/**\n * @packageDocumentation\n *\n * A class that lets you do operations over a list of Uint8Arrays without\n * copying them.\n *\n * ```js\n * import { Uint8ArrayList } from 'uint8arraylist'\n *\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray()\n * // -> Uint8Array([0, 1, 2, 3, 4, 5])\n *\n * list.consume(3)\n * list.subarray()\n * // -> Uint8Array([3, 4, 5])\n *\n * // you can also iterate over the list\n * for (const buf of list) {\n *   // ..do something with `buf`\n * }\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ## Converting Uint8ArrayLists to Uint8Arrays\n *\n * There are two ways to turn a `Uint8ArrayList` into a `Uint8Array` - `.slice` and `.subarray` and one way to turn a `Uint8ArrayList` into a `Uint8ArrayList` with different contents - `.sublist`.\n *\n * ### slice\n *\n * Slice follows the same semantics as [Uint8Array.slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice) in that it creates a new `Uint8Array` and copies bytes into it using an optional offset & length.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.slice(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ### subarray\n *\n * Subarray attempts to follow the same semantics as [Uint8Array.subarray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray) with one important different - this is a no-copy operation, unless the requested bytes span two internal buffers in which case it is a copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0]) - no-copy\n *\n * list.subarray(2, 5)\n * // -> Uint8Array([2, 3, 4]) - copy\n * ```\n *\n * ### sublist\n *\n * Sublist creates and returns a new `Uint8ArrayList` that shares the underlying buffers with the original so is always a no-copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.sublist(0, 1)\n * // -> Uint8ArrayList([0]) - no-copy\n *\n * list.sublist(2, 5)\n * // -> Uint8ArrayList([2], [3, 4]) - no-copy\n * ```\n *\n * ## Inspiration\n *\n * Borrows liberally from [bl](https://www.npmjs.com/package/bl) but only uses native JS types.\n */\nimport { allocUnsafe, alloc } from 'uint8arrays/alloc'\nimport { concat } from 'uint8arrays/concat'\nimport { equals } from 'uint8arrays/equals'\n\nconst symbol = Symbol.for('@achingbrain/uint8arraylist')\n\nexport type Appendable = Uint8ArrayList | Uint8Array\n\nfunction findBufAndOffset (bufs: Uint8Array[], index: number): { buf: Uint8Array, index: number } {\n  if (index == null || index < 0) {\n    throw new RangeError('index is out of bounds')\n  }\n\n  let offset = 0\n\n  for (const buf of bufs) {\n    const bufEnd = offset + buf.byteLength\n\n    if (index < bufEnd) {\n      return {\n        buf,\n        index: index - offset\n      }\n    }\n\n    offset = bufEnd\n  }\n\n  throw new RangeError('index is out of bounds')\n}\n\n/**\n * Check if object is a CID instance\n *\n * @example\n *\n * ```js\n * import { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist'\n *\n * isUint8ArrayList(true) // false\n * isUint8ArrayList([]) // false\n * isUint8ArrayList(new Uint8ArrayList()) // true\n * ```\n */\nexport function isUint8ArrayList (value: any): value is Uint8ArrayList {\n  return Boolean(value?.[symbol])\n}\n\nexport class Uint8ArrayList implements Iterable<Uint8Array> {\n  private bufs: Uint8Array[]\n  public length: number\n  public readonly [symbol] = true\n\n  constructor (...data: Appendable[]) {\n    this.bufs = []\n    this.length = 0\n\n    if (data.length > 0) {\n      this.appendAll(data)\n    }\n  }\n\n  * [Symbol.iterator] (): Iterator<Uint8Array> {\n    yield * this.bufs\n  }\n\n  get byteLength (): number {\n    return this.length\n  }\n\n  /**\n   * Add one or more `bufs` to the end of this Uint8ArrayList\n   */\n  append (...bufs: Appendable[]): void {\n    this.appendAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the end of this Uint8ArrayList\n   */\n  appendAll (bufs: Appendable[]): void {\n    let length = 0\n\n    for (const buf of bufs) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.push(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.push(...buf.bufs)\n      } else {\n        throw new Error('Could not append value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Add one or more `bufs` to the start of this Uint8ArrayList\n   */\n  prepend (...bufs: Appendable[]): void {\n    this.prependAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the start of this Uint8ArrayList\n   */\n  prependAll (bufs: Appendable[]): void {\n    let length = 0\n\n    for (const buf of bufs.reverse()) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.unshift(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.unshift(...buf.bufs)\n      } else {\n        throw new Error('Could not prepend value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Read the value at `index`\n   */\n  get (index: number): number {\n    const res = findBufAndOffset(this.bufs, index)\n\n    return res.buf[res.index]\n  }\n\n  /**\n   * Set the value at `index` to `value`\n   */\n  set (index: number, value: number): void {\n    const res = findBufAndOffset(this.bufs, index)\n\n    res.buf[res.index] = value\n  }\n\n  /**\n   * Copy bytes from `buf` to the index specified by `offset`\n   */\n  write (buf: Appendable, offset: number = 0): void {\n    if (buf instanceof Uint8Array) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf[i])\n      }\n    } else if (isUint8ArrayList(buf)) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf.get(i))\n      }\n    } else {\n      throw new Error('Could not write value, must be an Uint8Array or a Uint8ArrayList')\n    }\n  }\n\n  /**\n   * Remove bytes from the front of the pool\n   */\n  consume (bytes: number): void {\n    // first, normalize the argument, in accordance with how Buffer does it\n    bytes = Math.trunc(bytes)\n\n    // do nothing if not a positive number\n    if (Number.isNaN(bytes) || bytes <= 0) {\n      return\n    }\n\n    // if consuming all bytes, skip iterating\n    if (bytes === this.byteLength) {\n      this.bufs = []\n      this.length = 0\n      return\n    }\n\n    while (this.bufs.length > 0) {\n      if (bytes >= this.bufs[0].byteLength) {\n        bytes -= this.bufs[0].byteLength\n        this.length -= this.bufs[0].byteLength\n        this.bufs.shift()\n      } else {\n        this.bufs[0] = this.bufs[0].subarray(bytes)\n        this.length -= bytes\n        break\n      }\n    }\n  }\n\n  /**\n   * Extracts a section of an array and returns a new array.\n   *\n   * This is a copy operation as it is with Uint8Arrays and Arrays\n   * - note this is different to the behaviour of Node Buffers.\n   */\n  slice (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a alloc from the given start and end element index.\n   *\n   * In the best case where the data extracted comes from a single Uint8Array\n   * internally this is a no-copy operation otherwise it is a copy operation.\n   */\n  subarray (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    if (bufs.length === 1) {\n      return bufs[0]\n    }\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a allocList from the given start and end element index.\n   *\n   * This is a no-copy operation.\n   */\n  sublist (beginInclusive?: number, endExclusive?: number): Uint8ArrayList {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    const list = new Uint8ArrayList()\n    list.length = length\n    // don't loop, just set the bufs\n    list.bufs = [...bufs]\n\n    return list\n  }\n\n  private _subList (beginInclusive?: number, endExclusive?: number): { bufs: Uint8Array[], length: number } {\n    beginInclusive = beginInclusive ?? 0\n    endExclusive = endExclusive ?? this.length\n\n    if (beginInclusive < 0) {\n      beginInclusive = this.length + beginInclusive\n    }\n\n    if (endExclusive < 0) {\n      endExclusive = this.length + endExclusive\n    }\n\n    if (beginInclusive < 0 || endExclusive > this.length) {\n      throw new RangeError('index is out of bounds')\n    }\n\n    if (beginInclusive === endExclusive) {\n      return { bufs: [], length: 0 }\n    }\n\n    if (beginInclusive === 0 && endExclusive === this.length) {\n      return { bufs: this.bufs, length: this.length }\n    }\n\n    const bufs: Uint8Array[] = []\n    let offset = 0\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      const buf = this.bufs[i]\n      const bufStart = offset\n      const bufEnd = bufStart + buf.byteLength\n\n      // for next loop\n      offset = bufEnd\n\n      if (beginInclusive >= bufEnd) {\n        // start after this buf\n        continue\n      }\n\n      const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd\n      const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd\n\n      if (sliceStartInBuf && sliceEndsInBuf) {\n        // slice is wholly contained within this buffer\n        if (beginInclusive === bufStart && endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        const start = beginInclusive - bufStart\n        bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)))\n        break\n      }\n\n      if (sliceStartInBuf) {\n        // slice starts in this buffer\n        if (beginInclusive === 0) {\n          // requested whole buffer\n          bufs.push(buf)\n          continue\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(beginInclusive - bufStart))\n        continue\n      }\n\n      if (sliceEndsInBuf) {\n        if (endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(0, endExclusive - bufStart))\n        break\n      }\n\n      // slice started before this buffer and ends after it\n      bufs.push(buf)\n    }\n\n    return { bufs, length: endExclusive - beginInclusive }\n  }\n\n  indexOf (search: Uint8ArrayList | Uint8Array, offset: number = 0): number {\n    if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {\n      throw new TypeError('The \"value\" argument must be a Uint8ArrayList or Uint8Array')\n    }\n\n    const needle = search instanceof Uint8Array ? search : search.subarray()\n\n    offset = Number(offset ?? 0)\n\n    if (isNaN(offset)) {\n      offset = 0\n    }\n\n    if (offset < 0) {\n      offset = this.length + offset\n    }\n\n    if (offset < 0) {\n      offset = 0\n    }\n\n    if (search.length === 0) {\n      return offset > this.length ? this.length : offset\n    }\n\n    // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm\n    const M: number = needle.byteLength\n\n    if (M === 0) {\n      throw new TypeError('search must be at least 1 byte long')\n    }\n\n    // radix\n    const radix: number = 256\n    const rightmostPositions: Int32Array = new Int32Array(radix)\n\n    // position of the rightmost occurrence of the byte c in the pattern\n    for (let c: number = 0; c < radix; c++) {\n      // -1 for bytes not in pattern\n      rightmostPositions[c] = -1\n    }\n\n    for (let j = 0; j < M; j++) {\n      // rightmost position for bytes in pattern\n      rightmostPositions[needle[j]] = j\n    }\n\n    // Return offset of first match, -1 if no match\n    const right = rightmostPositions\n    const lastIndex = this.byteLength - needle.byteLength\n    const lastPatIndex = needle.byteLength - 1\n    let skip: number\n\n    for (let i = offset; i <= lastIndex; i += skip) {\n      skip = 0\n\n      for (let j = lastPatIndex; j >= 0; j--) {\n        const char: number = this.get(i + j)\n\n        if (needle[j] !== char) {\n          skip = Math.max(1, j - right[char])\n          break\n        }\n      }\n\n      if (skip === 0) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  getInt8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt8(0)\n  }\n\n  setInt8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt16(0, littleEndian)\n  }\n\n  setInt16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt32(0, littleEndian)\n  }\n\n  setInt32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigInt64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigInt64(0, littleEndian)\n  }\n\n  setBigInt64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigInt64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint8(0)\n  }\n\n  setUint8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint16(0, littleEndian)\n  }\n\n  setUint16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint32(0, littleEndian)\n  }\n\n  setUint32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigUint64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigUint64(0, littleEndian)\n  }\n\n  setBigUint64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigUint64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat32(0, littleEndian)\n  }\n\n  setFloat32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat64 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat64(0, littleEndian)\n  }\n\n  setFloat64 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  equals (other: any): other is Uint8ArrayList {\n    if (other == null) {\n      return false\n    }\n\n    if (!(other instanceof Uint8ArrayList)) {\n      return false\n    }\n\n    if (other.bufs.length !== this.bufs.length) {\n      return false\n    }\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      if (!equals(this.bufs[i], other.bufs[i])) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this\n   * method if you know the total size of all the Uint8Arrays ahead of time.\n   */\n  static fromUint8Arrays (bufs: Uint8Array[], length?: number): Uint8ArrayList {\n    const list = new Uint8ArrayList()\n    list.bufs = bufs\n\n    if (length == null) {\n      length = bufs.reduce((acc, curr) => acc + curr.byteLength, 0)\n    }\n\n    list.length = length\n\n    return list\n  }\n}\n\n/*\nfunction indexOf (needle: Uint8Array, haystack: Uint8Array, offset = 0) {\n  for (let i = offset; i < haystack.byteLength; i++) {\n    for (let j = 0; j < needle.length; j++) {\n      if (haystack[i + j] !== needle[j]) {\n        break\n      }\n\n      if (j === needle.byteLength -1) {\n        return i\n      }\n    }\n\n    if (haystack.byteLength - i < needle.byteLength) {\n      break\n    }\n  }\n\n  return -1\n}\n*/\n", "export class InvalidFrameError extends Error {\n  static name = 'InvalidFrameError'\n\n  constructor (message = 'The frame was invalid') {\n    super(message)\n    this.name = 'InvalidFrameError'\n  }\n}\n\nexport class UnrequestedPingError extends Error {\n  static name = 'UnrequestedPingError'\n\n  constructor (message = 'Unrequested ping error') {\n    super(message)\n    this.name = 'UnrequestedPingError'\n  }\n}\n\nexport class NotMatchingPingError extends Error {\n  static name = 'NotMatchingPingError'\n\n  constructor (message = 'Unrequested ping error') {\n    super(message)\n    this.name = 'NotMatchingPingError'\n  }\n}\n\nexport class InvalidStateError extends Error {\n  static name = 'InvalidStateError'\n\n  constructor (message = 'Invalid state') {\n    super(message)\n    this.name = 'InvalidStateError'\n  }\n}\n\nexport class StreamAlreadyExistsError extends Error {\n  static name = 'StreamAlreadyExistsError'\n\n  constructor (message = 'Strean already exists') {\n    super(message)\n    this.name = 'StreamAlreadyExistsError'\n  }\n}\n\nexport class DecodeInvalidVersionError extends Error {\n  static name = 'DecodeInvalidVersionError'\n\n  constructor (message = 'Decode invalid version') {\n    super(message)\n    this.name = 'DecodeInvalidVersionError'\n  }\n}\n\nexport class BothClientsError extends Error {\n  static name = 'BothClientsError'\n\n  constructor (message = 'Both clients') {\n    super(message)\n    this.name = 'BothClientsError'\n  }\n}\n\nexport class ReceiveWindowExceededError extends Error {\n  static name = 'ReceiveWindowExceededError'\n\n  constructor (message = 'Receive window exceeded') {\n    super(message)\n    this.name = 'ReceiveWindowExceededError'\n  }\n}\n", "// Protocol violation errors\n\nimport { BothClientsError, DecodeInvalidVersionError, InvalidFrameError, NotMatchingPingError, ReceiveWindowExceededError, StreamAlreadyExistsError, UnrequestedPingError } from './errors.js'\n\nexport const PROTOCOL_ERRORS = new Set([\n  InvalidFrameError.name,\n  UnrequestedPingError.name,\n  NotMatchingPingError.name,\n  StreamAlreadyExistsError.name,\n  DecodeInvalidVersionError.name,\n  BothClientsError.name,\n  ReceiveWindowExceededError.name\n])\n\n/**\n * INITIAL_STREAM_WINDOW is the initial stream window size.\n *\n * Not an implementation choice, this is defined in the specification\n */\nexport const INITIAL_STREAM_WINDOW = 256 * 1024\n\n/**\n * Default max stream window\n */\nexport const MAX_STREAM_WINDOW = 16 * 1024 * 1024\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { INITIAL_STREAM_WINDOW, MAX_STREAM_WINDOW } from './constants.js'\n\n// TOOD use config items or delete them\nexport interface Config {\n  /**\n   * Used to do periodic keep alive messages using a ping.\n   */\n  enableKeepAlive: boolean\n\n  /**\n   * How often to perform the keep alive\n   *\n   * measured in milliseconds\n   */\n  keepAliveInterval: number\n\n  /**\n   * Maximum number of concurrent inbound streams that we accept.\n   * If the peer tries to open more streams, those will be reset immediately.\n   */\n  maxInboundStreams: number\n\n  /**\n   * Maximum number of concurrent outbound streams that we accept.\n   * If the application tries to open more streams, the call to `newStream` will throw\n   */\n  maxOutboundStreams: number\n\n  /**\n   * Used to control the initial window size that we allow for a stream.\n   *\n   * measured in bytes\n   */\n  initialStreamWindowSize: number\n\n  /**\n   * Used to control the maximum window size that we allow for a stream.\n   */\n  maxStreamWindowSize: number\n\n  /**\n   * Maximum size of a message that we'll send on a stream.\n   * This ensures that a single stream doesn't hog a connection.\n   */\n  maxMessageSize: number\n}\n\nexport const defaultConfig: Config = {\n  enableKeepAlive: true,\n  keepAliveInterval: 30_000,\n  maxInboundStreams: 1_000,\n  maxOutboundStreams: 1_000,\n  initialStreamWindowSize: INITIAL_STREAM_WINDOW,\n  maxStreamWindowSize: MAX_STREAM_WINDOW,\n  maxMessageSize: 64 * 1024\n}\n\nexport function verifyConfig (config: Config): void {\n  if (config.keepAliveInterval <= 0) {\n    throw new InvalidParametersError('keep-alive interval must be positive')\n  }\n  if (config.maxInboundStreams < 0) {\n    throw new InvalidParametersError('max inbound streams must be larger or equal 0')\n  }\n  if (config.maxOutboundStreams < 0) {\n    throw new InvalidParametersError('max outbound streams must be larger or equal 0')\n  }\n  if (config.initialStreamWindowSize < INITIAL_STREAM_WINDOW) {\n    throw new InvalidParametersError('InitialStreamWindowSize must be larger or equal 256 kB')\n  }\n  if (config.maxStreamWindowSize < config.initialStreamWindowSize) {\n    throw new InvalidParametersError('MaxStreamWindowSize must be larger than the InitialStreamWindowSize')\n  }\n  if (config.maxStreamWindowSize > 2 ** 32 - 1) {\n    throw new InvalidParametersError('MaxStreamWindowSize must be less than equal MAX_UINT32')\n  }\n  if (config.maxMessageSize < 1024) {\n    throw new InvalidParametersError('MaxMessageSize must be greater than a kilobyte')\n  }\n}\n", "export enum FrameType {\n  /** Used to transmit data. May transmit zero length payloads depending on the flags. */\n  Data = 0x0,\n  /** Used to updated the senders receive window size. This is used to implement per-session flow control. */\n  WindowUpdate = 0x1,\n  /** Used to measure RTT. It can also be used to heart-beat and do keep-alives over TCP. */\n  Ping = 0x2,\n  /** Used to close a session. */\n  GoAway = 0x3\n}\n\nexport enum Flag {\n  /** Signals the start of a new stream. May be sent with a data or window update message. Also sent with a ping to indicate outbound. */\n  SYN = 0x1,\n  /** Acknowledges the start of a new stream. May be sent with a data or window update message. Also sent with a ping to indicate response. */\n  ACK = 0x2,\n  /** Performs a half-close of a stream. May be sent with a data message or window update. */\n  FIN = 0x4,\n  /** Reset a stream immediately. May be sent with a data or window update message. */\n  RST = 0x8\n}\n\nconst flagCodes = Object.values(Flag).filter((x) => typeof x !== 'string') as Flag[]\n\nexport const YAMUX_VERSION = 0\n\nexport enum GoAwayCode {\n  NormalTermination = 0x0,\n  ProtocolError = 0x1,\n  InternalError = 0x2\n}\n\nexport const HEADER_LENGTH = 12\n\nexport interface FrameHeader {\n  /**\n   * The version field is used for future backward compatibility.\n   * At the current time, the field is always set to 0, to indicate the initial version.\n   */\n  version?: number\n  /** The type field is used to switch the frame message type. */\n  type: FrameType\n  /** The flags field is used to provide additional information related to the message type. */\n  flag: number\n  /**\n   * The StreamID field is used to identify the logical stream the frame is addressing.\n   * The client side should use odd ID's, and the server even.\n   * This prevents any collisions. Additionally, the 0 ID is reserved to represent the session.\n   */\n  streamID: number\n  /**\n   * The meaning of the length field depends on the message type:\n   * Data - provides the length of bytes following the header\n   * Window update - provides a delta update to the window size\n   * Ping - Contains an opaque value, echoed back\n   * Go Away - Contains an error code\n   */\n  length: number\n}\n\nexport function stringifyHeader (header: FrameHeader): string {\n  const flags = flagCodes.filter(f => (header.flag & f) === f).map(f => Flag[f]).join('|')\n  return `streamID=${header.streamID} type=${FrameType[header.type]} flag=${flags} length=${header.length}`\n}\n", "import { Uint8ArrayList } from 'uint8arraylist'\nimport { InvalidFrameError, InvalidStateError } from './errors.js'\nimport { FrameType, HEADER_LENGTH, YAMUX_VERSION } from './frame.js'\nimport type { FrameHeader } from './frame.js'\nimport type { Source } from 'it-stream-types'\n\n// used to bitshift in decoding\n// native bitshift can overflow into a negative number, so we bitshift by multiplying by a power of 2\nconst twoPow24 = 2 ** 24\n\n/**\n * Decode a header from the front of a buffer\n *\n * @param data - Assumed to have enough bytes for a header\n */\nexport function decodeHeader (data: Uint8Array): FrameHeader {\n  if (data[0] !== YAMUX_VERSION) {\n    throw new InvalidFrameError('Invalid frame version')\n  }\n  return {\n    type: data[1],\n    flag: (data[2] << 8) + data[3],\n    streamID: (data[4] * twoPow24) + (data[5] << 16) + (data[6] << 8) + data[7],\n    length: (data[8] * twoPow24) + (data[9] << 16) + (data[10] << 8) + data[11]\n  }\n}\n\n/**\n * Decodes yamux frames from a source\n */\nexport class Decoder {\n  private readonly source: Source<Uint8Array | Uint8ArrayList>\n  /** Buffer for in-progress frames */\n  private readonly buffer: Uint8ArrayList\n  /** Used to sanity check against decoding while in an inconsistent state */\n  private frameInProgress: boolean\n\n  constructor (source: Source<Uint8Array | Uint8ArrayList>) {\n    // Normally, when entering a for-await loop with an iterable/async iterable, the only ways to exit the loop are:\n    // 1. exhaust the iterable\n    // 2. throw an error - slow, undesirable if there's not actually an error\n    // 3. break or return - calls the iterable's `return` method, finalizing the iterable, no more iteration possible\n    //\n    // In this case, we want to enter (and exit) a for-await loop per chunked data frame and continue processing the iterable.\n    // To do this, we strip the `return` method from the iterator and can now `break` early and continue iterating.\n    // Exiting the main for-await is still possible via 1. and 2.\n    this.source = returnlessSource(source)\n    this.buffer = new Uint8ArrayList()\n    this.frameInProgress = false\n  }\n\n  /**\n   * Emits frames from the decoder source.\n   *\n   * Note: If `readData` is emitted, it _must_ be called before the next iteration\n   * Otherwise an error is thrown\n   */\n  async * emitFrames (): AsyncGenerator<{ header: FrameHeader, readData?(): Promise<Uint8ArrayList> }> {\n    for await (const chunk of this.source) {\n      this.buffer.append(chunk)\n\n      // Loop to consume as many bytes from the buffer as possible\n      // Eg: when a single chunk contains several frames\n      while (true) {\n        const header = this.readHeader()\n        if (header === undefined) {\n          break\n        }\n\n        const { type, length } = header\n        if (type === FrameType.Data) {\n          // This is a data frame, the frame body must still be read\n          // `readData` must be called before the next iteration here\n          this.frameInProgress = true\n          yield {\n            header,\n            readData: this.readBytes.bind(this, length)\n          }\n        } else {\n          yield { header }\n        }\n      }\n    }\n  }\n\n  private readHeader (): FrameHeader | undefined {\n    // Sanity check to ensure a header isn't read when another frame is partially decoded\n    // In practice this shouldn't happen\n    if (this.frameInProgress) {\n      throw new InvalidStateError('decoding frame already in progress')\n    }\n\n    if (this.buffer.length < HEADER_LENGTH) {\n      // not enough data yet\n      return\n    }\n\n    const header = decodeHeader(this.buffer.subarray(0, HEADER_LENGTH))\n    this.buffer.consume(HEADER_LENGTH)\n    return header\n  }\n\n  private async readBytes (length: number): Promise<Uint8ArrayList> {\n    if (this.buffer.length < length) {\n      for await (const chunk of this.source) {\n        this.buffer.append(chunk)\n\n        if (this.buffer.length >= length) {\n          // see note above, the iterator is not `return`ed here\n          break\n        }\n      }\n    }\n\n    const out = this.buffer.sublist(0, length)\n    this.buffer.consume(length)\n\n    // The next frame can now be decoded\n    this.frameInProgress = false\n\n    return out\n  }\n}\n\n/**\n * Strip the `return` method from a `Source`\n */\nexport function returnlessSource<T> (source: Source<T>): Source<T> {\n  if ((source as Iterable<T>)[Symbol.iterator] !== undefined) {\n    const iterator = (source as Iterable<T>)[Symbol.iterator]()\n    iterator.return = undefined\n    return {\n      [Symbol.iterator] () { return iterator }\n    }\n  } else if ((source as AsyncIterable<T>)[Symbol.asyncIterator] !== undefined) {\n    const iterator = (source as AsyncIterable<T>)[Symbol.asyncIterator]()\n    iterator.return = undefined\n    return {\n      [Symbol.asyncIterator] () { return iterator }\n    }\n  } else {\n    throw new Error('a source must be either an iterable or an async iterable')\n  }\n}\n", "import { HEADER_LENGTH } from './frame.js'\nimport type { FrameHeader } from './frame.js'\n\nexport function encodeHeader (header: FrameHeader): Uint8Array {\n  const frame = new Uint8Array(HEADER_LENGTH)\n\n  // always assume version 0\n  // frameView.setUint8(0, header.version)\n\n  frame[1] = header.type\n\n  frame[2] = header.flag >>> 8\n  frame[3] = header.flag\n\n  frame[4] = header.streamID >>> 24\n  frame[5] = header.streamID >>> 16\n  frame[6] = header.streamID >>> 8\n  frame[7] = header.streamID\n\n  frame[8] = header.length >>> 24\n  frame[9] = header.length >>> 16\n  frame[10] = header.length >>> 8\n  frame[11] = header.length\n\n  return frame\n}\n", "/**\n * An abort error class that extends error\n */\nexport class AbortError extends Error {\n  public type: string\n  public code: string | string\n\n  constructor (message?: string, code?: string, name?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.name = name ?? 'AbortError'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface RaceSignalOptions {\n  /**\n   * The message for the error thrown if the signal aborts\n   */\n  errorMessage?: string\n\n  /**\n   * The code for the error thrown if the signal aborts\n   */\n  errorCode?: string\n\n  /**\n   * The name for the error thrown if the signal aborts\n   */\n  errorName?: string\n}\n\n/**\n * Race a promise against an abort signal\n */\nexport async function raceSignal <T> (promise: Promise<T>, signal?: AbortSignal, opts?: RaceSignalOptions): Promise<T> {\n  if (signal == null) {\n    return promise\n  }\n\n  if (signal.aborted) {\n    // the passed promise may yet resolve or reject but the use has signalled\n    // they are no longer interested so smother the error\n    promise.catch(() => {})\n    return Promise.reject(new AbortError(opts?.errorMessage, opts?.errorCode, opts?.errorName))\n  }\n\n  let listener\n\n  // create the error here so we have more context in the stack trace\n  const error = new AbortError(opts?.errorMessage, opts?.errorCode, opts?.errorName)\n\n  try {\n    return await Promise.race([\n      promise,\n      new Promise<T>((resolve, reject) => {\n        listener = () => {\n          reject(error)\n        }\n        signal.addEventListener('abort', listener)\n      })\n    ])\n  } finally {\n    if (listener != null) {\n      signal.removeEventListener('abort', listener)\n    }\n  }\n}\n", "export function isPromise <T = unknown> (thing: any): thing is Promise<T> {\n  if (thing == null) {\n    return false\n  }\n\n  return typeof thing.then === 'function' &&\n    typeof thing.catch === 'function' &&\n    typeof thing.finally === 'function'\n}\n", "import { getIterator } from 'get-iterator'\nimport { isPromise } from './is-promise.js'\nimport type { Logger } from '@libp2p/logger'\nimport type { Source } from 'it-stream-types'\n\nexport function closeSource (source: Source<unknown>, log: Logger): void {\n  const res = getIterator(source).return?.()\n\n  if (isPromise(res)) {\n    res.catch(err => {\n      log.error('could not cause iterator to return', err)\n    })\n  }\n}\n", "import { StreamResetError, StreamStateError } from '@libp2p/interface'\nimport { pushable } from 'it-pushable'\nimport defer from 'p-defer'\nimport { raceSignal } from 'race-signal'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { closeSource } from './close-source.js'\nimport type { AbortOptions, Direction, ReadStatus, Stream, StreamStatus, StreamTimeline, WriteStatus } from '@libp2p/interface'\nimport type { Logger } from '@libp2p/logger'\nimport type { Pushable } from 'it-pushable'\nimport type { Source } from 'it-stream-types'\nimport type { DeferredPromise } from 'p-defer'\n\nconst DEFAULT_SEND_CLOSE_WRITE_TIMEOUT = 5000\n\nexport interface AbstractStreamInit {\n  /**\n   * A unique identifier for this stream\n   */\n  id: string\n\n  /**\n   * The stream direction\n   */\n  direction: Direction\n\n  /**\n   * A Logger implementation used to log stream-specific information\n   */\n  log: Logger\n\n  /**\n   * User specific stream metadata\n   */\n  metadata?: Record<string, unknown>\n\n  /**\n   * Invoked when the stream ends\n   */\n  onEnd?(err?: Error): void\n\n  /**\n   * Invoked when the readable end of the stream is closed\n   */\n  onCloseRead?(): void\n\n  /**\n   * Invoked when the writable end of the stream is closed\n   */\n  onCloseWrite?(): void\n\n  /**\n   * Invoked when the stream has been reset by the remote\n   */\n  onReset?(): void\n\n  /**\n   * Invoked when the stream has errored\n   */\n  onAbort?(err: Error): void\n\n  /**\n   * How long to wait in ms for stream data to be written to the underlying\n   * connection when closing the writable end of the stream.\n   *\n   * @default 500\n   */\n  closeTimeout?: number\n\n  /**\n   * After the stream sink has closed, a limit on how long it takes to send\n   * a close-write message to the remote peer.\n   */\n  sendCloseWriteTimeout?: number\n}\n\nfunction isPromise <T = unknown> (thing: any): thing is Promise<T> {\n  if (thing == null) {\n    return false\n  }\n\n  return typeof thing.then === 'function' &&\n    typeof thing.catch === 'function' &&\n    typeof thing.finally === 'function'\n}\n\nexport abstract class AbstractStream implements Stream {\n  public id: string\n  public direction: Direction\n  public timeline: StreamTimeline\n  public protocol?: string\n  public metadata: Record<string, unknown>\n  public source: AsyncGenerator<Uint8ArrayList, void, unknown>\n  public status: StreamStatus\n  public readStatus: ReadStatus\n  public writeStatus: WriteStatus\n  public readonly log: Logger\n\n  private readonly sinkController: AbortController\n  private readonly sinkEnd: DeferredPromise<void>\n  private readonly closed: DeferredPromise<void>\n  private endErr: Error | undefined\n  private readonly streamSource: Pushable<Uint8ArrayList>\n  private readonly onEnd?: (err?: Error) => void\n  private readonly onCloseRead?: () => void\n  private readonly onCloseWrite?: () => void\n  private readonly onReset?: () => void\n  private readonly onAbort?: (err: Error) => void\n  private readonly sendCloseWriteTimeout: number\n  private sendingData?: DeferredPromise<void>\n\n  constructor (init: AbstractStreamInit) {\n    this.sinkController = new AbortController()\n    this.sinkEnd = defer()\n    this.closed = defer()\n    this.log = init.log\n\n    // stream status\n    this.status = 'open'\n    this.readStatus = 'ready'\n    this.writeStatus = 'ready'\n\n    this.id = init.id\n    this.metadata = init.metadata ?? {}\n    this.direction = init.direction\n    this.timeline = {\n      open: Date.now()\n    }\n    this.sendCloseWriteTimeout = init.sendCloseWriteTimeout ?? DEFAULT_SEND_CLOSE_WRITE_TIMEOUT\n\n    this.onEnd = init.onEnd\n    this.onCloseRead = init.onCloseRead\n    this.onCloseWrite = init.onCloseWrite\n    this.onReset = init.onReset\n    this.onAbort = init.onAbort\n\n    this.source = this.streamSource = pushable<Uint8ArrayList>({\n      onEnd: (err) => {\n        if (err != null) {\n          this.log.trace('source ended with error', err)\n        } else {\n          this.log.trace('source ended')\n        }\n\n        this.onSourceEnd(err)\n      }\n    })\n\n    // necessary because the libp2p upgrader wraps the sink function\n    this.sink = this.sink.bind(this)\n  }\n\n  async sink (source: Source<Uint8ArrayList | Uint8Array>): Promise<void> {\n    if (this.writeStatus !== 'ready') {\n      throw new StreamStateError(`writable end state is \"${this.writeStatus}\" not \"ready\"`)\n    }\n\n    try {\n      this.writeStatus = 'writing'\n\n      const options: AbortOptions = {\n        signal: this.sinkController.signal\n      }\n\n      if (this.direction === 'outbound') { // If initiator, open a new stream\n        const res = this.sendNewStream(options)\n\n        if (isPromise(res)) {\n          await res\n        }\n      }\n\n      const abortListener = (): void => {\n        closeSource(source, this.log)\n      }\n\n      try {\n        this.sinkController.signal.addEventListener('abort', abortListener)\n\n        this.log.trace('sink reading from source')\n\n        for await (let data of source) {\n          data = data instanceof Uint8Array ? new Uint8ArrayList(data) : data\n\n          const res = this.sendData(data, options)\n\n          if (isPromise(res)) {\n            this.sendingData = defer()\n            await res\n            this.sendingData.resolve()\n            this.sendingData = undefined\n          }\n        }\n      } finally {\n        this.sinkController.signal.removeEventListener('abort', abortListener)\n      }\n\n      this.log.trace('sink finished reading from source, write status is \"%s\"', this.writeStatus)\n\n      if (this.writeStatus === 'writing') {\n        this.writeStatus = 'closing'\n\n        this.log.trace('send close write to remote')\n        await this.sendCloseWrite({\n          signal: AbortSignal.timeout(this.sendCloseWriteTimeout)\n        })\n\n        this.writeStatus = 'closed'\n      }\n\n      this.onSinkEnd()\n    } catch (err: any) {\n      this.log.trace('sink ended with error, calling abort with error', err)\n      this.abort(err)\n\n      throw err\n    } finally {\n      this.log.trace('resolve sink end')\n      this.sinkEnd.resolve()\n    }\n  }\n\n  protected onSourceEnd (err?: Error): void {\n    if (this.timeline.closeRead != null) {\n      return\n    }\n\n    this.timeline.closeRead = Date.now()\n    this.readStatus = 'closed'\n\n    if (err != null && this.endErr == null) {\n      this.endErr = err\n    }\n\n    this.onCloseRead?.()\n\n    if (this.timeline.closeWrite != null) {\n      this.log.trace('source and sink ended')\n      this.timeline.close = Date.now()\n\n      if (this.status !== 'aborted' && this.status !== 'reset') {\n        this.status = 'closed'\n      }\n\n      if (this.onEnd != null) {\n        this.onEnd(this.endErr)\n      }\n\n      this.closed.resolve()\n    } else {\n      this.log.trace('source ended, waiting for sink to end')\n    }\n  }\n\n  protected onSinkEnd (err?: Error): void {\n    if (this.timeline.closeWrite != null) {\n      return\n    }\n\n    this.timeline.closeWrite = Date.now()\n    this.writeStatus = 'closed'\n\n    if (err != null && this.endErr == null) {\n      this.endErr = err\n    }\n\n    this.onCloseWrite?.()\n\n    if (this.timeline.closeRead != null) {\n      this.log.trace('sink and source ended')\n      this.timeline.close = Date.now()\n\n      if (this.status !== 'aborted' && this.status !== 'reset') {\n        this.status = 'closed'\n      }\n\n      if (this.onEnd != null) {\n        this.onEnd(this.endErr)\n      }\n\n      this.closed.resolve()\n    } else {\n      this.log.trace('sink ended, waiting for source to end')\n    }\n  }\n\n  // Close for both Reading and Writing\n  async close (options?: AbortOptions): Promise<void> {\n    if (this.status !== 'open') {\n      return\n    }\n\n    this.log.trace('closing gracefully')\n\n    this.status = 'closing'\n\n    // wait for read and write ends to close\n    await raceSignal(Promise.all([\n      this.closeWrite(options),\n      this.closeRead(options),\n      this.closed.promise\n    ]), options?.signal)\n\n    this.status = 'closed'\n\n    this.log.trace('closed gracefully')\n  }\n\n  async closeRead (options: AbortOptions = {}): Promise<void> {\n    if (this.readStatus === 'closing' || this.readStatus === 'closed') {\n      return\n    }\n\n    this.log.trace('closing readable end of stream with starting read status \"%s\"', this.readStatus)\n\n    const readStatus = this.readStatus\n    this.readStatus = 'closing'\n\n    if (this.status !== 'reset' && this.status !== 'aborted' && this.timeline.closeRead == null) {\n      this.log.trace('send close read to remote')\n      await this.sendCloseRead(options)\n    }\n\n    if (readStatus === 'ready') {\n      this.log.trace('ending internal source queue with %d queued bytes', this.streamSource.readableLength)\n      this.streamSource.end()\n    }\n\n    this.log.trace('closed readable end of stream')\n  }\n\n  async closeWrite (options: AbortOptions = {}): Promise<void> {\n    if (this.writeStatus === 'closing' || this.writeStatus === 'closed') {\n      return\n    }\n\n    this.log.trace('closing writable end of stream with starting write status \"%s\"', this.writeStatus)\n\n    if (this.writeStatus === 'ready') {\n      this.log.trace('sink was never sunk, sink an empty array')\n\n      await raceSignal(this.sink([]), options.signal)\n    }\n\n    if (this.writeStatus === 'writing') {\n      // try to let sending outgoing data succeed\n      if (this.sendingData != null) {\n        await raceSignal(this.sendingData.promise, options.signal)\n      }\n\n      // stop reading from the source passed to `.sink`\n      this.log.trace('aborting source passed to .sink')\n      this.sinkController.abort()\n      await raceSignal(this.sinkEnd.promise, options.signal)\n    }\n\n    this.writeStatus = 'closed'\n\n    this.log.trace('closed writable end of stream')\n  }\n\n  /**\n   * Close immediately for reading and writing and send a reset message (local\n   * error)\n   */\n  abort (err: Error): void {\n    if (this.status === 'closed' || this.status === 'aborted' || this.status === 'reset') {\n      return\n    }\n\n    this.log('abort with error', err)\n\n    // try to send a reset message\n    this.log('try to send reset to remote')\n    const res = this.sendReset()\n\n    if (isPromise(res)) {\n      res.catch((err) => {\n        this.log.error('error sending reset message', err)\n      })\n    }\n\n    this.status = 'aborted'\n    this.timeline.abort = Date.now()\n    this._closeSinkAndSource(err)\n    this.onAbort?.(err)\n  }\n\n  /**\n   * Receive a reset message - close immediately for reading and writing (remote\n   * error)\n   */\n  reset (): void {\n    if (this.status === 'closed' || this.status === 'aborted' || this.status === 'reset') {\n      return\n    }\n\n    const err = new StreamResetError('stream reset')\n\n    this.status = 'reset'\n    this.timeline.reset = Date.now()\n    this._closeSinkAndSource(err)\n    this.onReset?.()\n  }\n\n  _closeSinkAndSource (err?: Error): void {\n    this._closeSink(err)\n    this._closeSource(err)\n  }\n\n  _closeSink (err?: Error): void {\n    // if the sink function is running, cause it to end\n    if (this.writeStatus === 'writing') {\n      this.log.trace('end sink source')\n      this.sinkController.abort()\n    }\n\n    this.onSinkEnd(err)\n  }\n\n  _closeSource (err?: Error): void {\n    // if the source is not ending, end it\n    if (this.readStatus !== 'closing' && this.readStatus !== 'closed') {\n      this.log.trace('ending source with %d bytes to be read by consumer', this.streamSource.readableLength)\n      this.readStatus = 'closing'\n      this.streamSource.end(err)\n    }\n  }\n\n  /**\n   * The remote closed for writing so we should expect to receive no more\n   * messages\n   */\n  remoteCloseWrite (): void {\n    if (this.readStatus === 'closing' || this.readStatus === 'closed') {\n      this.log('received remote close write but local source is already closed')\n      return\n    }\n\n    this.log.trace('remote close write')\n    this._closeSource()\n  }\n\n  /**\n   * The remote closed for reading so we should not send any more\n   * messages\n   */\n  remoteCloseRead (): void {\n    if (this.writeStatus === 'closing' || this.writeStatus === 'closed') {\n      this.log('received remote close read but local sink is already closed')\n      return\n    }\n\n    this.log.trace('remote close read')\n    this._closeSink()\n  }\n\n  /**\n   * The underlying muxer has closed, no more messages can be sent or will\n   * be received, close immediately to free up resources\n   */\n  destroy (): void {\n    if (this.status === 'closed' || this.status === 'aborted' || this.status === 'reset') {\n      this.log('received destroy but we are already closed')\n      return\n    }\n\n    this.log.trace('stream destroyed')\n\n    this._closeSinkAndSource()\n  }\n\n  /**\n   * When an extending class reads data from it's implementation-specific source,\n   * call this method to allow the stream consumer to read the data.\n   */\n  sourcePush (data: Uint8ArrayList): void {\n    this.streamSource.push(data)\n  }\n\n  /**\n   * Returns the amount of unread data - can be used to prevent large amounts of\n   * data building up when the stream consumer is too slow.\n   */\n  sourceReadableLength (): number {\n    return this.streamSource.readableLength\n  }\n\n  /**\n   * Send a message to the remote muxer informing them a new stream is being\n   * opened\n   */\n  abstract sendNewStream (options?: AbortOptions): void | Promise<void>\n\n  /**\n   * Send a data message to the remote muxer\n   */\n  abstract sendData (buf: Uint8ArrayList, options?: AbortOptions): void | Promise<void>\n\n  /**\n   * Send a reset message to the remote muxer\n   */\n  abstract sendReset (options?: AbortOptions): void | Promise<void>\n\n  /**\n   * Send a message to the remote muxer, informing them no more data messages\n   * will be sent by this end of the stream\n   */\n  abstract sendCloseWrite (options?: AbortOptions): void | Promise<void>\n\n  /**\n   * Send a message to the remote muxer, informing them no more data messages\n   * will be read by this end of the stream\n   */\n  abstract sendCloseRead (options?: AbortOptions): void | Promise<void>\n}\n", "/**\n * @packageDocumentation\n *\n * Lets you look at the contents of an async iterator and decide what to do\n *\n * @example\n *\n * ```javascript\n * import peekable from 'it-peekable'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const it = peekable(value)\n *\n * const first = it.peek()\n *\n * console.info(first) // 0\n *\n * it.push(first)\n *\n * console.info([...it])\n * // [ 0, 1, 2, 3, 4 ]\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import peekable from 'it-peekable'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const it = peekable(values())\n *\n * const first = await it.peek()\n *\n * console.info(first) // 0\n *\n * it.push(first)\n *\n * console.info(await all(it))\n * // [ 0, 1, 2, 3, 4 ]\n * ```\n */\n\nexport interface Peek <T> {\n  peek(): IteratorResult<T, undefined>\n}\n\nexport interface AsyncPeek <T> {\n  peek(): Promise<IteratorResult<T, undefined>>\n}\n\nexport interface Push <T> {\n  push(value: T): void\n}\n\nexport type Peekable <T> = Iterable<T> & Peek<T> & Push<T> & Iterator<T>\n\nexport type AsyncPeekable <T> = AsyncIterable<T> & AsyncPeek<T> & Push<T> & AsyncIterator<T>\n\nfunction peekable <T> (iterable: Iterable<T>): Peekable<T>\nfunction peekable <T> (iterable: AsyncIterable<T>): AsyncPeekable<T>\nfunction peekable <T> (iterable: Iterable<T> | AsyncIterable<T>): Peekable<T> | AsyncPeekable<T> {\n  // @ts-expect-error can't use Symbol.asyncIterator to index iterable since it might be Iterable\n  const [iterator, symbol] = iterable[Symbol.asyncIterator] != null\n    // @ts-expect-error can't use Symbol.asyncIterator to index iterable since it might be Iterable\n    ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator]\n    // @ts-expect-error can't use Symbol.iterator to index iterable since it might be AsyncIterable\n    : [iterable[Symbol.iterator](), Symbol.iterator]\n\n  const queue: any[] = []\n\n  // @ts-expect-error can't use symbol to index peekable\n  return {\n    peek: () => {\n      return iterator.next()\n    },\n    push: (value: any) => {\n      queue.push(value)\n    },\n    next: () => {\n      if (queue.length > 0) {\n        return {\n          done: false,\n          value: queue.shift()\n        }\n      }\n\n      return iterator.next()\n    },\n    [symbol] () {\n      return this\n    }\n  }\n}\n\nexport default peekable\n", "/**\n * @packageDocumentation\n *\n * Calls a function for each value in an (async)iterable.\n *\n * The function can be sync or async.\n *\n * Async functions can be awaited on so may slow down processing of the (async)iterable.\n *\n * @example\n *\n * ```javascript\n * import each from 'it-foreach'\n * import drain from 'it-drain'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * // prints [0, 0], [1, 1], [2, 2], [3, 3], [4, 4]\n * const arr = drain(\n *   each(values, console.info)\n * )\n * ```\n *\n * Async sources and callbacks must be awaited:\n *\n * ```javascript\n * import each from 'it-foreach'\n * import drain from 'it-drain'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * // prints [0, 0], [1, 1], [2, 2], [3, 3], [4, 4]\n * const arr = await drain(\n *   each(values(), console.info)\n * )\n * ```\n */\n\nimport peek from 'it-peekable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\nfunction isPromise <T = unknown> (thing: any): thing is Promise<T> {\n  return thing?.then != null\n}\n\n/**\n * Invokes the passed function for each item in an iterable\n */\nfunction forEach <T> (source: Iterable<T>, fn: (thing: T, index: number) => Promise<void>): AsyncGenerator<T, void, undefined>\nfunction forEach <T> (source: Iterable<T>, fn: (thing: T, index: number) => void): Generator<T, void, undefined>\nfunction forEach <T> (source: Iterable<T> | AsyncIterable<T>, fn: (thing: T, index: number) => void | Promise<void>): AsyncGenerator<T, void, undefined>\nfunction forEach <T> (source: Iterable<T> | AsyncIterable<T>, fn: (thing: T, index: number) => void | Promise<void>): AsyncGenerator<T, void, undefined> | Generator<T, void, undefined> {\n  let index = 0\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const val of source) {\n        const res = fn(val, index++)\n\n        if (isPromise(res)) {\n          await res\n        }\n\n        yield val\n      }\n    })()\n  }\n\n  // if fn function returns a promise we have to return an async generator\n  const peekable = peek(source)\n  const { value, done } = peekable.next()\n\n  if (done === true) {\n    return (function * () {}())\n  }\n\n  const res = fn(value, index++)\n\n  if (typeof res?.then === 'function') {\n    return (async function * () {\n      yield value\n\n      for (const val of peekable) {\n        const res = fn(val, index++)\n\n        if (isPromise(res)) {\n          await res\n        }\n\n        yield val\n      }\n    })()\n  }\n\n  const func = fn as (val: T, index: number) => void\n\n  return (function * () {\n    yield value\n\n    for (const val of peekable) {\n      func(val, index++)\n      yield val\n    }\n  })()\n}\n\nexport default forEach\n", "import { AbortError } from '@libp2p/interface'\nimport { AbstractStream } from '@libp2p/utils/abstract-stream'\nimport each from 'it-foreach'\nimport { INITIAL_STREAM_WINDOW } from './constants.js'\nimport { ReceiveWindowExceededError } from './errors.js'\nimport { Flag, FrameType, HEADER_LENGTH } from './frame.js'\nimport type { Config } from './config.js'\nimport type { FrameHeader } from './frame.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { AbstractStreamInit } from '@libp2p/utils/abstract-stream'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport enum StreamState {\n  Init,\n  SYNSent,\n  SYNReceived,\n  Established,\n  Finished\n}\n\nexport interface YamuxStreamInit extends AbstractStreamInit {\n  name?: string\n  sendFrame(header: FrameHeader, body?: Uint8ArrayList): void\n  getRTT(): number\n  config: Config\n  state: StreamState\n}\n\n/** YamuxStream is used to represent a logical stream within a session */\nexport class YamuxStream extends AbstractStream {\n  name?: string\n  state: StreamState\n\n  private readonly config: Config\n  private readonly _id: number\n\n  /** The number of available bytes to send */\n  private sendWindowCapacity: number\n  /** Callback to notify that the sendWindowCapacity has been updated */\n  private sendWindowCapacityUpdate?: () => void\n\n  /** The number of bytes available to receive in a full window */\n  private recvWindow: number\n  /** The number of available bytes to receive */\n  private recvWindowCapacity: number\n\n  /**\n   * An 'epoch' is the time it takes to process and read data\n   *\n   * Used in conjunction with RTT to determine whether to increase the recvWindow\n   */\n  private epochStart: number\n  private readonly getRTT: () => number\n\n  private readonly sendFrame: (header: FrameHeader, body?: Uint8ArrayList) => void\n\n  constructor (init: YamuxStreamInit) {\n    super({\n      ...init,\n      onEnd: (err?: Error) => {\n        this.state = StreamState.Finished\n        init.onEnd?.(err)\n      }\n    })\n\n    this.config = init.config\n    this._id = parseInt(init.id, 10)\n    this.name = init.name\n    this.state = init.state\n    this.sendWindowCapacity = INITIAL_STREAM_WINDOW\n    this.recvWindow = this.config.initialStreamWindowSize\n    this.recvWindowCapacity = this.recvWindow\n    this.epochStart = Date.now()\n    this.getRTT = init.getRTT\n\n    this.sendFrame = init.sendFrame\n\n    this.source = each(this.source, () => {\n      this.sendWindowUpdate()\n    })\n  }\n\n  /**\n   * Send a message to the remote muxer informing them a new stream is being\n   * opened.\n   *\n   * This is a noop for Yamux because the first window update is sent when\n   * .newStream is called on the muxer which opens the stream on the remote.\n   */\n  async sendNewStream (): Promise<void> {\n\n  }\n\n  /**\n   * Send a data message to the remote muxer\n   */\n  async sendData (buf: Uint8ArrayList, options: AbortOptions = {}): Promise<void> {\n    buf = buf.sublist()\n\n    // send in chunks, waiting for window updates\n    while (buf.byteLength !== 0) {\n      // wait for the send window to refill\n      if (this.sendWindowCapacity === 0) {\n        this.log?.trace('wait for send window capacity, status %s', this.status)\n        await this.waitForSendWindowCapacity(options)\n\n        // check we didn't close while waiting for send window capacity\n        if (this.status === 'closed' || this.status === 'aborted' || this.status === 'reset') {\n          this.log?.trace('%s while waiting for send window capacity', this.status)\n          return\n        }\n      }\n\n      // send as much as we can\n      const toSend = Math.min(this.sendWindowCapacity, this.config.maxMessageSize - HEADER_LENGTH, buf.length)\n      const flags = this.getSendFlags()\n\n      this.sendFrame({\n        type: FrameType.Data,\n        flag: flags,\n        streamID: this._id,\n        length: toSend\n      }, buf.sublist(0, toSend))\n\n      this.sendWindowCapacity -= toSend\n\n      buf.consume(toSend)\n    }\n  }\n\n  /**\n   * Send a reset message to the remote muxer\n   */\n  async sendReset (): Promise<void> {\n    this.sendFrame({\n      type: FrameType.WindowUpdate,\n      flag: Flag.RST,\n      streamID: this._id,\n      length: 0\n    })\n  }\n\n  /**\n   * Send a message to the remote muxer, informing them no more data messages\n   * will be sent by this end of the stream\n   */\n  async sendCloseWrite (): Promise<void> {\n    const flags = this.getSendFlags() | Flag.FIN\n    this.sendFrame({\n      type: FrameType.WindowUpdate,\n      flag: flags,\n      streamID: this._id,\n      length: 0\n    })\n  }\n\n  /**\n   * Send a message to the remote muxer, informing them no more data messages\n   * will be read by this end of the stream\n   */\n  async sendCloseRead (): Promise<void> {\n\n  }\n\n  /**\n   * Wait for the send window to be non-zero\n   *\n   * Will throw with ERR_STREAM_ABORT if the stream gets aborted\n   */\n  async waitForSendWindowCapacity (options: AbortOptions = {}): Promise<void> {\n    if (this.sendWindowCapacity > 0) {\n      return\n    }\n\n    let resolve: () => void\n    let reject: (err: Error) => void\n    const abort = (): void => {\n      if (this.status === 'open' || this.status === 'closing') {\n        reject(new AbortError('Stream aborted'))\n      } else {\n        // the stream was closed already, ignore the failure to send\n        resolve()\n      }\n    }\n    options.signal?.addEventListener('abort', abort)\n\n    try {\n      await new Promise<void>((_resolve, _reject) => {\n        this.sendWindowCapacityUpdate = () => {\n          _resolve()\n        }\n        reject = _reject\n        resolve = _resolve\n      })\n    } finally {\n      options.signal?.removeEventListener('abort', abort)\n    }\n  }\n\n  /**\n   * handleWindowUpdate is called when the stream receives a window update frame\n   */\n  handleWindowUpdate (header: FrameHeader): void {\n    this.log?.trace('stream received window update id=%s', this._id)\n    this.processFlags(header.flag)\n\n    // increase send window\n    const available = this.sendWindowCapacity\n    this.sendWindowCapacity += header.length\n    // if the update increments a 0 availability, notify the stream that sending can resume\n    if (available === 0 && header.length > 0) {\n      this.sendWindowCapacityUpdate?.()\n    }\n  }\n\n  /**\n   * handleData is called when the stream receives a data frame\n   */\n  async handleData (header: FrameHeader, readData: () => Promise<Uint8ArrayList>): Promise<void> {\n    this.log?.trace('stream received data id=%s', this._id)\n    this.processFlags(header.flag)\n\n    // check that our recv window is not exceeded\n    if (this.recvWindowCapacity < header.length) {\n      throw new ReceiveWindowExceededError('Receive window exceeded')\n    }\n\n    const data = await readData()\n    this.recvWindowCapacity -= header.length\n\n    this.sourcePush(data)\n  }\n\n  /**\n   * processFlags is used to update the state of the stream based on set flags, if any.\n   */\n  private processFlags (flags: number): void {\n    if ((flags & Flag.ACK) === Flag.ACK) {\n      if (this.state === StreamState.SYNSent) {\n        this.state = StreamState.Established\n      }\n    }\n    if ((flags & Flag.FIN) === Flag.FIN) {\n      this.remoteCloseWrite()\n    }\n    if ((flags & Flag.RST) === Flag.RST) {\n      this.reset()\n    }\n  }\n\n  /**\n   * getSendFlags determines any flags that are appropriate\n   * based on the current stream state.\n   *\n   * The state is updated as a side-effect.\n   */\n  private getSendFlags (): number {\n    switch (this.state) {\n      case StreamState.Init:\n        this.state = StreamState.SYNSent\n        return Flag.SYN\n      case StreamState.SYNReceived:\n        this.state = StreamState.Established\n        return Flag.ACK\n      default:\n        return 0\n    }\n  }\n\n  /**\n   * potentially sends a window update enabling further writes to take place.\n   */\n  sendWindowUpdate (): void {\n    // determine the flags if any\n    const flags = this.getSendFlags()\n\n    // If the stream has already been established\n    // and we've processed data within the time it takes for 4 round trips\n    // then we (up to) double the recvWindow\n    const now = Date.now()\n    const rtt = this.getRTT()\n    if (flags === 0 && rtt > -1 && now - this.epochStart < rtt * 4) {\n      // we've already validated that maxStreamWindowSize can't be more than MAX_UINT32\n      this.recvWindow = Math.min(this.recvWindow * 2, this.config.maxStreamWindowSize)\n    }\n\n    if (this.recvWindowCapacity >= this.recvWindow && flags === 0) {\n      // a window update isn't needed\n      return\n    }\n\n    // update the receive window\n    const delta = this.recvWindow - this.recvWindowCapacity\n    this.recvWindowCapacity = this.recvWindow\n\n    // update the epoch start\n    this.epochStart = now\n\n    // send window update\n    this.sendFrame({\n      type: FrameType.WindowUpdate,\n      flag: flags,\n      streamID: this._id,\n      length: delta\n    })\n  }\n}\n", "import { InvalidParametersError, MuxerClosedError, TooManyOutboundProtocolStreamsError, serviceCapabilities, setMaxListeners } from '@libp2p/interface'\nimport { getIterator } from 'get-iterator'\nimport { pushable } from 'it-pushable'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { defaultConfig, verifyConfig } from './config.js'\nimport { PROTOCOL_ERRORS } from './constants.js'\nimport { Decoder } from './decode.js'\nimport { encodeHeader } from './encode.js'\nimport { InvalidFrameError, NotMatchingPingError, UnrequestedPingError } from './errors.js'\nimport { Flag, FrameType, GoAwayCode } from './frame.js'\nimport { StreamState, YamuxStream } from './stream.js'\nimport type { Config } from './config.js'\nimport type { FrameHeader } from './frame.js'\nimport type { YamuxMuxerComponents } from './index.js'\nimport type { AbortOptions, ComponentLogger, Logger, Stream, StreamMuxer, StreamMuxerFactory, StreamMuxerInit } from '@libp2p/interface'\nimport type { Pushable } from 'it-pushable'\nimport type { Sink, Source } from 'it-stream-types'\n\nconst YAMUX_PROTOCOL_ID = '/yamux/1.0.0'\nconst CLOSE_TIMEOUT = 500\n\nexport interface YamuxMuxerInit extends StreamMuxerInit, Partial<Config> {\n}\n\nexport class Yamux implements StreamMuxerFactory {\n  protocol = YAMUX_PROTOCOL_ID\n  private readonly _components: YamuxMuxerComponents\n  private readonly _init: YamuxMuxerInit\n\n  constructor (components: YamuxMuxerComponents, init: YamuxMuxerInit = {}) {\n    this._components = components\n    this._init = init\n  }\n\n  readonly [Symbol.toStringTag] = '@chainsafe/libp2p-yamux'\n\n  readonly [serviceCapabilities]: string[] = [\n    '@libp2p/stream-multiplexing'\n  ]\n\n  createStreamMuxer (init?: YamuxMuxerInit): YamuxMuxer {\n    return new YamuxMuxer(this._components, {\n      ...this._init,\n      ...init\n    })\n  }\n}\n\nexport interface CloseOptions extends AbortOptions {\n  reason?: GoAwayCode\n}\n\nexport class YamuxMuxer implements StreamMuxer {\n  protocol = YAMUX_PROTOCOL_ID\n  source: Pushable<Uint8ArrayList | Uint8Array>\n  sink: Sink<Source<Uint8ArrayList | Uint8Array>, Promise<void>>\n\n  private readonly config: Config\n  private readonly log?: Logger\n  private readonly logger: ComponentLogger\n\n  /** Used to close the muxer from either the sink or source */\n  private readonly closeController: AbortController\n\n  /** The next stream id to be used when initiating a new stream */\n  private nextStreamID: number\n  /** Primary stream mapping, streamID => stream */\n  private readonly _streams: Map<number, YamuxStream>\n\n  /** The next ping id to be used when pinging */\n  private nextPingID: number\n  /** Tracking info for the currently active ping */\n  private activePing?: { id: number, promise: Promise<void>, resolve(): void }\n  /** Round trip time */\n  private rtt: number\n\n  /** True if client, false if server */\n  private readonly client: boolean\n\n  private localGoAway?: GoAwayCode\n  private remoteGoAway?: GoAwayCode\n\n  /** Number of tracked inbound streams */\n  private numInboundStreams: number\n  /** Number of tracked outbound streams */\n  private numOutboundStreams: number\n\n  private readonly onIncomingStream?: (stream: Stream) => void\n  private readonly onStreamEnd?: (stream: Stream) => void\n\n  constructor (components: YamuxMuxerComponents, init: YamuxMuxerInit) {\n    this.client = init.direction === 'outbound'\n    this.config = { ...defaultConfig, ...init }\n    this.logger = components.logger\n    this.log = this.logger.forComponent('libp2p:yamux')\n    verifyConfig(this.config)\n\n    this.closeController = new AbortController()\n    setMaxListeners(Infinity, this.closeController.signal)\n\n    this.onIncomingStream = init.onIncomingStream\n    this.onStreamEnd = init.onStreamEnd\n\n    this._streams = new Map()\n\n    this.source = pushable({\n      onEnd: (): void => {\n        this.log?.trace('muxer source ended')\n\n        this._streams.forEach(stream => {\n          stream.destroy()\n        })\n      }\n    })\n\n    this.sink = async (source: Source<Uint8ArrayList | Uint8Array>): Promise<void> => {\n      const shutDownListener = (): void => {\n        const iterator = getIterator(source)\n\n        if (iterator.return != null) {\n          const res = iterator.return()\n\n          if (isPromise(res)) {\n            res.catch(err => {\n              this.log?.('could not cause sink source to return', err)\n            })\n          }\n        }\n      }\n\n      let reason, error\n      try {\n        const decoder = new Decoder(source)\n\n        try {\n          this.closeController.signal.addEventListener('abort', shutDownListener)\n\n          for await (const frame of decoder.emitFrames()) {\n            await this.handleFrame(frame.header, frame.readData)\n          }\n        } finally {\n          this.closeController.signal.removeEventListener('abort', shutDownListener)\n        }\n\n        reason = GoAwayCode.NormalTermination\n      } catch (err: any) {\n        // either a protocol or internal error\n        if (PROTOCOL_ERRORS.has(err.name)) {\n          this.log?.error('protocol error in sink', err)\n          reason = GoAwayCode.ProtocolError\n        } else {\n          this.log?.error('internal error in sink', err)\n          reason = GoAwayCode.InternalError\n        }\n\n        error = err as Error\n      }\n\n      this.log?.trace('muxer sink ended')\n\n      if (error != null) {\n        this.abort(error, reason)\n      } else {\n        await this.close({ reason })\n      }\n    }\n\n    this.numInboundStreams = 0\n    this.numOutboundStreams = 0\n\n    // client uses odd streamIDs, server uses even streamIDs\n    this.nextStreamID = this.client ? 1 : 2\n\n    this.nextPingID = 0\n    this.rtt = -1\n\n    this.log?.trace('muxer created')\n\n    if (this.config.enableKeepAlive) {\n      this.keepAliveLoop().catch(e => this.log?.error('keepalive error: %s', e))\n    }\n\n    // send an initial ping to establish RTT\n    this.ping().catch(e => this.log?.error('ping error: %s', e))\n  }\n\n  get streams (): YamuxStream[] {\n    return Array.from(this._streams.values())\n  }\n\n  newStream (name?: string | undefined): YamuxStream {\n    if (this.remoteGoAway !== undefined) {\n      throw new MuxerClosedError('Muxer closed remotely')\n    }\n    if (this.localGoAway !== undefined) {\n      throw new MuxerClosedError('Muxer closed locally')\n    }\n\n    const id = this.nextStreamID\n    this.nextStreamID += 2\n\n    // check against our configured maximum number of outbound streams\n    if (this.numOutboundStreams >= this.config.maxOutboundStreams) {\n      throw new TooManyOutboundProtocolStreamsError('max outbound streams exceeded')\n    }\n\n    this.log?.trace('new outgoing stream id=%s', id)\n\n    const stream = this._newStream(id, name, StreamState.Init, 'outbound')\n    this._streams.set(id, stream)\n\n    this.numOutboundStreams++\n\n    // send a window update to open the stream on the receiver end\n    stream.sendWindowUpdate()\n\n    return stream\n  }\n\n  /**\n   * Initiate a ping and wait for a response\n   *\n   * Note: only a single ping will be initiated at a time.\n   * If a ping is already in progress, a new ping will not be initiated.\n   *\n   * @returns the round-trip-time in milliseconds\n   */\n  async ping (): Promise<number> {\n    if (this.remoteGoAway !== undefined) {\n      throw new MuxerClosedError('Muxer closed remotely')\n    }\n    if (this.localGoAway !== undefined) {\n      throw new MuxerClosedError('Muxer closed locally')\n    }\n\n    // An active ping does not yet exist, handle the process here\n    if (this.activePing === undefined) {\n      // create active ping\n      let _resolve = (): void => {}\n      this.activePing = {\n        id: this.nextPingID++,\n        // this promise awaits resolution or the close controller aborting\n        promise: new Promise<void>((resolve, reject) => {\n          const closed = (): void => {\n            reject(new MuxerClosedError('Muxer closed locally'))\n          }\n          this.closeController.signal.addEventListener('abort', closed, { once: true })\n          _resolve = (): void => {\n            this.closeController.signal.removeEventListener('abort', closed)\n            resolve()\n          }\n        }),\n        resolve: _resolve\n      }\n      // send ping\n      const start = Date.now()\n      this.sendPing(this.activePing.id)\n      // await pong\n      try {\n        await this.activePing.promise\n      } finally {\n        // clean-up active ping\n        delete this.activePing\n      }\n      // update rtt\n      const end = Date.now()\n      this.rtt = end - start\n    } else {\n      // an active ping is already in progress, piggyback off that\n      await this.activePing.promise\n    }\n    return this.rtt\n  }\n\n  /**\n   * Get the ping round trip time\n   *\n   * Note: Will return 0 if no successful ping has yet been completed\n   *\n   * @returns the round-trip-time in milliseconds\n   */\n  getRTT (): number {\n    return this.rtt\n  }\n\n  /**\n   * Close the muxer\n   */\n  async close (options: CloseOptions = {}): Promise<void> {\n    if (this.closeController.signal.aborted) {\n      // already closed\n      return\n    }\n\n    const reason = options?.reason ?? GoAwayCode.NormalTermination\n\n    this.log?.trace('muxer close reason=%s', reason)\n\n    if (options.signal == null) {\n      const signal = AbortSignal.timeout(CLOSE_TIMEOUT)\n      setMaxListeners(Infinity, signal)\n\n      options = {\n        ...options,\n        signal\n      }\n    }\n\n    try {\n      await Promise.all(\n        [...this._streams.values()].map(async s => s.close(options))\n      )\n\n      // send reason to the other side, allow the other side to close gracefully\n      this.sendGoAway(reason)\n\n      this._closeMuxer()\n    } catch (err: any) {\n      this.abort(err)\n    }\n  }\n\n  abort (err: Error, reason?: GoAwayCode): void {\n    if (this.closeController.signal.aborted) {\n      // already closed\n      return\n    }\n\n    reason = reason ?? GoAwayCode.InternalError\n\n    // If reason was provided, use that, otherwise use the presence of `err` to determine the reason\n    this.log?.error('muxer abort reason=%s error=%s', reason, err)\n\n    // Abort all underlying streams\n    for (const stream of this._streams.values()) {\n      stream.abort(err)\n    }\n\n    // send reason to the other side, allow the other side to close gracefully\n    this.sendGoAway(reason)\n\n    this._closeMuxer()\n  }\n\n  isClosed (): boolean {\n    return this.closeController.signal.aborted\n  }\n\n  /**\n   * Called when either the local or remote shuts down the muxer\n   */\n  private _closeMuxer (): void {\n    // stop the sink and any other processes\n    this.closeController.abort()\n\n    // stop the source\n    this.source.end()\n  }\n\n  /** Create a new stream */\n  private _newStream (id: number, name: string | undefined, state: StreamState, direction: 'inbound' | 'outbound'): YamuxStream {\n    if (this._streams.get(id) != null) {\n      throw new InvalidParametersError('Stream already exists with that id')\n    }\n\n    const stream = new YamuxStream({\n      id: id.toString(),\n      name,\n      state,\n      direction,\n      sendFrame: this.sendFrame.bind(this),\n      onEnd: () => {\n        this.closeStream(id)\n        this.onStreamEnd?.(stream)\n      },\n      log: this.logger.forComponent(`libp2p:yamux:${direction}:${id}`),\n      config: this.config,\n      getRTT: this.getRTT.bind(this)\n    })\n\n    return stream\n  }\n\n  /**\n   * closeStream is used to close a stream once both sides have\n   * issued a close.\n   */\n  private closeStream (id: number): void {\n    if (this.client === (id % 2 === 0)) {\n      this.numInboundStreams--\n    } else {\n      this.numOutboundStreams--\n    }\n    this._streams.delete(id)\n  }\n\n  private async keepAliveLoop (): Promise<void> {\n    const abortPromise = new Promise((_resolve, reject) => { this.closeController.signal.addEventListener('abort', reject, { once: true }) })\n    this.log?.trace('muxer keepalive enabled interval=%s', this.config.keepAliveInterval)\n    while (true) {\n      let timeoutId\n      try {\n        await Promise.race([\n          abortPromise,\n          new Promise((resolve) => {\n            timeoutId = setTimeout(resolve, this.config.keepAliveInterval)\n          })\n        ])\n        this.ping().catch(e => this.log?.error('ping error: %s', e))\n      } catch (e) {\n        // closed\n        clearInterval(timeoutId)\n        return\n      }\n    }\n  }\n\n  private async handleFrame (header: FrameHeader, readData?: () => Promise<Uint8ArrayList>): Promise<void> {\n    const {\n      streamID,\n      type,\n      length\n    } = header\n    this.log?.trace('received frame %o', header)\n\n    if (streamID === 0) {\n      switch (type) {\n        case FrameType.Ping:\n        { this.handlePing(header); return }\n        case FrameType.GoAway:\n        { this.handleGoAway(length); return }\n        default:\n          // Invalid state\n          throw new InvalidFrameError('Invalid frame type')\n      }\n    } else {\n      switch (header.type) {\n        case FrameType.Data:\n        case FrameType.WindowUpdate:\n        { await this.handleStreamMessage(header, readData); return }\n        default:\n          // Invalid state\n          throw new InvalidFrameError('Invalid frame type')\n      }\n    }\n  }\n\n  private handlePing (header: FrameHeader): void {\n    // If the ping  is initiated by the sender, send a response\n    if (header.flag === Flag.SYN) {\n      this.log?.trace('received ping request pingId=%s', header.length)\n      this.sendPing(header.length, Flag.ACK)\n    } else if (header.flag === Flag.ACK) {\n      this.log?.trace('received ping response pingId=%s', header.length)\n      this.handlePingResponse(header.length)\n    } else {\n      // Invalid state\n      throw new InvalidFrameError('Invalid frame flag')\n    }\n  }\n\n  private handlePingResponse (pingId: number): void {\n    if (this.activePing === undefined) {\n      // this ping was not requested\n      throw new UnrequestedPingError('ping not requested')\n    }\n    if (this.activePing.id !== pingId) {\n      // this ping doesn't match our active ping request\n      throw new NotMatchingPingError('ping doesn\\'t match our id')\n    }\n\n    // valid ping response\n    this.activePing.resolve()\n  }\n\n  private handleGoAway (reason: GoAwayCode): void {\n    this.log?.trace('received GoAway reason=%s', GoAwayCode[reason] ?? 'unknown')\n    this.remoteGoAway = reason\n\n    // If the other side is friendly, they would have already closed all streams before sending a GoAway\n    // In case they weren't, reset all streams\n    for (const stream of this._streams.values()) {\n      stream.reset()\n    }\n\n    this._closeMuxer()\n  }\n\n  private async handleStreamMessage (header: FrameHeader, readData?: () => Promise<Uint8ArrayList>): Promise<void> {\n    const { streamID, flag, type } = header\n\n    if ((flag & Flag.SYN) === Flag.SYN) {\n      this.incomingStream(streamID)\n    }\n\n    const stream = this._streams.get(streamID)\n    if (stream === undefined) {\n      if (type === FrameType.Data) {\n        this.log?.('discarding data for stream id=%s', streamID)\n        if (readData === undefined) {\n          throw new Error('unreachable')\n        }\n        await readData()\n      } else {\n        this.log?.trace('frame for missing stream id=%s', streamID)\n      }\n      return\n    }\n\n    switch (type) {\n      case FrameType.WindowUpdate: {\n        stream.handleWindowUpdate(header); return\n      }\n      case FrameType.Data: {\n        if (readData === undefined) {\n          throw new Error('unreachable')\n        }\n\n        await stream.handleData(header, readData); return\n      }\n      default:\n        throw new Error('unreachable')\n    }\n  }\n\n  private incomingStream (id: number): void {\n    if (this.client !== (id % 2 === 0)) {\n      throw new InvalidParametersError('Both endpoints are clients')\n    }\n    if (this._streams.has(id)) {\n      return\n    }\n\n    this.log?.trace('new incoming stream id=%s', id)\n\n    if (this.localGoAway !== undefined) {\n      // reject (reset) immediately if we are doing a go away\n      this.sendFrame({\n        type: FrameType.WindowUpdate,\n        flag: Flag.RST,\n        streamID: id,\n        length: 0\n      }); return\n    }\n\n    // check against our configured maximum number of inbound streams\n    if (this.numInboundStreams >= this.config.maxInboundStreams) {\n      this.log?.('maxIncomingStreams exceeded, forcing stream reset')\n      this.sendFrame({\n        type: FrameType.WindowUpdate,\n        flag: Flag.RST,\n        streamID: id,\n        length: 0\n      }); return\n    }\n\n    // allocate a new stream\n    const stream = this._newStream(id, undefined, StreamState.SYNReceived, 'inbound')\n\n    this.numInboundStreams++\n    // the stream should now be tracked\n    this._streams.set(id, stream)\n\n    this.onIncomingStream?.(stream)\n  }\n\n  private sendFrame (header: FrameHeader, data?: Uint8ArrayList): void {\n    this.log?.trace('sending frame %o', header)\n    if (header.type === FrameType.Data) {\n      if (data === undefined) {\n        throw new InvalidFrameError('Invalid frame')\n      }\n      this.source.push(\n        new Uint8ArrayList(encodeHeader(header), data)\n      )\n    } else {\n      this.source.push(encodeHeader(header))\n    }\n  }\n\n  private sendPing (pingId: number, flag: Flag = Flag.SYN): void {\n    if (flag === Flag.SYN) {\n      this.log?.trace('sending ping request pingId=%s', pingId)\n    } else {\n      this.log?.trace('sending ping response pingId=%s', pingId)\n    }\n    this.sendFrame({\n      type: FrameType.Ping,\n      flag,\n      streamID: 0,\n      length: pingId\n    })\n  }\n\n  private sendGoAway (reason: GoAwayCode = GoAwayCode.NormalTermination): void {\n    this.log?.('sending GoAway reason=%s', GoAwayCode[reason])\n    this.localGoAway = reason\n    this.sendFrame({\n      type: FrameType.GoAway,\n      flag: 0,\n      streamID: 0,\n      length: reason\n    })\n  }\n}\n\nfunction isPromise <T = unknown> (thing: any): thing is Promise<T> {\n  return thing != null && typeof thing.then === 'function'\n}\n"],
-  "mappings": "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",
-  "names": ["index_exports", "__export", "GoAwayCode", "yamux", "AbortError", "message", "InvalidParametersError", "message", "MuxerClosedError", "message", "StreamResetError", "StreamStateError", "TooManyOutboundProtocolStreamsError", "message", "serviceCapabilities", "serviceDependencies", "getIterator", "obj", "pDefer", "deferred", "resolve", "reject", "FixedFIFO", "hwm", "data", "last", "FIFO", "options", "obj", "val", "prev", "next", "AbortError", "message", "code", "pushable", "options", "_pushable", "buffer", "next", "_pushable", "getNext", "options", "onEnd", "buffer", "FIFO", "pushable", "onNext", "ended", "drain", "pDefer", "waitNext", "resolve", "reject", "next", "err", "bufferNext", "bufferError", "push", "value", "end", "_return", "_throw", "signal", "cancel", "listener", "AbortError", "opts", "alloc", "size", "allocUnsafe", "concat", "arrays", "length", "acc", "curr", "output", "allocUnsafe", "offset", "arr", "equals", "a", "b", "i", "symbol", "findBufAndOffset", "bufs", "index", "offset", "buf", "bufEnd", "isUint8ArrayList", "value", "Uint8ArrayList", "_Uint8ArrayList", "data", "length", "res", "i", "bytes", "beginInclusive", "endExclusive", "concat", "list", "bufStart", "sliceStartInBuf", "sliceEndsInBuf", "start", "search", "needle", "M", "radix", "rightmostPositions", "c", "j", "right", "lastIndex", "lastPatIndex", "skip", "char", "byteOffset", "allocUnsafe", "littleEndian", "alloc", "other", "equals", "acc", "curr", "InvalidFrameError", "message", "UnrequestedPingError", "NotMatchingPingError", "InvalidStateError", "StreamAlreadyExistsError", "DecodeInvalidVersionError", "BothClientsError", "ReceiveWindowExceededError", "PROTOCOL_ERRORS", "InvalidFrameError", "UnrequestedPingError", "NotMatchingPingError", "StreamAlreadyExistsError", "DecodeInvalidVersionError", "BothClientsError", "ReceiveWindowExceededError", "INITIAL_STREAM_WINDOW", "MAX_STREAM_WINDOW", "defaultConfig", "INITIAL_STREAM_WINDOW", "MAX_STREAM_WINDOW", "verifyConfig", "config", "InvalidParametersError", "FrameType", "Flag", "flagCodes", "x", "YAMUX_VERSION", "GoAwayCode", "HEADER_LENGTH", "twoPow24", "decodeHeader", "data", "YAMUX_VERSION", "InvalidFrameError", "Decoder", "source", "returnlessSource", "Uint8ArrayList", "chunk", "header", "type", "length", "FrameType", "InvalidStateError", "HEADER_LENGTH", "out", "iterator", "encodeHeader", "header", "frame", "HEADER_LENGTH", "AbortError", "message", "code", "name", "raceSignal", "promise", "signal", "opts", "listener", "error", "resolve", "reject", "isPromise", "thing", "closeSource", "source", "log", "res", "getIterator", "isPromise", "err", "DEFAULT_SEND_CLOSE_WRITE_TIMEOUT", "isPromise", "thing", "AbstractStream", "init", "pDefer", "pushable", "err", "source", "StreamStateError", "options", "res", "abortListener", "closeSource", "data", "Uint8ArrayList", "raceSignal", "readStatus", "StreamResetError", "peekable", "iterable", "iterator", "symbol", "queue", "value", "src_default", "isAsyncIterable", "thing", "isPromise", "forEach", "source", "fn", "index", "val", "res", "peekable", "src_default", "value", "done", "func", "StreamState", "YamuxStream", "AbstractStream", "init", "err", "INITIAL_STREAM_WINDOW", "src_default", "buf", "options", "toSend", "HEADER_LENGTH", "flags", "FrameType", "Flag", "resolve", "reject", "abort", "AbortError", "_resolve", "_reject", "header", "available", "readData", "ReceiveWindowExceededError", "data", "now", "rtt", "delta", "YAMUX_PROTOCOL_ID", "CLOSE_TIMEOUT", "Yamux", "components", "init", "serviceCapabilities", "YamuxMuxer", "defaultConfig", "verifyConfig", "pushable", "stream", "source", "shutDownListener", "iterator", "getIterator", "res", "isPromise", "err", "reason", "error", "decoder", "Decoder", "frame", "GoAwayCode", "PROTOCOL_ERRORS", "e", "name", "MuxerClosedError", "id", "TooManyOutboundProtocolStreamsError", "StreamState", "_resolve", "resolve", "reject", "closed", "start", "end", "options", "signal", "s", "state", "direction", "InvalidParametersError", "YamuxStream", "abortPromise", "timeoutId", "header", "readData", "streamID", "type", "length", "FrameType", "InvalidFrameError", "Flag", "pingId", "UnrequestedPingError", "NotMatchingPingError", "flag", "data", "Uint8ArrayList", "encodeHeader", "thing", "yamux", "init", "components", "Yamux"]
+  "sources": ["../src/index.ts", "../node_modules/@libp2p/interface/src/errors.ts", "../node_modules/@libp2p/interface/src/index.ts", "../node_modules/get-iterator/src/index.ts", "../node_modules/p-defer/index.js", "../node_modules/it-pushable/src/fifo.ts", "../node_modules/it-pushable/src/index.ts", "../node_modules/race-signal/src/index.ts", "../node_modules/uint8arrays/src/alloc.ts", "../node_modules/uint8arrays/src/concat.ts", "../node_modules/uint8arrays/src/equals.ts", "../node_modules/uint8arraylist/src/index.ts", "../src/errors.ts", "../src/constants.ts", "../src/config.ts", "../src/frame.ts", "../src/decode.ts", "../src/encode.ts", "../node_modules/@libp2p/utils/src/is-promise.ts", "../node_modules/@libp2p/utils/src/close-source.ts", "../node_modules/@libp2p/utils/src/abstract-stream.ts", "../node_modules/it-peekable/src/index.ts", "../node_modules/it-foreach/src/index.ts", "../src/stream.ts", "../src/muxer.ts"],
+  "sourcesContent": ["/**\n * @packageDocumentation\n *\n * This module is a JavaScript implementation of [Yamux from Hashicorp](https://github.com/hashicorp/yamux/blob/master/spec.md) designed to be used with [js-libp2p](https://github.com/libp2p/js-libp2p).\n *\n * @example Configure libp2p with Yamux\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n * import { yamux } from '@chainsafe/libp2p-yamux'\n *\n * const node = await createLibp2p({\n *   // ... other options\n *   streamMuxers: [\n *     yamux()\n *   ]\n * })\n * ```\n *\n * @example Using the low-level API\n *\n * ```js\n * import { yamux } from '@chainsafe/libp2p-yamux'\n * import { pipe } from 'it-pipe'\n * import { duplexPair } from 'it-pair/duplex'\n * import all from 'it-all'\n *\n * // Connect two yamux muxers to demo basic stream multiplexing functionality\n *\n * const clientMuxer = yamux({\n *   client: true,\n *   onIncomingStream: stream => {\n *     // echo data on incoming streams\n *     pipe(stream, stream)\n *   },\n *   onStreamEnd: stream => {\n *     // do nothing\n *   }\n * })()\n *\n * const serverMuxer = yamux({\n *   client: false,\n *   onIncomingStream: stream => {\n *     // echo data on incoming streams\n *     pipe(stream, stream)\n *   },\n *   onStreamEnd: stream => {\n *     // do nothing\n *   }\n * })()\n *\n * // `p` is our \"connections\", what we use to connect the two sides\n * // In a real application, a connection is usually to a remote computer\n * const p = duplexPair()\n *\n * // connect the muxers together\n * pipe(p[0], clientMuxer, p[0])\n * pipe(p[1], serverMuxer, p[1])\n *\n * // now either side can open streams\n * const stream0 = clientMuxer.newStream()\n * const stream1 = serverMuxer.newStream()\n *\n * // Send some data to the other side\n * const encoder = new TextEncoder()\n * const data = [encoder.encode('hello'), encoder.encode('world')]\n * pipe(data, stream0)\n *\n * // Receive data back\n * const result = await pipe(stream0, all)\n *\n * // close a stream\n * stream1.close()\n *\n * // close the muxer\n * clientMuxer.close()\n * ```\n */\n\nimport { Yamux } from './muxer.js'\nimport type { YamuxMuxerInit } from './muxer.js'\nimport type { ComponentLogger, StreamMuxerFactory } from '@libp2p/interface'\n\nexport { GoAwayCode, type FrameHeader, type FrameType } from './frame.js'\nexport type { YamuxMuxerInit }\n\nexport interface YamuxMuxerComponents {\n  logger: ComponentLogger\n}\n\nexport function yamux (init: YamuxMuxerInit = {}): (components: YamuxMuxerComponents) => StreamMuxerFactory {\n  return (components) => new Yamux(components, init)\n}\n", "/**\n * When this error is thrown it means an operation was aborted,\n * usually in response to the `abort` event being emitted by an\n * AbortSignal.\n */\nexport class AbortError extends Error {\n  static name = 'AbortError'\n\n  constructor (message: string = 'The operation was aborted') {\n    super(message)\n    this.name = 'AbortError'\n  }\n}\n\n/**\n * Thrown when a remote Peer ID does not match the expected one\n */\nexport class UnexpectedPeerError extends Error {\n  static name = 'UnexpectedPeerError'\n\n  constructor (message = 'Unexpected Peer') {\n    super(message)\n    this.name = 'UnexpectedPeerError'\n  }\n}\n\n/**\n * Thrown when a crypto exchange fails\n */\nexport class InvalidCryptoExchangeError extends Error {\n  static name = 'InvalidCryptoExchangeError'\n\n  constructor (message = 'Invalid crypto exchange') {\n    super(message)\n    this.name = 'InvalidCryptoExchangeError'\n  }\n}\n\n/**\n * Thrown when invalid parameters are passed to a function or method call\n */\nexport class InvalidParametersError extends Error {\n  static name = 'InvalidParametersError'\n\n  constructor (message = 'Invalid parameters') {\n    super(message)\n    this.name = 'InvalidParametersError'\n  }\n}\n\n/**\n * Thrown when a public key is invalid\n */\nexport class InvalidPublicKeyError extends Error {\n  static name = 'InvalidPublicKeyError'\n\n  constructor (message = 'Invalid public key') {\n    super(message)\n    this.name = 'InvalidPublicKeyError'\n  }\n}\n\n/**\n * Thrown when a private key is invalid\n */\nexport class InvalidPrivateKeyError extends Error {\n  static name = 'InvalidPrivateKeyError'\n\n  constructor (message = 'Invalid private key') {\n    super(message)\n    this.name = 'InvalidPrivateKeyError'\n  }\n}\n\n/**\n * Thrown when a operation is unsupported\n */\nexport class UnsupportedOperationError extends Error {\n  static name = 'UnsupportedOperationError'\n\n  constructor (message = 'Unsupported operation') {\n    super(message)\n    this.name = 'UnsupportedOperationError'\n  }\n}\n\n/**\n * Thrown when a connection is closing\n */\nexport class ConnectionClosingError extends Error {\n  static name = 'ConnectionClosingError'\n\n  constructor (message = 'The connection is closing') {\n    super(message)\n    this.name = 'ConnectionClosingError'\n  }\n}\n\n/**\n * Thrown when a connection is closed\n */\nexport class ConnectionClosedError extends Error {\n  static name = 'ConnectionClosedError'\n\n  constructor (message = 'The connection is closed') {\n    super(message)\n    this.name = 'ConnectionClosedError'\n  }\n}\n\n/**\n * Thrown when a connection fails\n */\nexport class ConnectionFailedError extends Error {\n  static name = 'ConnectionFailedError'\n\n  constructor (message = 'Connection failed') {\n    super(message)\n    this.name = 'ConnectionFailedError'\n  }\n}\n\n/**\n * Thrown when the muxer is closed and an attempt to open a stream occurs\n */\nexport class MuxerClosedError extends Error {\n  static name = 'MuxerClosedError'\n\n  constructor (message = 'The muxer is closed') {\n    super(message)\n    this.name = 'MuxerClosedError'\n  }\n}\n\n/**\n * Thrown when a protocol stream is reset by the remote muxer\n */\nexport class StreamResetError extends Error {\n  static name = 'StreamResetError'\n\n  constructor (message = 'The stream has been reset') {\n    super(message)\n    this.name = 'StreamResetError'\n  }\n}\n\n/**\n * Thrown when a stream is in an invalid state\n */\nexport class StreamStateError extends Error {\n  static name = 'StreamStateError'\n\n  constructor (message = 'The stream is in an invalid state') {\n    super(message)\n    this.name = 'StreamStateError'\n  }\n}\n\n/**\n * Thrown when a value could not be found\n */\nexport class NotFoundError extends Error {\n  static name = 'NotFoundError'\n\n  constructor (message = 'Not found') {\n    super(message)\n    this.name = 'NotFoundError'\n  }\n}\n\n/**\n * Thrown when an invalid peer ID is encountered\n */\nexport class InvalidPeerIdError extends Error {\n  static name = 'InvalidPeerIdError'\n\n  constructor (message = 'Invalid PeerID') {\n    super(message)\n    this.name = 'InvalidPeerIdError'\n  }\n}\n\n/**\n * Thrown when an invalid multiaddr is encountered\n */\nexport class InvalidMultiaddrError extends Error {\n  static name = 'InvalidMultiaddrError'\n\n  constructor (message = 'Invalid multiaddr') {\n    super(message)\n    this.name = 'InvalidMultiaddrError'\n  }\n}\n\n/**\n * Thrown when an invalid CID is encountered\n */\nexport class InvalidCIDError extends Error {\n  static name = 'InvalidCIDError'\n\n  constructor (message = 'Invalid CID') {\n    super(message)\n    this.name = 'InvalidCIDError'\n  }\n}\n\n/**\n * Thrown when an invalid multihash is encountered\n */\nexport class InvalidMultihashError extends Error {\n  static name = 'InvalidMultihashError'\n\n  constructor (message = 'Invalid Multihash') {\n    super(message)\n    this.name = 'InvalidMultihashError'\n  }\n}\n\n/**\n * Thrown when a protocol is not supported\n */\nexport class UnsupportedProtocolError extends Error {\n  static name = 'UnsupportedProtocolError'\n\n  constructor (message = 'Unsupported protocol error') {\n    super(message)\n    this.name = 'UnsupportedProtocolError'\n  }\n}\n\n/**\n * An invalid or malformed message was encountered during a protocol exchange\n */\nexport class InvalidMessageError extends Error {\n  static name = 'InvalidMessageError'\n\n  constructor (message = 'Invalid message') {\n    super(message)\n    this.name = 'InvalidMessageError'\n  }\n}\n\n/**\n * Thrown when a remote peer sends a structurally valid message that does not\n * comply with the protocol\n */\nexport class ProtocolError extends Error {\n  static name = 'ProtocolError'\n\n  constructor (message = 'Protocol error') {\n    super(message)\n    this.name = 'ProtocolError'\n  }\n}\n\n/**\n * Throw when an operation times out\n */\nexport class TimeoutError extends Error {\n  static name = 'TimeoutError'\n\n  constructor (message = 'Timed out') {\n    super(message)\n    this.name = 'TimeoutError'\n  }\n}\n\n/**\n * Thrown when a startable component is interacted with but it has not been\n * started yet\n */\nexport class NotStartedError extends Error {\n  static name = 'NotStartedError'\n\n  constructor (message = 'Not started') {\n    super(message)\n    this.name = 'NotStartedError'\n  }\n}\n\n/**\n * Thrown when a component is started that has already been started\n */\nexport class AlreadyStartedError extends Error {\n  static name = 'AlreadyStartedError'\n\n  constructor (message = 'Already started') {\n    super(message)\n    this.name = 'AlreadyStartedError'\n  }\n}\n\n/**\n * Thrown when dialing an address failed\n */\nexport class DialError extends Error {\n  static name = 'DialError'\n\n  constructor (message = 'Dial error') {\n    super(message)\n    this.name = 'DialError'\n  }\n}\n\n/**\n * Thrown when listening on an address failed\n */\nexport class ListenError extends Error {\n  static name = 'ListenError'\n\n  constructor (message = 'Listen error') {\n    super(message)\n    this.name = 'ListenError'\n  }\n}\n\n/**\n * This error is thrown when a limited connection is encountered, i.e. if the\n * user tried to open a stream on a connection for a protocol that is not\n * configured to run over limited connections.\n */\nexport class LimitedConnectionError extends Error {\n  static name = 'LimitedConnectionError'\n\n  constructor (message = 'Limited connection') {\n    super(message)\n    this.name = 'LimitedConnectionError'\n  }\n}\n\n/**\n * This error is thrown where there are too many inbound protocols streams open\n */\nexport class TooManyInboundProtocolStreamsError extends Error {\n  static name = 'TooManyInboundProtocolStreamsError'\n\n  constructor (message = 'Too many inbound protocol streams') {\n    super(message)\n    this.name = 'TooManyInboundProtocolStreamsError'\n  }\n}\n\n/**\n * This error is thrown where there are too many outbound protocols streams open\n */\nexport class TooManyOutboundProtocolStreamsError extends Error {\n  static name = 'TooManyOutboundProtocolStreamsError'\n\n  constructor (message = 'Too many outbound protocol streams') {\n    super(message)\n    this.name = 'TooManyOutboundProtocolStreamsError'\n  }\n}\n\n/**\n * Thrown when an attempt to operate on an unsupported key was made\n */\nexport class UnsupportedKeyTypeError extends Error {\n  static name = 'UnsupportedKeyTypeError'\n\n  constructor (message = 'Unsupported key type') {\n    super(message)\n    this.name = 'UnsupportedKeyTypeError'\n  }\n}\n\n/**\n * Thrown when an operation has not been implemented\n */\nexport class NotImplementedError extends Error {\n  static name = 'NotImplementedError'\n\n  constructor (message = 'Not implemented') {\n    super(message)\n    this.name = 'NotImplementedError'\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Exports a `Libp2p` type for modules to use as a type argument.\n *\n * @example\n *\n * ```typescript\n * import type { Libp2p } from '@libp2p/interface'\n *\n * function doSomethingWithLibp2p (node: Libp2p) {\n *   // ...\n * }\n * ```\n */\n\nimport type { Connection, NewStreamOptions, Stream } from './connection.js'\nimport type { ContentRouting } from './content-routing.js'\nimport type { Ed25519PublicKey, PublicKey, RSAPublicKey, Secp256k1PublicKey } from './keys.js'\nimport type { Metrics } from './metrics.js'\nimport type { Ed25519PeerId, PeerId, RSAPeerId, Secp256k1PeerId, URLPeerId } from './peer-id.js'\nimport type { PeerInfo } from './peer-info.js'\nimport type { PeerRouting } from './peer-routing.js'\nimport type { Address, Peer, PeerStore } from './peer-store.js'\nimport type { Startable } from './startable.js'\nimport type { StreamHandler, StreamHandlerOptions } from './stream-handler.js'\nimport type { Topology } from './topology.js'\nimport type { Listener, OutboundConnectionUpgradeEvents } from './transport.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { TypedEventTarget } from 'main-event'\nimport type { ProgressOptions, ProgressEvent } from 'progress-events'\n\n/**\n * Used by the connection manager to sort addresses into order before dialling\n */\nexport interface AddressSorter {\n  (a: Address, b: Address): -1 | 0 | 1\n}\n\n/**\n * Event detail emitted when peer data changes\n */\nexport interface PeerUpdate {\n  peer: Peer\n  previous?: Peer\n}\n\n/**\n * Peer data signed by the remote Peer's public key\n */\nexport interface SignedPeerRecord {\n  addresses: Multiaddr[]\n  seq: bigint\n}\n\n/**\n * A certificate that can be used to secure connections\n */\nexport interface TLSCertificate {\n  /**\n   * The private key that corresponds to the certificate in PEM format\n   */\n  key: string\n\n  /**\n   * The certificate chain in PEM format\n   */\n  cert: string\n}\n\n/**\n * Data returned from a successful identify response\n */\nexport interface IdentifyResult {\n  /**\n   * The remote Peer's PeerId\n   */\n  peerId: PeerId\n\n  /**\n   * The unsigned addresses they are listening on. Note - any multiaddrs present\n   * in the signed peer record should be preferred to the value here.\n   */\n  listenAddrs: Multiaddr[]\n\n  /**\n   * The protocols the remote peer supports\n   */\n  protocols: string[]\n\n  /**\n   * The remote protocol version\n   */\n  protocolVersion?: string\n\n  /**\n   * The remote agent version\n   */\n  agentVersion?: string\n\n  /**\n   * The public key part of the remote PeerId - this is only useful for older\n   * RSA-based PeerIds, the more modern Ed25519 and secp256k1 types have the\n   * public key embedded in them\n   */\n  publicKey?: Uint8Array\n\n  /**\n   * If set this is the address that the remote peer saw the identify request\n   * originate from\n   */\n  observedAddr?: Multiaddr\n\n  /**\n   * If sent by the remote peer this is the deserialized signed peer record\n   */\n  signedPeerRecord?: SignedPeerRecord\n\n  /**\n   * The connection that the identify protocol ran over\n   */\n  connection: Connection\n}\n\n/**\n * Logger component for libp2p\n */\nexport interface Logger {\n  (formatter: any, ...args: any[]): void\n  error(formatter: any, ...args: any[]): void\n  trace(formatter: any, ...args: any[]): void\n  enabled: boolean\n}\n\n/**\n * Peer logger component for libp2p. This can be used to create loggers that are\n * scoped to individual system components or services.\n *\n * To see logs, run your app with `DEBUG` set as an env var or for browsers, in\n * `localStorage`:\n *\n * ```console\n * $ DEBUG=libp2p* node index.js\n *  libp2p:my-service hello +0ms\n * ```\n */\nexport interface ComponentLogger {\n  /**\n   * Returns a logger for the specified component.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * import { ComponentLogger, Logger } from '@libp2p/interface'\n   *\n   * interface MyServiceComponents {\n   *   logger: ComponentLogger\n   * }\n   *\n   * class MyService {\n   *   private readonly log: Logger\n   *\n   *   constructor (components) {\n   *     this.log = components.logger.forComponent('libp2p:my-service')\n   *\n   *     this.log('hello')\n   *     // logs:\n   *     // libp2p:my-service hello +0ms\n   *   }\n   * }\n   * ```\n   */\n  forComponent(name: string): Logger\n}\n\n/**\n * Once you have a libp2p instance, you can listen to several events it emits,\n * so that you can be notified of relevant network events.\n *\n * Event names are `noun:verb` so the first part is the name of the object\n * being acted on and the second is the action.\n */\nexport interface Libp2pEvents<T extends ServiceMap = ServiceMap> {\n  /**\n   * This event is dispatched when a new network peer is discovered.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:discovery', (event) => {\n   *    const peerInfo = event.detail\n   *    // ...\n   * })\n   * ```\n   */\n  'peer:discovery': CustomEvent<PeerInfo>\n\n  /**\n   * This event will be triggered any time a new peer connects.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:connect', (event) => {\n   *   const peerId = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:connect': CustomEvent<PeerId>\n\n  /**\n   * This event will be triggered any time we are disconnected from another\n   * peer, regardless of the circumstances of that disconnection. If we happen\n   * to have multiple connections to a peer, this event will **only** be\n   * triggered when the last connection is closed.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:disconnect', (event) => {\n   *   const peerId = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:disconnect': CustomEvent<PeerId>\n\n  /**\n   * When a peer tagged with `keep-alive` disconnects, we will make multiple\n   * attempts to reconnect to it with a backoff factor (see the connection\n   * manager settings for details). If these all fail, the `keep-alive` tag will\n   * be removed and this event will be emitted.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:reconnect-failure', (event) => {\n   *   const peerId = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:reconnect-failure': CustomEvent<PeerId>\n\n  /**\n   * This event is dispatched after a remote peer has successfully responded to\n   * the identify protocol. Note that for this to be emitted, both peers must\n   * have an identify service configured.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:identify', (event) => {\n   *   const identifyResult = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:identify': CustomEvent<IdentifyResult>\n\n  /**\n   * This event is dispatched when the peer store data for a peer has been\n   * updated - e.g. their multiaddrs, protocols etc have changed.\n   *\n   * If they were previously known to this node, the old peer data will be\n   * set in the `previous` field.\n   *\n   * This may be in response to the identify protocol running, a manual\n   * update or some other event.\n   */\n  'peer:update': CustomEvent<PeerUpdate>\n\n  /**\n   * This event is dispatched when the current node's peer record changes -\n   * for example a transport started listening on a new address or a new\n   * protocol handler was registered.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('self:peer:update', (event) => {\n   *   const { peer } = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'self:peer:update': CustomEvent<PeerUpdate>\n\n  /**\n   * This event is dispatched when a transport begins listening on a new address\n   */\n  'transport:listening': CustomEvent<Listener>\n\n  /**\n   * This event is dispatched when a transport stops listening on an address\n   */\n  'transport:close': CustomEvent<Listener>\n\n  /**\n   * This event is dispatched when the connection manager has more than the\n   * configured allowable max connections and has closed some connections to\n   * bring the node back under the limit.\n   */\n  'connection:prune': CustomEvent<Connection[]>\n\n  /**\n   * This event notifies listeners when new incoming or outgoing connections\n   * are opened.\n   */\n  'connection:open': CustomEvent<Connection>\n\n  /**\n   * This event notifies listeners when incoming or outgoing connections are\n   * closed.\n   */\n  'connection:close': CustomEvent<Connection>\n\n  /**\n   * This event notifies listeners that a TLS certificate is available for use\n   */\n  'certificate:provision': CustomEvent<TLSCertificate>\n\n  /**\n   * This event notifies listeners that a new TLS certificate is available for\n   * use. Any previous certificate may no longer be valid.\n   */\n  'certificate:renew': CustomEvent<TLSCertificate>\n\n  /**\n   * This event notifies listeners that the node has started\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('start', (event) => {\n   *   console.info(libp2p.isStarted()) // true\n   * })\n   * ```\n   */\n  start: CustomEvent<Libp2p<T>>\n\n  /**\n   * This event notifies listeners that the node has stopped\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('stop', (event) => {\n   *   console.info(libp2p.isStarted()) // false\n   * })\n   * ```\n   */\n  stop: CustomEvent<Libp2p<T>>\n}\n\n/**\n * A map of user defined services available on the libp2p node via the\n * `services` key\n *\n * @example\n *\n * ```TypeScript\n * const node = await createLibp2p({\n *   // ...other options\n *   services: {\n *     myService: myService({\n *       // ...service options\n *     })\n *   }\n * })\n *\n * // invoke methods on the service\n * node.services.myService.anOperation()\n * ```\n */\nexport type ServiceMap = Record<string, unknown>\n\nexport type PendingDialStatus = 'queued' | 'active' | 'error' | 'success'\n\n/**\n * An item in the dial queue\n */\nexport interface PendingDial {\n  /**\n   * A unique identifier for this dial\n   */\n  id: string\n\n  /**\n   * The current status of the dial\n   */\n  status: PendingDialStatus\n\n  /**\n   * If known, this is the peer id that libp2p expects to be dialling\n   */\n  peerId?: PeerId\n\n  /**\n   * The list of multiaddrs that will be dialled. The returned connection will\n   * use the first address that succeeds, all other dials part of this pending\n   * dial will be cancelled.\n   */\n  multiaddrs: Multiaddr[]\n}\n\nexport type Libp2pStatus = 'starting' | 'started' | 'stopping' | 'stopped'\n\nexport interface IsDialableOptions extends AbortOptions {\n  /**\n   * If the dial attempt would open a protocol, and the multiaddr being dialed\n   * is a circuit relay address, passing true here would cause the test to fail\n   * because that protocol would not be allowed to run over a data/time limited\n   * connection.\n   */\n  runOnLimitedConnection?: boolean\n}\n\nexport type TransportManagerDialProgressEvents =\n  ProgressEvent<'transport-manager:selected-transport', string>\n\nexport type OpenConnectionProgressEvents =\n  TransportManagerDialProgressEvents |\n  ProgressEvent<'dial-queue:already-connected'> |\n  ProgressEvent<'dial-queue:already-in-dial-queue'> |\n  ProgressEvent<'dial-queue:add-to-dial-queue'> |\n  ProgressEvent<'dial-queue:start-dial'> |\n  ProgressEvent<'dial-queue:calculated-addresses', Address[]> |\n  OutboundConnectionUpgradeEvents\n\nexport interface DialOptions extends AbortOptions, ProgressOptions {\n  /**\n   * If true, open a new connection to the remote even if one already exists\n   */\n  force?: boolean\n}\n\nexport interface DialProtocolOptions extends NewStreamOptions {\n\n}\n\n/**\n * Libp2p nodes implement this interface.\n */\nexport interface Libp2p<T extends ServiceMap = ServiceMap> extends Startable, TypedEventTarget<Libp2pEvents<T>> {\n  /**\n   * The PeerId is a unique identifier for a node on the network.\n   *\n   * It is the hash of an RSA public key or, for Ed25519 or secp256k1 keys,\n   * the key itself.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * console.info(libp2p.peerId)\n   * // PeerId(12D3Foo...)\n   * ````\n   */\n  peerId: PeerId\n\n  /**\n   * The peer store holds information we know about other peers on the network.\n   * - multiaddrs, supported protocols, etc.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peer = await libp2p.peerStore.get(peerId)\n   * console.info(peer)\n   * // { id: PeerId(12D3Foo...), addresses: [] ... }\n   * ```\n   */\n  peerStore: PeerStore\n\n  /**\n   * The peer routing subsystem allows the user to find peers on the network\n   * or to find peers close to binary keys.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peerInfo = await libp2p.peerRouting.findPeer(peerId)\n   * console.info(peerInfo)\n   * // { id: PeerId(12D3Foo...), multiaddrs: [] ... }\n   * ```\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for await (const peerInfo of libp2p.peerRouting.getClosestPeers(key)) {\n   *   console.info(peerInfo)\n   *   // { id: PeerId(12D3Foo...), multiaddrs: [] ... }\n   * }\n   * ```\n   */\n  peerRouting: PeerRouting\n\n  /**\n   * The content routing subsystem allows the user to find providers for content,\n   * let the network know they are providers for content, and get/put values to\n   * the DHT.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for await (const peerInfo of libp2p.contentRouting.findProviders(cid)) {\n   *   console.info(peerInfo)\n   *   // { id: PeerId(12D3Foo...), multiaddrs: [] ... }\n   * }\n   * ```\n   */\n  contentRouting: ContentRouting\n\n  /**\n   * The metrics subsystem allows recording values to assess the health/performance\n   * of the running node.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const metric = libp2p.metrics.registerMetric({\n   *   'my-metric'\n   * })\n   *\n   * // later\n   * metric.update(5)\n   * ```\n   */\n  metrics?: Metrics\n\n  /**\n   * The logger used by this libp2p node\n   */\n  logger: ComponentLogger\n\n  /**\n   * The current status of the libp2p node\n   */\n  status: Libp2pStatus\n\n  /**\n   * Get a deduplicated list of peer advertising multiaddrs by concatenating\n   * the listen addresses used by transports with any configured\n   * announce addresses as well as observed addresses reported by peers.\n   *\n   * If Announce addrs are specified, configured listen addresses will be\n   * ignored though observed addresses will still be included.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const listenMa = libp2p.getMultiaddrs()\n   * // [ <Multiaddr 047f00000106f9ba - /ip4/127.0.0.1/tcp/63930> ]\n   * ```\n   */\n  getMultiaddrs(): Multiaddr[]\n\n  /**\n   * Returns a list of supported protocols\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const protocols = libp2p.getProtocols()\n   * // [ '/ipfs/ping/1.0.0', '/ipfs/id/1.0.0' ]\n   * ```\n   */\n  getProtocols(): string[]\n\n  /**\n   * Return a list of all connections this node has open, optionally filtering\n   * by a PeerId\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for (const connection of libp2p.getConnections()) {\n   *   console.log(peerId, connection.remoteAddr.toString())\n   *   // Logs the PeerId string and the observed remote multiaddr of each Connection\n   * }\n   * ```\n   */\n  getConnections(peerId?: PeerId): Connection[]\n\n  /**\n   * Return the list of dials currently in progress or queued to start\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for (const pendingDial of libp2p.getDialQueue()) {\n   *   console.log(pendingDial)\n   * }\n   * ```\n   */\n  getDialQueue(): PendingDial[]\n\n  /**\n   * Return a list of all peers we currently have a connection open to\n   */\n  getPeers(): PeerId[]\n\n  /**\n   * Dials to the provided peer. If successful, the known metadata of the\n   * peer will be added to the nodes `peerStore`.\n   *\n   * If a PeerId is passed as the first argument, the peer will need to have known multiaddrs for it in the PeerStore.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const conn = await libp2p.dial(remotePeerId)\n   *\n   * // create a new stream within the connection\n   * const stream = await conn.newStream(['/echo/1.1.0', '/echo/1.0.0'])\n   *\n   * // protocol negotiated: 'echo/1.0.0' means that the other party only supports the older version\n   *\n   * // ...\n   * await conn.close()\n   * ```\n   */\n  dial(peer: PeerId | Multiaddr | Multiaddr[], options?: DialOptions): Promise<Connection>\n\n  /**\n   * Dials to the provided peer and tries to handshake with the given protocols in order.\n   * If successful, the known metadata of the peer will be added to the nodes `peerStore`,\n   * and the `MuxedStream` will be returned together with the successful negotiated protocol.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * import { pipe } from 'it-pipe'\n   *\n   * const { stream, protocol } = await libp2p.dialProtocol(remotePeerId, protocols)\n   *\n   * // Use this new stream like any other duplex stream\n   * pipe([1, 2, 3], stream, consume)\n   * ```\n   */\n  dialProtocol(peer: PeerId | Multiaddr | Multiaddr[], protocols: string | string[], options?: DialProtocolOptions): Promise<Stream>\n\n  /**\n   * Attempts to gracefully close an open connection to the given peer. If the\n   * connection is not closed in the grace period, it will be forcefully closed.\n   *\n   * An AbortSignal can optionally be passed to control when the connection is\n   * forcefully closed.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * await libp2p.hangUp(remotePeerId)\n   * ```\n   */\n  hangUp(peer: PeerId | Multiaddr, options?: AbortOptions): Promise<void>\n\n  /**\n   * Sets up [multistream-select routing](https://github.com/multiformats/multistream-select) of protocols to their application handlers. Whenever a stream is opened on one of the provided protocols, the handler will be called. `handle` must be called in order to register a handler and support for a given protocol. This also informs other peers of the protocols you support.\n   *\n   * `libp2p.handle(protocols, handler, options)`\n   *\n   * In the event of a new handler for the same protocol being added and error\n   * will be thrown. Pass `force: true` to override this.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const handler = ({ connection, stream, protocol }) => {\n   *   // use stream or connection according to the needs\n   * }\n   *\n   * libp2p.handle('/echo/1.0.0', handler, {\n   *   maxInboundStreams: 5,\n   *   maxOutboundStreams: 5\n   * })\n   * ```\n   */\n  handle(protocol: string | string[], handler: StreamHandler, options?: StreamHandlerOptions): Promise<void>\n\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.unhandle(['/echo/1.0.0'])\n   * ```\n   */\n  unhandle(protocols: string[] | string, options?: AbortOptions): Promise<void>\n\n  /**\n   * Register a topology to be informed when peers are encountered that\n   * support the specified protocol\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const id = await libp2p.register('/echo/1.0.0', {\n   *   onConnect: (peer, connection) => {\n   *     // handle connect\n   *   },\n   *   onDisconnect: (peer, connection) => {\n   *     // handle disconnect\n   *   }\n   * })\n   * ```\n   */\n  register(protocol: string, topology: Topology, options?: AbortOptions): Promise<string>\n\n  /**\n   * Unregister topology to no longer be informed when peers connect or\n   * disconnect.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const id = await libp2p.register(...)\n   *\n   * libp2p.unregister(id)\n   * ```\n   */\n  unregister(id: string): void\n\n  /**\n   * Returns the public key for the passed PeerId. If the PeerId is of the 'RSA'\n   * type this may mean searching the routing if the peer's key is not present\n   * in the peer store.\n   */\n  getPublicKey(peer: Ed25519PeerId, options?: AbortOptions): Promise<Ed25519PublicKey>\n  getPublicKey(peer: Secp256k1PeerId, options?: AbortOptions): Promise<Secp256k1PublicKey>\n  getPublicKey(peer: RSAPeerId, options?: AbortOptions): Promise<RSAPublicKey>\n  getPublicKey(peer: URLPeerId, options?: AbortOptions): Promise<never>\n  getPublicKey(peer: PeerId, options?: AbortOptions): Promise<PublicKey>\n\n  /**\n   * Given the current node configuration, returns a promise of `true` or\n   * `false` if the node would attempt to dial the passed multiaddr.\n   *\n   * This means a relevant transport is configured, and the connection gater\n   * would not block the dial attempt.\n   *\n   * This may involve resolving DNS addresses so you should pass an AbortSignal.\n   */\n  isDialable(multiaddr: Multiaddr | Multiaddr[], options?: IsDialableOptions): Promise<boolean>\n\n  /**\n   * A set of user defined services\n   */\n  services: T\n}\n\n/**\n * Metadata about the current node\n */\nexport interface NodeInfo {\n  /**\n   * The implementation name\n   */\n  name: string\n\n  /**\n   * The implementation version\n   */\n  version: string\n\n  /**\n   * A string that contains information about the implementation and runtime\n   */\n  userAgent: string\n}\n\n/**\n * An object that contains an AbortSignal as\n * the optional `signal` property.\n *\n * @example\n *\n * ```TypeScript\n * const controller = new AbortController()\n *\n * aLongRunningOperation({\n *   signal: controller.signal\n * })\n *\n * // later\n *\n * controller.abort()\n */\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\n/**\n * An object that contains a Logger as the `log` property.\n */\nexport interface LoggerOptions {\n  log: Logger\n}\n\n/**\n * An object that includes a trace object that is passed onwards.\n *\n * This is used by metrics method tracing to link function calls together.\n */\nexport interface TraceOptions {\n  trace?: any\n}\n\n/**\n * A signal that needs to be cleared when no longer in use\n */\nexport interface ClearableSignal extends AbortSignal {\n  clear(): void\n}\n\n/**\n * When a routing operation involves reading values, these options allow\n * controlling where the values are read from. By default libp2p will check\n * local caches but may not use the network if a valid local value is found,\n * these options allow tuning that behavior.\n */\nexport interface RoutingOptions extends AbortOptions, ProgressOptions, TraceOptions {\n  /**\n   * Pass `false` to not use the network\n   *\n   * @default true\n   */\n  useNetwork?: boolean\n\n  /**\n   * Pass `false` to not use cached values\n   *\n   * @default true\n   */\n  useCache?: boolean\n}\n\n/**\n * This symbol is used by libp2p services to define the capabilities they can\n * provide to other libp2p services.\n *\n * The service should define a property with this symbol as the key and the\n * value should be a string array of provided capabilities.\n */\nexport const serviceCapabilities = Symbol.for('@libp2p/service-capabilities')\n\n/**\n * This symbol is used by libp2p services to define the capabilities they\n * require from other libp2p services.\n *\n * The service should define a property with this symbol as the key and the\n * value should be a string array of required capabilities.\n */\nexport const serviceDependencies = Symbol.for('@libp2p/service-dependencies')\n\nexport * from './connection.js'\nexport * from './connection-encrypter.js'\nexport * from './connection-gater.js'\nexport * from './content-routing.js'\nexport * from './keys.js'\nexport * from './metrics.js'\nexport * from './peer-discovery.js'\nexport * from './peer-id.js'\nexport * from './peer-info.js'\nexport * from './peer-routing.js'\nexport * from './peer-store.js'\nexport * from './pubsub.js'\nexport * from './record.js'\nexport * from './stream-handler.js'\nexport * from './stream-muxer.js'\nexport * from './topology.js'\nexport * from './transport.js'\nexport * from './errors.js'\nexport * from 'main-event'\nexport * from './startable.js'\n", "\n// If the passed object is an (async) iterable, then get the iterator\n// If it's probably an iterator already (i.e. has next function) return it\n// else throw\nexport function getIterator <T> (obj: AsyncIterable<T>): AsyncIterator<T>\nexport function getIterator <T> (obj: AsyncIterator<T>): AsyncIterator<T>\nexport function getIterator <T> (obj: Iterable<T>): Iterator<T>\nexport function getIterator <T> (obj: Iterator<T>): Iterator<T>\nexport function getIterator <T> (obj: any): AsyncIterator<T> | Iterator <T>\nexport function getIterator <T> (obj: any): AsyncIterator<T> | Iterator <T> {\n  if (obj != null) {\n    if (typeof obj[Symbol.iterator] === 'function') {\n      return obj[Symbol.iterator]()\n    }\n    if (typeof obj[Symbol.asyncIterator] === 'function') {\n      return obj[Symbol.asyncIterator]()\n    }\n    if (typeof obj.next === 'function') {\n      return obj // probably an iterator\n    }\n  }\n  throw new Error('argument is not an iterator or iterable')\n}\n", "export default function pDefer() {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n}\n", "// ported from https://www.npmjs.com/package/fast-fifo\n\nexport interface Next<T> {\n  done?: boolean\n  error?: Error\n  value?: T\n}\n\nclass FixedFIFO<T> {\n  public buffer: Array<Next<T> | undefined>\n  private readonly mask: number\n  private top: number\n  private btm: number\n  public next: FixedFIFO<T> | null\n\n  constructor (hwm: number) {\n    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) {\n      throw new Error('Max size for a FixedFIFO should be a power of two')\n    }\n\n    this.buffer = new Array(hwm)\n    this.mask = hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.next = null\n  }\n\n  push (data: Next<T>): boolean {\n    if (this.buffer[this.top] !== undefined) {\n      return false\n    }\n\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n\n    return true\n  }\n\n  shift (): Next<T> | undefined {\n    const last = this.buffer[this.btm]\n\n    if (last === undefined) {\n      return undefined\n    }\n\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    return last\n  }\n\n  isEmpty (): boolean {\n    return this.buffer[this.btm] === undefined\n  }\n}\n\nexport interface FIFOOptions {\n  /**\n   * When the queue reaches this size, it will be split into head/tail parts\n   */\n  splitLimit?: number\n}\n\nexport class FIFO<T> {\n  public size: number\n  private readonly hwm: number\n  private head: FixedFIFO<T>\n  private tail: FixedFIFO<T>\n\n  constructor (options: FIFOOptions = {}) {\n    this.hwm = options.splitLimit ?? 16\n    this.head = new FixedFIFO<T>(this.hwm)\n    this.tail = this.head\n    this.size = 0\n  }\n\n  calculateSize (obj: any): number {\n    if (obj?.byteLength != null) {\n      return obj.byteLength\n    }\n\n    return 1\n  }\n\n  push (val: Next<T>): void {\n    if (val?.value != null) {\n      this.size += this.calculateSize(val.value)\n    }\n\n    if (!this.head.push(val)) {\n      const prev = this.head\n      this.head = prev.next = new FixedFIFO<T>(2 * this.head.buffer.length)\n      this.head.push(val)\n    }\n  }\n\n  shift (): Next<T> | undefined {\n    let val = this.tail.shift()\n\n    if (val === undefined && (this.tail.next != null)) {\n      const next = this.tail.next\n      this.tail.next = null\n      this.tail = next\n      val = this.tail.shift()\n    }\n\n    if (val?.value != null) {\n      this.size -= this.calculateSize(val.value)\n    }\n\n    return val\n  }\n\n  isEmpty (): boolean {\n    return this.head.isEmpty()\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\n\nimport deferred from 'p-defer'\nimport { FIFO, type Next } from './fifo.js'\n\nexport class AbortError extends Error {\n  type: string\n  code: string\n\n  constructor (message?: string, code?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\ninterface BasePushable<T> {\n  /**\n   * End the iterable after all values in the buffer (if any) have been yielded. If an\n   * error is passed the buffer is cleared immediately and the next iteration will\n   * throw the passed error\n   */\n  end(err?: Error): this\n\n  /**\n   * Push a value into the iterable. Values are yielded from the iterable in the order\n   * they are pushed. Values not yet consumed from the iterable are buffered.\n   */\n  push(value: T): this\n\n  /**\n   * Returns a promise that resolves when the underlying queue becomes empty (e.g.\n   * this.readableLength === 0).\n   *\n   * If an AbortSignal is passed as an option and that signal aborts, it only\n   * causes the returned promise to reject - it does not end the pushable.\n   */\n  onEmpty(options?: AbortOptions): Promise<void>\n\n  /**\n   * This property contains the number of bytes (or objects) in the queue ready to be read.\n   *\n   * If `objectMode` is true, this is the number of objects in the queue, if false it's the\n   * total number of bytes in the queue.\n   */\n  readableLength: number\n}\n\n/**\n * An iterable that you can push values into.\n */\nexport interface Pushable<T, R = void, N = unknown> extends AsyncGenerator<T, R, N>, BasePushable<T> {}\n\n/**\n * Similar to `pushable`, except it yields multiple buffered chunks at a time. All values yielded from the iterable will be arrays.\n */\nexport interface PushableV<T, R = void, N = unknown> extends AsyncGenerator<T[], R, N>, BasePushable<T> {}\n\nexport interface Options {\n  /**\n   * A boolean value that means non-`Uint8Array`s will be passed to `.push`, default: `false`\n   */\n  objectMode?: boolean\n\n  /**\n   * A function called after *all* values have been yielded from the iterator (including\n   * buffered values). In the case when the iterator is ended with an error it will be\n   * passed the error as a parameter.\n   */\n  onEnd?(err?: Error): void\n}\n\nexport interface DoneResult { done: true }\nexport interface ValueResult<T> { done: false, value: T }\nexport type NextResult<T> = ValueResult<T> | DoneResult\n\ninterface getNext<T, V = T> { (buffer: FIFO<T>): NextResult<V> }\n\nexport interface ObjectPushableOptions extends Options {\n  objectMode: true\n}\n\nexport interface BytePushableOptions extends Options {\n  objectMode?: false\n}\n\n/**\n * Create a new async iterable. The values yielded from calls to `.next()`\n * or when used in a `for await of`loop are \"pushed\" into the iterable.\n * Returns an async iterable object with additional methods.\n */\nexport function pushable<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): Pushable<T>\nexport function pushable<T> (options: ObjectPushableOptions): Pushable<T>\nexport function pushable<T> (options: Options = {}): Pushable<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T> => {\n    const next: Next<T> | undefined = buffer.shift()\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    if (next.error != null) {\n      throw next.error\n    }\n\n    return {\n      done: next.done === true,\n      // @ts-expect-error if done is false, value will be present\n      value: next.value\n    }\n  }\n\n  return _pushable<T, T, Pushable<T>>(getNext, options)\n}\n\nexport function pushableV<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): PushableV<T>\nexport function pushableV<T> (options: ObjectPushableOptions): PushableV<T>\nexport function pushableV<T> (options: Options = {}): PushableV<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T[]> => {\n    let next: Next<T> | undefined\n    const values: T[] = []\n\n    while (!buffer.isEmpty()) {\n      next = buffer.shift()\n\n      if (next == null) {\n        break\n      }\n\n      if (next.error != null) {\n        throw next.error\n      }\n\n      if (next.done === false) {\n        // @ts-expect-error if done is false value should be pushed\n        values.push(next.value)\n      }\n    }\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    return {\n      done: next.done === true,\n      value: values\n    }\n  }\n\n  return _pushable<T, T[], PushableV<T>>(getNext, options)\n}\n\nfunction _pushable<PushType, ValueType, ReturnType> (getNext: getNext<PushType, ValueType>, options?: Options): ReturnType {\n  options = options ?? {}\n  let onEnd = options.onEnd\n  let buffer = new FIFO<PushType>()\n  let pushable: any\n  let onNext: ((next: Next<PushType>) => ReturnType) | null\n  let ended: boolean\n  let drain = deferred()\n\n  const waitNext = async (): Promise<NextResult<ValueType>> => {\n    try {\n      if (!buffer.isEmpty()) {\n        return getNext(buffer)\n      }\n\n      if (ended) {\n        return { done: true }\n      }\n\n      return await new Promise<NextResult<ValueType>>((resolve, reject) => {\n        onNext = (next: Next<PushType>) => {\n          onNext = null\n          buffer.push(next)\n\n          try {\n            resolve(getNext(buffer))\n          } catch (err) {\n            reject(err)\n          }\n\n          return pushable\n        }\n      })\n    } finally {\n      if (buffer.isEmpty()) {\n        // settle promise in the microtask queue to give consumers a chance to\n        // await after calling .push\n        queueMicrotask(() => {\n          drain.resolve()\n          drain = deferred()\n        })\n      }\n    }\n  }\n\n  const bufferNext = (next: Next<PushType>): ReturnType => {\n    if (onNext != null) {\n      return onNext(next)\n    }\n\n    buffer.push(next)\n    return pushable\n  }\n\n  const bufferError = (err: Error): ReturnType => {\n    buffer = new FIFO()\n\n    if (onNext != null) {\n      return onNext({ error: err })\n    }\n\n    buffer.push({ error: err })\n    return pushable\n  }\n\n  const push = (value: PushType): ReturnType => {\n    if (ended) {\n      return pushable\n    }\n\n    // @ts-expect-error `byteLength` is not declared on PushType\n    if (options?.objectMode !== true && value?.byteLength == null) {\n      throw new Error('objectMode was not true but tried to push non-Uint8Array value')\n    }\n\n    return bufferNext({ done: false, value })\n  }\n  const end = (err?: Error): ReturnType => {\n    if (ended) return pushable\n    ended = true\n\n    return (err != null) ? bufferError(err) : bufferNext({ done: true })\n  }\n  const _return = (): DoneResult => {\n    buffer = new FIFO()\n    end()\n\n    return { done: true }\n  }\n  const _throw = (err: Error): DoneResult => {\n    end(err)\n\n    return { done: true }\n  }\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next: waitNext,\n    return: _return,\n    throw: _throw,\n    push,\n    end,\n    get readableLength (): number {\n      return buffer.size\n    },\n    onEmpty: async (options?: AbortOptions) => {\n      const signal = options?.signal\n      signal?.throwIfAborted()\n\n      if (buffer.isEmpty()) {\n        return\n      }\n\n      let cancel: Promise<void> | undefined\n      let listener: (() => void) | undefined\n\n      if (signal != null) {\n        cancel = new Promise((resolve, reject) => {\n          listener = () => {\n            reject(new AbortError())\n          }\n\n          signal.addEventListener('abort', listener)\n        })\n      }\n\n      try {\n        await Promise.race([\n          drain.promise,\n          cancel\n        ])\n      } finally {\n        if (listener != null && signal != null) {\n          signal?.removeEventListener('abort', listener)\n        }\n      }\n    }\n  }\n\n  if (onEnd == null) {\n    return pushable\n  }\n\n  const _pushable = pushable\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next () {\n      return _pushable.next()\n    },\n    throw (err: Error) {\n      _pushable.throw(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    return () {\n      _pushable.return()\n\n      if (onEnd != null) {\n        onEnd()\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    push,\n    end (err: Error) {\n      _pushable.end(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return pushable\n    },\n    get readableLength () {\n      return _pushable.readableLength\n    },\n    onEmpty: (opts?: AbortOptions) => {\n      return _pushable.onEmpty(opts)\n    }\n  }\n\n  return pushable\n}\n", "/**\n * An abort error class that extends error\n */\nexport class AbortError extends Error {\n  public type: string\n  public code: string | string\n\n  constructor (message?: string, code?: string, name?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.name = name ?? 'AbortError'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface RaceSignalOptions {\n  /**\n   * The message for the error thrown if the signal aborts\n   */\n  errorMessage?: string\n\n  /**\n   * The code for the error thrown if the signal aborts\n   */\n  errorCode?: string\n\n  /**\n   * The name for the error thrown if the signal aborts\n   */\n  errorName?: string\n}\n\n/**\n * Race a promise against an abort signal\n */\nexport async function raceSignal <T> (promise: Promise<T>, signal?: AbortSignal, opts?: RaceSignalOptions): Promise<T> {\n  if (signal == null) {\n    return promise\n  }\n\n  if (signal.aborted) {\n    // the passed promise may yet resolve or reject but the use has signalled\n    // they are no longer interested so smother the error\n    promise.catch(() => {})\n    return Promise.reject(new AbortError(opts?.errorMessage, opts?.errorCode, opts?.errorName))\n  }\n\n  let listener\n\n  // create the error here so we have more context in the stack trace\n  const error = new AbortError(opts?.errorMessage, opts?.errorCode, opts?.errorName)\n\n  try {\n    return await Promise.race([\n      promise,\n      new Promise<T>((resolve, reject) => {\n        listener = () => {\n          reject(error)\n        }\n        signal.addEventListener('abort', listener)\n      })\n    ])\n  } finally {\n    if (listener != null) {\n      signal.removeEventListener('abort', listener)\n    }\n  }\n}\n", "/**\n * Returns a `Uint8Array` of the requested size. Referenced memory will\n * be initialized to 0.\n */\nexport function alloc (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n", "import { allocUnsafe } from '#alloc'\nimport { asUint8Array } from '#util/as-uint8array'\n\n/**\n * Returns a new Uint8Array created by concatenating the passed Uint8Arrays\n */\nexport function concat (arrays: Uint8Array[], length?: number): Uint8Array {\n  if (length == null) {\n    length = arrays.reduce((acc, curr) => acc + curr.length, 0)\n  }\n\n  const output = allocUnsafe(length)\n  let offset = 0\n\n  for (const arr of arrays) {\n    output.set(arr, offset)\n    offset += arr.length\n  }\n\n  return asUint8Array(output)\n}\n", "/**\n * Returns true if the two passed Uint8Arrays have the same content\n */\nexport function equals (a: Uint8Array, b: Uint8Array): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (a.byteLength !== b.byteLength) {\n    return false\n  }\n\n  for (let i = 0; i < a.byteLength; i++) {\n    if (a[i] !== b[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n", "/**\n * @packageDocumentation\n *\n * A class that lets you do operations over a list of Uint8Arrays without\n * copying them.\n *\n * ```js\n * import { Uint8ArrayList } from 'uint8arraylist'\n *\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray()\n * // -> Uint8Array([0, 1, 2, 3, 4, 5])\n *\n * list.consume(3)\n * list.subarray()\n * // -> Uint8Array([3, 4, 5])\n *\n * // you can also iterate over the list\n * for (const buf of list) {\n *   // ..do something with `buf`\n * }\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ## Converting Uint8ArrayLists to Uint8Arrays\n *\n * There are two ways to turn a `Uint8ArrayList` into a `Uint8Array` - `.slice` and `.subarray` and one way to turn a `Uint8ArrayList` into a `Uint8ArrayList` with different contents - `.sublist`.\n *\n * ### slice\n *\n * Slice follows the same semantics as [Uint8Array.slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice) in that it creates a new `Uint8Array` and copies bytes into it using an optional offset & length.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.slice(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ### subarray\n *\n * Subarray attempts to follow the same semantics as [Uint8Array.subarray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray) with one important different - this is a no-copy operation, unless the requested bytes span two internal buffers in which case it is a copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0]) - no-copy\n *\n * list.subarray(2, 5)\n * // -> Uint8Array([2, 3, 4]) - copy\n * ```\n *\n * ### sublist\n *\n * Sublist creates and returns a new `Uint8ArrayList` that shares the underlying buffers with the original so is always a no-copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.sublist(0, 1)\n * // -> Uint8ArrayList([0]) - no-copy\n *\n * list.sublist(2, 5)\n * // -> Uint8ArrayList([2], [3, 4]) - no-copy\n * ```\n *\n * ## Inspiration\n *\n * Borrows liberally from [bl](https://www.npmjs.com/package/bl) but only uses native JS types.\n */\nimport { allocUnsafe, alloc } from 'uint8arrays/alloc'\nimport { concat } from 'uint8arrays/concat'\nimport { equals } from 'uint8arrays/equals'\n\nconst symbol = Symbol.for('@achingbrain/uint8arraylist')\n\nexport type Appendable = Uint8ArrayList | Uint8Array\n\nfunction findBufAndOffset (bufs: Uint8Array[], index: number): { buf: Uint8Array, index: number } {\n  if (index == null || index < 0) {\n    throw new RangeError('index is out of bounds')\n  }\n\n  let offset = 0\n\n  for (const buf of bufs) {\n    const bufEnd = offset + buf.byteLength\n\n    if (index < bufEnd) {\n      return {\n        buf,\n        index: index - offset\n      }\n    }\n\n    offset = bufEnd\n  }\n\n  throw new RangeError('index is out of bounds')\n}\n\n/**\n * Check if object is a CID instance\n *\n * @example\n *\n * ```js\n * import { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist'\n *\n * isUint8ArrayList(true) // false\n * isUint8ArrayList([]) // false\n * isUint8ArrayList(new Uint8ArrayList()) // true\n * ```\n */\nexport function isUint8ArrayList (value: any): value is Uint8ArrayList {\n  return Boolean(value?.[symbol])\n}\n\nexport class Uint8ArrayList implements Iterable<Uint8Array> {\n  private bufs: Uint8Array[]\n  public length: number\n  public readonly [symbol] = true\n\n  constructor (...data: Appendable[]) {\n    this.bufs = []\n    this.length = 0\n\n    if (data.length > 0) {\n      this.appendAll(data)\n    }\n  }\n\n  * [Symbol.iterator] (): Iterator<Uint8Array> {\n    yield * this.bufs\n  }\n\n  get byteLength (): number {\n    return this.length\n  }\n\n  /**\n   * Add one or more `bufs` to the end of this Uint8ArrayList\n   */\n  append (...bufs: Appendable[]): void {\n    this.appendAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the end of this Uint8ArrayList\n   */\n  appendAll (bufs: Appendable[]): void {\n    let length = 0\n\n    for (const buf of bufs) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.push(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.push(...buf.bufs)\n      } else {\n        throw new Error('Could not append value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Add one or more `bufs` to the start of this Uint8ArrayList\n   */\n  prepend (...bufs: Appendable[]): void {\n    this.prependAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the start of this Uint8ArrayList\n   */\n  prependAll (bufs: Appendable[]): void {\n    let length = 0\n\n    for (const buf of bufs.reverse()) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.unshift(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.unshift(...buf.bufs)\n      } else {\n        throw new Error('Could not prepend value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Read the value at `index`\n   */\n  get (index: number): number {\n    const res = findBufAndOffset(this.bufs, index)\n\n    return res.buf[res.index]\n  }\n\n  /**\n   * Set the value at `index` to `value`\n   */\n  set (index: number, value: number): void {\n    const res = findBufAndOffset(this.bufs, index)\n\n    res.buf[res.index] = value\n  }\n\n  /**\n   * Copy bytes from `buf` to the index specified by `offset`\n   */\n  write (buf: Appendable, offset: number = 0): void {\n    if (buf instanceof Uint8Array) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf[i])\n      }\n    } else if (isUint8ArrayList(buf)) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf.get(i))\n      }\n    } else {\n      throw new Error('Could not write value, must be an Uint8Array or a Uint8ArrayList')\n    }\n  }\n\n  /**\n   * Remove bytes from the front of the pool\n   */\n  consume (bytes: number): void {\n    // first, normalize the argument, in accordance with how Buffer does it\n    bytes = Math.trunc(bytes)\n\n    // do nothing if not a positive number\n    if (Number.isNaN(bytes) || bytes <= 0) {\n      return\n    }\n\n    // if consuming all bytes, skip iterating\n    if (bytes === this.byteLength) {\n      this.bufs = []\n      this.length = 0\n      return\n    }\n\n    while (this.bufs.length > 0) {\n      if (bytes >= this.bufs[0].byteLength) {\n        bytes -= this.bufs[0].byteLength\n        this.length -= this.bufs[0].byteLength\n        this.bufs.shift()\n      } else {\n        this.bufs[0] = this.bufs[0].subarray(bytes)\n        this.length -= bytes\n        break\n      }\n    }\n  }\n\n  /**\n   * Extracts a section of an array and returns a new array.\n   *\n   * This is a copy operation as it is with Uint8Arrays and Arrays\n   * - note this is different to the behaviour of Node Buffers.\n   */\n  slice (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a alloc from the given start and end element index.\n   *\n   * In the best case where the data extracted comes from a single Uint8Array\n   * internally this is a no-copy operation otherwise it is a copy operation.\n   */\n  subarray (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    if (bufs.length === 1) {\n      return bufs[0]\n    }\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a allocList from the given start and end element index.\n   *\n   * This is a no-copy operation.\n   */\n  sublist (beginInclusive?: number, endExclusive?: number): Uint8ArrayList {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    const list = new Uint8ArrayList()\n    list.length = length\n    // don't loop, just set the bufs\n    list.bufs = [...bufs]\n\n    return list\n  }\n\n  private _subList (beginInclusive?: number, endExclusive?: number): { bufs: Uint8Array[], length: number } {\n    beginInclusive = beginInclusive ?? 0\n    endExclusive = endExclusive ?? this.length\n\n    if (beginInclusive < 0) {\n      beginInclusive = this.length + beginInclusive\n    }\n\n    if (endExclusive < 0) {\n      endExclusive = this.length + endExclusive\n    }\n\n    if (beginInclusive < 0 || endExclusive > this.length) {\n      throw new RangeError('index is out of bounds')\n    }\n\n    if (beginInclusive === endExclusive) {\n      return { bufs: [], length: 0 }\n    }\n\n    if (beginInclusive === 0 && endExclusive === this.length) {\n      return { bufs: this.bufs, length: this.length }\n    }\n\n    const bufs: Uint8Array[] = []\n    let offset = 0\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      const buf = this.bufs[i]\n      const bufStart = offset\n      const bufEnd = bufStart + buf.byteLength\n\n      // for next loop\n      offset = bufEnd\n\n      if (beginInclusive >= bufEnd) {\n        // start after this buf\n        continue\n      }\n\n      const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd\n      const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd\n\n      if (sliceStartInBuf && sliceEndsInBuf) {\n        // slice is wholly contained within this buffer\n        if (beginInclusive === bufStart && endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        const start = beginInclusive - bufStart\n        bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)))\n        break\n      }\n\n      if (sliceStartInBuf) {\n        // slice starts in this buffer\n        if (beginInclusive === 0) {\n          // requested whole buffer\n          bufs.push(buf)\n          continue\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(beginInclusive - bufStart))\n        continue\n      }\n\n      if (sliceEndsInBuf) {\n        if (endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(0, endExclusive - bufStart))\n        break\n      }\n\n      // slice started before this buffer and ends after it\n      bufs.push(buf)\n    }\n\n    return { bufs, length: endExclusive - beginInclusive }\n  }\n\n  indexOf (search: Uint8ArrayList | Uint8Array, offset: number = 0): number {\n    if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {\n      throw new TypeError('The \"value\" argument must be a Uint8ArrayList or Uint8Array')\n    }\n\n    const needle = search instanceof Uint8Array ? search : search.subarray()\n\n    offset = Number(offset ?? 0)\n\n    if (isNaN(offset)) {\n      offset = 0\n    }\n\n    if (offset < 0) {\n      offset = this.length + offset\n    }\n\n    if (offset < 0) {\n      offset = 0\n    }\n\n    if (search.length === 0) {\n      return offset > this.length ? this.length : offset\n    }\n\n    // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm\n    const M: number = needle.byteLength\n\n    if (M === 0) {\n      throw new TypeError('search must be at least 1 byte long')\n    }\n\n    // radix\n    const radix: number = 256\n    const rightmostPositions: Int32Array = new Int32Array(radix)\n\n    // position of the rightmost occurrence of the byte c in the pattern\n    for (let c: number = 0; c < radix; c++) {\n      // -1 for bytes not in pattern\n      rightmostPositions[c] = -1\n    }\n\n    for (let j = 0; j < M; j++) {\n      // rightmost position for bytes in pattern\n      rightmostPositions[needle[j]] = j\n    }\n\n    // Return offset of first match, -1 if no match\n    const right = rightmostPositions\n    const lastIndex = this.byteLength - needle.byteLength\n    const lastPatIndex = needle.byteLength - 1\n    let skip: number\n\n    for (let i = offset; i <= lastIndex; i += skip) {\n      skip = 0\n\n      for (let j = lastPatIndex; j >= 0; j--) {\n        const char: number = this.get(i + j)\n\n        if (needle[j] !== char) {\n          skip = Math.max(1, j - right[char])\n          break\n        }\n      }\n\n      if (skip === 0) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  getInt8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt8(0)\n  }\n\n  setInt8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt16(0, littleEndian)\n  }\n\n  setInt16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt32(0, littleEndian)\n  }\n\n  setInt32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigInt64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigInt64(0, littleEndian)\n  }\n\n  setBigInt64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigInt64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint8(0)\n  }\n\n  setUint8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint16(0, littleEndian)\n  }\n\n  setUint16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint32(0, littleEndian)\n  }\n\n  setUint32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigUint64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigUint64(0, littleEndian)\n  }\n\n  setBigUint64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigUint64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat32(0, littleEndian)\n  }\n\n  setFloat32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat64 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat64(0, littleEndian)\n  }\n\n  setFloat64 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  equals (other: any): other is Uint8ArrayList {\n    if (other == null) {\n      return false\n    }\n\n    if (!(other instanceof Uint8ArrayList)) {\n      return false\n    }\n\n    if (other.bufs.length !== this.bufs.length) {\n      return false\n    }\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      if (!equals(this.bufs[i], other.bufs[i])) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this\n   * method if you know the total size of all the Uint8Arrays ahead of time.\n   */\n  static fromUint8Arrays (bufs: Uint8Array[], length?: number): Uint8ArrayList {\n    const list = new Uint8ArrayList()\n    list.bufs = bufs\n\n    if (length == null) {\n      length = bufs.reduce((acc, curr) => acc + curr.byteLength, 0)\n    }\n\n    list.length = length\n\n    return list\n  }\n}\n\n/*\nfunction indexOf (needle: Uint8Array, haystack: Uint8Array, offset = 0) {\n  for (let i = offset; i < haystack.byteLength; i++) {\n    for (let j = 0; j < needle.length; j++) {\n      if (haystack[i + j] !== needle[j]) {\n        break\n      }\n\n      if (j === needle.byteLength -1) {\n        return i\n      }\n    }\n\n    if (haystack.byteLength - i < needle.byteLength) {\n      break\n    }\n  }\n\n  return -1\n}\n*/\n", "export class InvalidFrameError extends Error {\n  static name = 'InvalidFrameError'\n\n  constructor (message = 'The frame was invalid') {\n    super(message)\n    this.name = 'InvalidFrameError'\n  }\n}\n\nexport class UnrequestedPingError extends Error {\n  static name = 'UnrequestedPingError'\n\n  constructor (message = 'Unrequested ping error') {\n    super(message)\n    this.name = 'UnrequestedPingError'\n  }\n}\n\nexport class NotMatchingPingError extends Error {\n  static name = 'NotMatchingPingError'\n\n  constructor (message = 'Unrequested ping error') {\n    super(message)\n    this.name = 'NotMatchingPingError'\n  }\n}\n\nexport class InvalidStateError extends Error {\n  static name = 'InvalidStateError'\n\n  constructor (message = 'Invalid state') {\n    super(message)\n    this.name = 'InvalidStateError'\n  }\n}\n\nexport class StreamAlreadyExistsError extends Error {\n  static name = 'StreamAlreadyExistsError'\n\n  constructor (message = 'Strean already exists') {\n    super(message)\n    this.name = 'StreamAlreadyExistsError'\n  }\n}\n\nexport class DecodeInvalidVersionError extends Error {\n  static name = 'DecodeInvalidVersionError'\n\n  constructor (message = 'Decode invalid version') {\n    super(message)\n    this.name = 'DecodeInvalidVersionError'\n  }\n}\n\nexport class BothClientsError extends Error {\n  static name = 'BothClientsError'\n\n  constructor (message = 'Both clients') {\n    super(message)\n    this.name = 'BothClientsError'\n  }\n}\n\nexport class ReceiveWindowExceededError extends Error {\n  static name = 'ReceiveWindowExceededError'\n\n  constructor (message = 'Receive window exceeded') {\n    super(message)\n    this.name = 'ReceiveWindowExceededError'\n  }\n}\n", "// Protocol violation errors\n\nimport { BothClientsError, DecodeInvalidVersionError, InvalidFrameError, NotMatchingPingError, ReceiveWindowExceededError, StreamAlreadyExistsError, UnrequestedPingError } from './errors.js'\n\nexport const PROTOCOL_ERRORS = new Set([\n  InvalidFrameError.name,\n  UnrequestedPingError.name,\n  NotMatchingPingError.name,\n  StreamAlreadyExistsError.name,\n  DecodeInvalidVersionError.name,\n  BothClientsError.name,\n  ReceiveWindowExceededError.name\n])\n\n/**\n * INITIAL_STREAM_WINDOW is the initial stream window size.\n *\n * Not an implementation choice, this is defined in the specification\n */\nexport const INITIAL_STREAM_WINDOW = 256 * 1024\n\n/**\n * Default max stream window\n */\nexport const MAX_STREAM_WINDOW = 16 * 1024 * 1024\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { INITIAL_STREAM_WINDOW, MAX_STREAM_WINDOW } from './constants.js'\n\n// TOOD use config items or delete them\nexport interface Config {\n  /**\n   * Used to do periodic keep alive messages using a ping.\n   */\n  enableKeepAlive: boolean\n\n  /**\n   * How often to perform the keep alive\n   *\n   * measured in milliseconds\n   */\n  keepAliveInterval: number\n\n  /**\n   * Maximum number of concurrent inbound streams that we accept.\n   * If the peer tries to open more streams, those will be reset immediately.\n   */\n  maxInboundStreams: number\n\n  /**\n   * Maximum number of concurrent outbound streams that we accept.\n   * If the application tries to open more streams, the call to `newStream` will throw\n   */\n  maxOutboundStreams: number\n\n  /**\n   * Used to control the initial window size that we allow for a stream.\n   *\n   * measured in bytes\n   */\n  initialStreamWindowSize: number\n\n  /**\n   * Used to control the maximum window size that we allow for a stream.\n   */\n  maxStreamWindowSize: number\n\n  /**\n   * Maximum size of a message that we'll send on a stream.\n   * This ensures that a single stream doesn't hog a connection.\n   */\n  maxMessageSize: number\n}\n\nexport const defaultConfig: Config = {\n  enableKeepAlive: true,\n  keepAliveInterval: 30_000,\n  maxInboundStreams: 1_000,\n  maxOutboundStreams: 1_000,\n  initialStreamWindowSize: INITIAL_STREAM_WINDOW,\n  maxStreamWindowSize: MAX_STREAM_WINDOW,\n  maxMessageSize: 64 * 1024\n}\n\nexport function verifyConfig (config: Config): void {\n  if (config.keepAliveInterval <= 0) {\n    throw new InvalidParametersError('keep-alive interval must be positive')\n  }\n  if (config.maxInboundStreams < 0) {\n    throw new InvalidParametersError('max inbound streams must be larger or equal 0')\n  }\n  if (config.maxOutboundStreams < 0) {\n    throw new InvalidParametersError('max outbound streams must be larger or equal 0')\n  }\n  if (config.initialStreamWindowSize < INITIAL_STREAM_WINDOW) {\n    throw new InvalidParametersError('InitialStreamWindowSize must be larger or equal 256 kB')\n  }\n  if (config.maxStreamWindowSize < config.initialStreamWindowSize) {\n    throw new InvalidParametersError('MaxStreamWindowSize must be larger than the InitialStreamWindowSize')\n  }\n  if (config.maxStreamWindowSize > 2 ** 32 - 1) {\n    throw new InvalidParametersError('MaxStreamWindowSize must be less than equal MAX_UINT32')\n  }\n  if (config.maxMessageSize < 1024) {\n    throw new InvalidParametersError('MaxMessageSize must be greater than a kilobyte')\n  }\n}\n", "export enum FrameType {\n  /** Used to transmit data. May transmit zero length payloads depending on the flags. */\n  Data = 0x0,\n  /** Used to updated the senders receive window size. This is used to implement per-session flow control. */\n  WindowUpdate = 0x1,\n  /** Used to measure RTT. It can also be used to heart-beat and do keep-alives over TCP. */\n  Ping = 0x2,\n  /** Used to close a session. */\n  GoAway = 0x3\n}\n\nexport enum Flag {\n  /** Signals the start of a new stream. May be sent with a data or window update message. Also sent with a ping to indicate outbound. */\n  SYN = 0x1,\n  /** Acknowledges the start of a new stream. May be sent with a data or window update message. Also sent with a ping to indicate response. */\n  ACK = 0x2,\n  /** Performs a half-close of a stream. May be sent with a data message or window update. */\n  FIN = 0x4,\n  /** Reset a stream immediately. May be sent with a data or window update message. */\n  RST = 0x8\n}\n\nconst flagCodes = Object.values(Flag).filter((x) => typeof x !== 'string') as Flag[]\n\nexport const YAMUX_VERSION = 0\n\nexport enum GoAwayCode {\n  NormalTermination = 0x0,\n  ProtocolError = 0x1,\n  InternalError = 0x2\n}\n\nexport const HEADER_LENGTH = 12\n\nexport interface FrameHeader {\n  /**\n   * The version field is used for future backward compatibility.\n   * At the current time, the field is always set to 0, to indicate the initial version.\n   */\n  version?: number\n  /** The type field is used to switch the frame message type. */\n  type: FrameType\n  /** The flags field is used to provide additional information related to the message type. */\n  flag: number\n  /**\n   * The StreamID field is used to identify the logical stream the frame is addressing.\n   * The client side should use odd ID's, and the server even.\n   * This prevents any collisions. Additionally, the 0 ID is reserved to represent the session.\n   */\n  streamID: number\n  /**\n   * The meaning of the length field depends on the message type:\n   * Data - provides the length of bytes following the header\n   * Window update - provides a delta update to the window size\n   * Ping - Contains an opaque value, echoed back\n   * Go Away - Contains an error code\n   */\n  length: number\n}\n\nexport function stringifyHeader (header: FrameHeader): string {\n  const flags = flagCodes.filter(f => (header.flag & f) === f).map(f => Flag[f]).join('|')\n  return `streamID=${header.streamID} type=${FrameType[header.type]} flag=${flags} length=${header.length}`\n}\n", "import { Uint8ArrayList } from 'uint8arraylist'\nimport { InvalidFrameError, InvalidStateError } from './errors.js'\nimport { FrameType, HEADER_LENGTH, YAMUX_VERSION } from './frame.js'\nimport type { FrameHeader } from './frame.js'\nimport type { Source } from 'it-stream-types'\n\n// used to bitshift in decoding\n// native bitshift can overflow into a negative number, so we bitshift by multiplying by a power of 2\nconst twoPow24 = 2 ** 24\n\n/**\n * Decode a header from the front of a buffer\n *\n * @param data - Assumed to have enough bytes for a header\n */\nexport function decodeHeader (data: Uint8Array): FrameHeader {\n  if (data[0] !== YAMUX_VERSION) {\n    throw new InvalidFrameError('Invalid frame version')\n  }\n  return {\n    type: data[1],\n    flag: (data[2] << 8) + data[3],\n    streamID: (data[4] * twoPow24) + (data[5] << 16) + (data[6] << 8) + data[7],\n    length: (data[8] * twoPow24) + (data[9] << 16) + (data[10] << 8) + data[11]\n  }\n}\n\n/**\n * Decodes yamux frames from a source\n */\nexport class Decoder {\n  private readonly source: Source<Uint8Array | Uint8ArrayList>\n  /** Buffer for in-progress frames */\n  private readonly buffer: Uint8ArrayList\n  /** Used to sanity check against decoding while in an inconsistent state */\n  private frameInProgress: boolean\n\n  constructor (source: Source<Uint8Array | Uint8ArrayList>) {\n    // Normally, when entering a for-await loop with an iterable/async iterable, the only ways to exit the loop are:\n    // 1. exhaust the iterable\n    // 2. throw an error - slow, undesirable if there's not actually an error\n    // 3. break or return - calls the iterable's `return` method, finalizing the iterable, no more iteration possible\n    //\n    // In this case, we want to enter (and exit) a for-await loop per chunked data frame and continue processing the iterable.\n    // To do this, we strip the `return` method from the iterator and can now `break` early and continue iterating.\n    // Exiting the main for-await is still possible via 1. and 2.\n    this.source = returnlessSource(source)\n    this.buffer = new Uint8ArrayList()\n    this.frameInProgress = false\n  }\n\n  /**\n   * Emits frames from the decoder source.\n   *\n   * Note: If `readData` is emitted, it _must_ be called before the next iteration\n   * Otherwise an error is thrown\n   */\n  async * emitFrames (): AsyncGenerator<{ header: FrameHeader, readData?(): Promise<Uint8ArrayList> }> {\n    for await (const chunk of this.source) {\n      this.buffer.append(chunk)\n\n      // Loop to consume as many bytes from the buffer as possible\n      // Eg: when a single chunk contains several frames\n      while (true) {\n        const header = this.readHeader()\n        if (header === undefined) {\n          break\n        }\n\n        const { type, length } = header\n        if (type === FrameType.Data) {\n          // This is a data frame, the frame body must still be read\n          // `readData` must be called before the next iteration here\n          this.frameInProgress = true\n          yield {\n            header,\n            readData: this.readBytes.bind(this, length)\n          }\n        } else {\n          yield { header }\n        }\n      }\n    }\n  }\n\n  private readHeader (): FrameHeader | undefined {\n    // Sanity check to ensure a header isn't read when another frame is partially decoded\n    // In practice this shouldn't happen\n    if (this.frameInProgress) {\n      throw new InvalidStateError('decoding frame already in progress')\n    }\n\n    if (this.buffer.length < HEADER_LENGTH) {\n      // not enough data yet\n      return\n    }\n\n    const header = decodeHeader(this.buffer.subarray(0, HEADER_LENGTH))\n    this.buffer.consume(HEADER_LENGTH)\n    return header\n  }\n\n  private async readBytes (length: number): Promise<Uint8ArrayList> {\n    if (this.buffer.length < length) {\n      for await (const chunk of this.source) {\n        this.buffer.append(chunk)\n\n        if (this.buffer.length >= length) {\n          // see note above, the iterator is not `return`ed here\n          break\n        }\n      }\n    }\n\n    const out = this.buffer.sublist(0, length)\n    this.buffer.consume(length)\n\n    // The next frame can now be decoded\n    this.frameInProgress = false\n\n    return out\n  }\n}\n\n/**\n * Strip the `return` method from a `Source`\n */\nexport function returnlessSource<T> (source: Source<T>): Source<T> {\n  if ((source as Iterable<T>)[Symbol.iterator] !== undefined) {\n    const iterator = (source as Iterable<T>)[Symbol.iterator]()\n    iterator.return = undefined\n    return {\n      [Symbol.iterator] () { return iterator }\n    }\n  } else if ((source as AsyncIterable<T>)[Symbol.asyncIterator] !== undefined) {\n    const iterator = (source as AsyncIterable<T>)[Symbol.asyncIterator]()\n    iterator.return = undefined\n    return {\n      [Symbol.asyncIterator] () { return iterator }\n    }\n  } else {\n    throw new Error('a source must be either an iterable or an async iterable')\n  }\n}\n", "import { HEADER_LENGTH } from './frame.js'\nimport type { FrameHeader } from './frame.js'\n\nexport function encodeHeader (header: FrameHeader): Uint8Array {\n  const frame = new Uint8Array(HEADER_LENGTH)\n\n  // always assume version 0\n  // frameView.setUint8(0, header.version)\n\n  frame[1] = header.type\n\n  frame[2] = header.flag >>> 8\n  frame[3] = header.flag\n\n  frame[4] = header.streamID >>> 24\n  frame[5] = header.streamID >>> 16\n  frame[6] = header.streamID >>> 8\n  frame[7] = header.streamID\n\n  frame[8] = header.length >>> 24\n  frame[9] = header.length >>> 16\n  frame[10] = header.length >>> 8\n  frame[11] = header.length\n\n  return frame\n}\n", "export function isPromise <T = unknown> (thing: any): thing is Promise<T> {\n  if (thing == null) {\n    return false\n  }\n\n  return typeof thing.then === 'function' &&\n    typeof thing.catch === 'function' &&\n    typeof thing.finally === 'function'\n}\n", "import { getIterator } from 'get-iterator'\nimport { isPromise } from './is-promise.js'\nimport type { Logger } from '@libp2p/logger'\nimport type { Source } from 'it-stream-types'\n\nexport function closeSource (source: Source<unknown>, log: Logger): void {\n  const res = getIterator(source).return?.()\n\n  if (isPromise(res)) {\n    res.catch(err => {\n      log.error('could not cause iterator to return', err)\n    })\n  }\n}\n", "import { StreamResetError, StreamStateError } from '@libp2p/interface'\nimport { pushable } from 'it-pushable'\nimport defer from 'p-defer'\nimport { raceSignal } from 'race-signal'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { closeSource } from './close-source.js'\nimport type { AbortOptions, Direction, ReadStatus, Stream, StreamStatus, StreamTimeline, WriteStatus } from '@libp2p/interface'\nimport type { Logger } from '@libp2p/logger'\nimport type { Pushable } from 'it-pushable'\nimport type { Source } from 'it-stream-types'\nimport type { DeferredPromise } from 'p-defer'\n\nconst DEFAULT_SEND_CLOSE_WRITE_TIMEOUT = 5000\n\nexport interface AbstractStreamInit {\n  /**\n   * A unique identifier for this stream\n   */\n  id: string\n\n  /**\n   * The stream direction\n   */\n  direction: Direction\n\n  /**\n   * A Logger implementation used to log stream-specific information\n   */\n  log: Logger\n\n  /**\n   * User specific stream metadata\n   */\n  metadata?: Record<string, unknown>\n\n  /**\n   * Invoked when the stream ends\n   */\n  onEnd?(err?: Error): void\n\n  /**\n   * Invoked when the readable end of the stream is closed\n   */\n  onCloseRead?(): void\n\n  /**\n   * Invoked when the writable end of the stream is closed\n   */\n  onCloseWrite?(): void\n\n  /**\n   * Invoked when the stream has been reset by the remote\n   */\n  onReset?(): void\n\n  /**\n   * Invoked when the stream has errored\n   */\n  onAbort?(err: Error): void\n\n  /**\n   * How long to wait in ms for stream data to be written to the underlying\n   * connection when closing the writable end of the stream.\n   *\n   * @default 500\n   */\n  closeTimeout?: number\n\n  /**\n   * After the stream sink has closed, a limit on how long it takes to send\n   * a close-write message to the remote peer.\n   */\n  sendCloseWriteTimeout?: number\n}\n\nfunction isPromise <T = unknown> (thing: any): thing is Promise<T> {\n  if (thing == null) {\n    return false\n  }\n\n  return typeof thing.then === 'function' &&\n    typeof thing.catch === 'function' &&\n    typeof thing.finally === 'function'\n}\n\nexport abstract class AbstractStream implements Stream {\n  public id: string\n  public direction: Direction\n  public timeline: StreamTimeline\n  public protocol?: string\n  public metadata: Record<string, unknown>\n  public source: AsyncGenerator<Uint8ArrayList, void, unknown>\n  public status: StreamStatus\n  public readStatus: ReadStatus\n  public writeStatus: WriteStatus\n  public readonly log: Logger\n\n  private readonly sinkController: AbortController\n  private readonly sinkEnd: DeferredPromise<void>\n  private readonly closed: DeferredPromise<void>\n  private endErr: Error | undefined\n  private readonly streamSource: Pushable<Uint8ArrayList>\n  private readonly onEnd?: (err?: Error) => void\n  private readonly onCloseRead?: () => void\n  private readonly onCloseWrite?: () => void\n  private readonly onReset?: () => void\n  private readonly onAbort?: (err: Error) => void\n  private readonly sendCloseWriteTimeout: number\n  private sendingData?: DeferredPromise<void>\n\n  constructor (init: AbstractStreamInit) {\n    this.sinkController = new AbortController()\n    this.sinkEnd = defer()\n    this.closed = defer()\n    this.log = init.log\n\n    // stream status\n    this.status = 'open'\n    this.readStatus = 'ready'\n    this.writeStatus = 'ready'\n\n    this.id = init.id\n    this.metadata = init.metadata ?? {}\n    this.direction = init.direction\n    this.timeline = {\n      open: Date.now()\n    }\n    this.sendCloseWriteTimeout = init.sendCloseWriteTimeout ?? DEFAULT_SEND_CLOSE_WRITE_TIMEOUT\n\n    this.onEnd = init.onEnd\n    this.onCloseRead = init.onCloseRead\n    this.onCloseWrite = init.onCloseWrite\n    this.onReset = init.onReset\n    this.onAbort = init.onAbort\n\n    this.source = this.streamSource = pushable<Uint8ArrayList>({\n      onEnd: (err) => {\n        if (err != null) {\n          this.log.trace('source ended with error', err)\n        } else {\n          this.log.trace('source ended')\n        }\n\n        this.onSourceEnd(err)\n      }\n    })\n\n    // necessary because the libp2p upgrader wraps the sink function\n    this.sink = this.sink.bind(this)\n  }\n\n  async sink (source: Source<Uint8ArrayList | Uint8Array>): Promise<void> {\n    if (this.writeStatus !== 'ready') {\n      throw new StreamStateError(`writable end state is \"${this.writeStatus}\" not \"ready\"`)\n    }\n\n    try {\n      this.writeStatus = 'writing'\n\n      const options: AbortOptions = {\n        signal: this.sinkController.signal\n      }\n\n      if (this.direction === 'outbound') { // If initiator, open a new stream\n        const res = this.sendNewStream(options)\n\n        if (isPromise(res)) {\n          await res\n        }\n      }\n\n      const abortListener = (): void => {\n        closeSource(source, this.log)\n      }\n\n      try {\n        this.sinkController.signal.addEventListener('abort', abortListener)\n\n        this.log.trace('sink reading from source')\n\n        for await (let data of source) {\n          data = data instanceof Uint8Array ? new Uint8ArrayList(data) : data\n\n          const res = this.sendData(data, options)\n\n          if (isPromise(res)) {\n            this.sendingData = defer()\n            await res\n            this.sendingData.resolve()\n            this.sendingData = undefined\n          }\n        }\n      } finally {\n        this.sinkController.signal.removeEventListener('abort', abortListener)\n      }\n\n      this.log.trace('sink finished reading from source, write status is \"%s\"', this.writeStatus)\n\n      if (this.writeStatus === 'writing') {\n        this.writeStatus = 'closing'\n\n        this.log.trace('send close write to remote')\n        await this.sendCloseWrite({\n          signal: AbortSignal.timeout(this.sendCloseWriteTimeout)\n        })\n\n        this.writeStatus = 'closed'\n      }\n\n      this.onSinkEnd()\n    } catch (err: any) {\n      this.log.trace('sink ended with error, calling abort with error', err)\n      this.abort(err)\n\n      throw err\n    } finally {\n      this.log.trace('resolve sink end')\n      this.sinkEnd.resolve()\n    }\n  }\n\n  protected onSourceEnd (err?: Error): void {\n    if (this.timeline.closeRead != null) {\n      return\n    }\n\n    this.timeline.closeRead = Date.now()\n    this.readStatus = 'closed'\n\n    if (err != null && this.endErr == null) {\n      this.endErr = err\n    }\n\n    this.onCloseRead?.()\n\n    if (this.timeline.closeWrite != null) {\n      this.log.trace('source and sink ended')\n      this.timeline.close = Date.now()\n\n      if (this.status !== 'aborted' && this.status !== 'reset') {\n        this.status = 'closed'\n      }\n\n      if (this.onEnd != null) {\n        this.onEnd(this.endErr)\n      }\n\n      this.closed.resolve()\n    } else {\n      this.log.trace('source ended, waiting for sink to end')\n    }\n  }\n\n  protected onSinkEnd (err?: Error): void {\n    if (this.timeline.closeWrite != null) {\n      return\n    }\n\n    this.timeline.closeWrite = Date.now()\n    this.writeStatus = 'closed'\n\n    if (err != null && this.endErr == null) {\n      this.endErr = err\n    }\n\n    this.onCloseWrite?.()\n\n    if (this.timeline.closeRead != null) {\n      this.log.trace('sink and source ended')\n      this.timeline.close = Date.now()\n\n      if (this.status !== 'aborted' && this.status !== 'reset') {\n        this.status = 'closed'\n      }\n\n      if (this.onEnd != null) {\n        this.onEnd(this.endErr)\n      }\n\n      this.closed.resolve()\n    } else {\n      this.log.trace('sink ended, waiting for source to end')\n    }\n  }\n\n  // Close for both Reading and Writing\n  async close (options?: AbortOptions): Promise<void> {\n    if (this.status !== 'open') {\n      return\n    }\n\n    this.log.trace('closing gracefully')\n\n    this.status = 'closing'\n\n    // wait for read and write ends to close\n    await raceSignal(Promise.all([\n      this.closeWrite(options),\n      this.closeRead(options),\n      this.closed.promise\n    ]), options?.signal)\n\n    this.status = 'closed'\n\n    this.log.trace('closed gracefully')\n  }\n\n  async closeRead (options: AbortOptions = {}): Promise<void> {\n    if (this.readStatus === 'closing' || this.readStatus === 'closed') {\n      return\n    }\n\n    this.log.trace('closing readable end of stream with starting read status \"%s\"', this.readStatus)\n\n    const readStatus = this.readStatus\n    this.readStatus = 'closing'\n\n    if (this.status !== 'reset' && this.status !== 'aborted' && this.timeline.closeRead == null) {\n      this.log.trace('send close read to remote')\n      await this.sendCloseRead(options)\n    }\n\n    if (readStatus === 'ready') {\n      this.log.trace('ending internal source queue with %d queued bytes', this.streamSource.readableLength)\n      this.streamSource.end()\n    }\n\n    this.log.trace('closed readable end of stream')\n  }\n\n  async closeWrite (options: AbortOptions = {}): Promise<void> {\n    if (this.writeStatus === 'closing' || this.writeStatus === 'closed') {\n      return\n    }\n\n    this.log.trace('closing writable end of stream with starting write status \"%s\"', this.writeStatus)\n\n    if (this.writeStatus === 'ready') {\n      this.log.trace('sink was never sunk, sink an empty array')\n\n      await raceSignal(this.sink([]), options.signal)\n    }\n\n    if (this.writeStatus === 'writing') {\n      // try to let sending outgoing data succeed\n      if (this.sendingData != null) {\n        await raceSignal(this.sendingData.promise, options.signal)\n      }\n\n      // stop reading from the source passed to `.sink`\n      this.log.trace('aborting source passed to .sink')\n      this.sinkController.abort()\n      await raceSignal(this.sinkEnd.promise, options.signal)\n    }\n\n    this.writeStatus = 'closed'\n\n    this.log.trace('closed writable end of stream')\n  }\n\n  /**\n   * Close immediately for reading and writing and send a reset message (local\n   * error)\n   */\n  abort (err: Error): void {\n    if (this.status === 'closed' || this.status === 'aborted' || this.status === 'reset') {\n      return\n    }\n\n    this.log('abort with error', err)\n\n    // try to send a reset message\n    this.log('try to send reset to remote')\n    const res = this.sendReset()\n\n    if (isPromise(res)) {\n      res.catch((err) => {\n        this.log.error('error sending reset message', err)\n      })\n    }\n\n    this.status = 'aborted'\n    this.timeline.abort = Date.now()\n    this._closeSinkAndSource(err)\n    this.onAbort?.(err)\n  }\n\n  /**\n   * Receive a reset message - close immediately for reading and writing (remote\n   * error)\n   */\n  reset (): void {\n    if (this.status === 'closed' || this.status === 'aborted' || this.status === 'reset') {\n      return\n    }\n\n    const err = new StreamResetError('stream reset')\n\n    this.status = 'reset'\n    this.timeline.reset = Date.now()\n    this._closeSinkAndSource(err)\n    this.onReset?.()\n  }\n\n  _closeSinkAndSource (err?: Error): void {\n    this._closeSink(err)\n    this._closeSource(err)\n  }\n\n  _closeSink (err?: Error): void {\n    // if the sink function is running, cause it to end\n    if (this.writeStatus === 'writing') {\n      this.log.trace('end sink source')\n      this.sinkController.abort()\n    }\n\n    this.onSinkEnd(err)\n  }\n\n  _closeSource (err?: Error): void {\n    // if the source is not ending, end it\n    if (this.readStatus !== 'closing' && this.readStatus !== 'closed') {\n      this.log.trace('ending source with %d bytes to be read by consumer', this.streamSource.readableLength)\n      this.readStatus = 'closing'\n      this.streamSource.end(err)\n    }\n  }\n\n  /**\n   * The remote closed for writing so we should expect to receive no more\n   * messages\n   */\n  remoteCloseWrite (): void {\n    if (this.readStatus === 'closing' || this.readStatus === 'closed') {\n      this.log('received remote close write but local source is already closed')\n      return\n    }\n\n    this.log.trace('remote close write')\n    this._closeSource()\n  }\n\n  /**\n   * The remote closed for reading so we should not send any more\n   * messages\n   */\n  remoteCloseRead (): void {\n    if (this.writeStatus === 'closing' || this.writeStatus === 'closed') {\n      this.log('received remote close read but local sink is already closed')\n      return\n    }\n\n    this.log.trace('remote close read')\n    this._closeSink()\n  }\n\n  /**\n   * The underlying muxer has closed, no more messages can be sent or will\n   * be received, close immediately to free up resources\n   */\n  destroy (): void {\n    if (this.status === 'closed' || this.status === 'aborted' || this.status === 'reset') {\n      this.log('received destroy but we are already closed')\n      return\n    }\n\n    this.log.trace('stream destroyed')\n\n    this._closeSinkAndSource()\n  }\n\n  /**\n   * When an extending class reads data from it's implementation-specific source,\n   * call this method to allow the stream consumer to read the data.\n   */\n  sourcePush (data: Uint8ArrayList): void {\n    this.streamSource.push(data)\n  }\n\n  /**\n   * Returns the amount of unread data - can be used to prevent large amounts of\n   * data building up when the stream consumer is too slow.\n   */\n  sourceReadableLength (): number {\n    return this.streamSource.readableLength\n  }\n\n  /**\n   * Send a message to the remote muxer informing them a new stream is being\n   * opened\n   */\n  abstract sendNewStream (options?: AbortOptions): void | Promise<void>\n\n  /**\n   * Send a data message to the remote muxer\n   */\n  abstract sendData (buf: Uint8ArrayList, options?: AbortOptions): void | Promise<void>\n\n  /**\n   * Send a reset message to the remote muxer\n   */\n  abstract sendReset (options?: AbortOptions): void | Promise<void>\n\n  /**\n   * Send a message to the remote muxer, informing them no more data messages\n   * will be sent by this end of the stream\n   */\n  abstract sendCloseWrite (options?: AbortOptions): void | Promise<void>\n\n  /**\n   * Send a message to the remote muxer, informing them no more data messages\n   * will be read by this end of the stream\n   */\n  abstract sendCloseRead (options?: AbortOptions): void | Promise<void>\n}\n", "/**\n * @packageDocumentation\n *\n * Lets you look at the contents of an async iterator and decide what to do\n *\n * @example\n *\n * ```javascript\n * import peekable from 'it-peekable'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const it = peekable(value)\n *\n * const first = it.peek()\n *\n * console.info(first) // 0\n *\n * it.push(first)\n *\n * console.info([...it])\n * // [ 0, 1, 2, 3, 4 ]\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import peekable from 'it-peekable'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const it = peekable(values())\n *\n * const first = await it.peek()\n *\n * console.info(first) // 0\n *\n * it.push(first)\n *\n * console.info(await all(it))\n * // [ 0, 1, 2, 3, 4 ]\n * ```\n */\n\nexport interface Peek <T> {\n  peek(): IteratorResult<T, undefined>\n}\n\nexport interface AsyncPeek <T> {\n  peek(): Promise<IteratorResult<T, undefined>>\n}\n\nexport interface Push <T> {\n  push(value: T): void\n}\n\nexport type Peekable <T> = Iterable<T> & Peek<T> & Push<T> & Iterator<T>\n\nexport type AsyncPeekable <T> = AsyncIterable<T> & AsyncPeek<T> & Push<T> & AsyncIterator<T>\n\nfunction peekable <T> (iterable: Iterable<T>): Peekable<T>\nfunction peekable <T> (iterable: AsyncIterable<T>): AsyncPeekable<T>\nfunction peekable <T> (iterable: Iterable<T> | AsyncIterable<T>): Peekable<T> | AsyncPeekable<T> {\n  // @ts-expect-error can't use Symbol.asyncIterator to index iterable since it might be Iterable\n  const [iterator, symbol] = iterable[Symbol.asyncIterator] != null\n    // @ts-expect-error can't use Symbol.asyncIterator to index iterable since it might be Iterable\n    ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator]\n    // @ts-expect-error can't use Symbol.iterator to index iterable since it might be AsyncIterable\n    : [iterable[Symbol.iterator](), Symbol.iterator]\n\n  const queue: any[] = []\n\n  // @ts-expect-error can't use symbol to index peekable\n  return {\n    peek: () => {\n      return iterator.next()\n    },\n    push: (value: any) => {\n      queue.push(value)\n    },\n    next: () => {\n      if (queue.length > 0) {\n        return {\n          done: false,\n          value: queue.shift()\n        }\n      }\n\n      return iterator.next()\n    },\n    [symbol] () {\n      return this\n    }\n  }\n}\n\nexport default peekable\n", "/**\n * @packageDocumentation\n *\n * Calls a function for each value in an (async)iterable.\n *\n * The function can be sync or async.\n *\n * Async functions can be awaited on so may slow down processing of the (async)iterable.\n *\n * @example\n *\n * ```javascript\n * import each from 'it-foreach'\n * import drain from 'it-drain'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * // prints [0, 0], [1, 1], [2, 2], [3, 3], [4, 4]\n * const arr = drain(\n *   each(values, console.info)\n * )\n * ```\n *\n * Async sources and callbacks must be awaited:\n *\n * ```javascript\n * import each from 'it-foreach'\n * import drain from 'it-drain'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * // prints [0, 0], [1, 1], [2, 2], [3, 3], [4, 4]\n * const arr = await drain(\n *   each(values(), console.info)\n * )\n * ```\n */\n\nimport peek from 'it-peekable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\nfunction isPromise <T = unknown> (thing: any): thing is Promise<T> {\n  return thing?.then != null\n}\n\n/**\n * Invokes the passed function for each item in an iterable\n */\nfunction forEach <T> (source: Iterable<T>, fn: (thing: T, index: number) => Promise<void>): AsyncGenerator<T, void, undefined>\nfunction forEach <T> (source: Iterable<T>, fn: (thing: T, index: number) => void): Generator<T, void, undefined>\nfunction forEach <T> (source: Iterable<T> | AsyncIterable<T>, fn: (thing: T, index: number) => void | Promise<void>): AsyncGenerator<T, void, undefined>\nfunction forEach <T> (source: Iterable<T> | AsyncIterable<T>, fn: (thing: T, index: number) => void | Promise<void>): AsyncGenerator<T, void, undefined> | Generator<T, void, undefined> {\n  let index = 0\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const val of source) {\n        const res = fn(val, index++)\n\n        if (isPromise(res)) {\n          await res\n        }\n\n        yield val\n      }\n    })()\n  }\n\n  // if fn function returns a promise we have to return an async generator\n  const peekable = peek(source)\n  const { value, done } = peekable.next()\n\n  if (done === true) {\n    return (function * () {}())\n  }\n\n  const res = fn(value, index++)\n\n  if (typeof res?.then === 'function') {\n    return (async function * () {\n      yield value\n\n      for (const val of peekable) {\n        const res = fn(val, index++)\n\n        if (isPromise(res)) {\n          await res\n        }\n\n        yield val\n      }\n    })()\n  }\n\n  const func = fn as (val: T, index: number) => void\n\n  return (function * () {\n    yield value\n\n    for (const val of peekable) {\n      func(val, index++)\n      yield val\n    }\n  })()\n}\n\nexport default forEach\n", "import { AbortError } from '@libp2p/interface'\nimport { AbstractStream } from '@libp2p/utils/abstract-stream'\nimport each from 'it-foreach'\nimport { INITIAL_STREAM_WINDOW } from './constants.js'\nimport { ReceiveWindowExceededError } from './errors.js'\nimport { Flag, FrameType, HEADER_LENGTH } from './frame.js'\nimport type { Config } from './config.js'\nimport type { FrameHeader } from './frame.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { AbstractStreamInit } from '@libp2p/utils/abstract-stream'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport enum StreamState {\n  Init,\n  SYNSent,\n  SYNReceived,\n  Established,\n  Finished\n}\n\nexport interface YamuxStreamInit extends AbstractStreamInit {\n  name?: string\n  sendFrame(header: FrameHeader, body?: Uint8ArrayList): void\n  getRTT(): number\n  config: Config\n  state: StreamState\n}\n\n/** YamuxStream is used to represent a logical stream within a session */\nexport class YamuxStream extends AbstractStream {\n  name?: string\n  state: StreamState\n\n  private readonly config: Config\n  private readonly _id: number\n\n  /** The number of available bytes to send */\n  private sendWindowCapacity: number\n  /** Callback to notify that the sendWindowCapacity has been updated */\n  private sendWindowCapacityUpdate?: () => void\n\n  /** The number of bytes available to receive in a full window */\n  private recvWindow: number\n  /** The number of available bytes to receive */\n  private recvWindowCapacity: number\n\n  /**\n   * An 'epoch' is the time it takes to process and read data\n   *\n   * Used in conjunction with RTT to determine whether to increase the recvWindow\n   */\n  private epochStart: number\n  private readonly getRTT: () => number\n\n  private readonly sendFrame: (header: FrameHeader, body?: Uint8ArrayList) => void\n\n  constructor (init: YamuxStreamInit) {\n    super({\n      ...init,\n      onEnd: (err?: Error) => {\n        this.state = StreamState.Finished\n        init.onEnd?.(err)\n      }\n    })\n\n    this.config = init.config\n    this._id = parseInt(init.id, 10)\n    this.name = init.name\n    this.state = init.state\n    this.sendWindowCapacity = INITIAL_STREAM_WINDOW\n    this.recvWindow = this.config.initialStreamWindowSize\n    this.recvWindowCapacity = this.recvWindow\n    this.epochStart = Date.now()\n    this.getRTT = init.getRTT\n\n    this.sendFrame = init.sendFrame\n\n    this.source = each(this.source, () => {\n      this.sendWindowUpdate()\n    })\n  }\n\n  /**\n   * Send a message to the remote muxer informing them a new stream is being\n   * opened.\n   *\n   * This is a noop for Yamux because the first window update is sent when\n   * .newStream is called on the muxer which opens the stream on the remote.\n   */\n  async sendNewStream (): Promise<void> {\n\n  }\n\n  /**\n   * Send a data message to the remote muxer\n   */\n  async sendData (buf: Uint8ArrayList, options: AbortOptions = {}): Promise<void> {\n    buf = buf.sublist()\n\n    // send in chunks, waiting for window updates\n    while (buf.byteLength !== 0) {\n      // wait for the send window to refill\n      if (this.sendWindowCapacity === 0) {\n        this.log?.trace('wait for send window capacity, status %s', this.status)\n        await this.waitForSendWindowCapacity(options)\n\n        // check we didn't close while waiting for send window capacity\n        if (this.status === 'closed' || this.status === 'aborted' || this.status === 'reset') {\n          this.log?.trace('%s while waiting for send window capacity', this.status)\n          return\n        }\n      }\n\n      // send as much as we can\n      const toSend = Math.min(this.sendWindowCapacity, this.config.maxMessageSize - HEADER_LENGTH, buf.length)\n      const flags = this.getSendFlags()\n\n      this.sendFrame({\n        type: FrameType.Data,\n        flag: flags,\n        streamID: this._id,\n        length: toSend\n      }, buf.sublist(0, toSend))\n\n      this.sendWindowCapacity -= toSend\n\n      buf.consume(toSend)\n    }\n  }\n\n  /**\n   * Send a reset message to the remote muxer\n   */\n  async sendReset (): Promise<void> {\n    this.sendFrame({\n      type: FrameType.WindowUpdate,\n      flag: Flag.RST,\n      streamID: this._id,\n      length: 0\n    })\n  }\n\n  /**\n   * Send a message to the remote muxer, informing them no more data messages\n   * will be sent by this end of the stream\n   */\n  async sendCloseWrite (): Promise<void> {\n    const flags = this.getSendFlags() | Flag.FIN\n    this.sendFrame({\n      type: FrameType.WindowUpdate,\n      flag: flags,\n      streamID: this._id,\n      length: 0\n    })\n  }\n\n  /**\n   * Send a message to the remote muxer, informing them no more data messages\n   * will be read by this end of the stream\n   */\n  async sendCloseRead (): Promise<void> {\n\n  }\n\n  /**\n   * Wait for the send window to be non-zero\n   *\n   * Will throw with ERR_STREAM_ABORT if the stream gets aborted\n   */\n  async waitForSendWindowCapacity (options: AbortOptions = {}): Promise<void> {\n    if (this.sendWindowCapacity > 0) {\n      return\n    }\n\n    let resolve: () => void\n    let reject: (err: Error) => void\n    const abort = (): void => {\n      if (this.status === 'open' || this.status === 'closing') {\n        reject(new AbortError('Stream aborted'))\n      } else {\n        // the stream was closed already, ignore the failure to send\n        resolve()\n      }\n    }\n    options.signal?.addEventListener('abort', abort)\n\n    try {\n      await new Promise<void>((_resolve, _reject) => {\n        this.sendWindowCapacityUpdate = () => {\n          _resolve()\n        }\n        reject = _reject\n        resolve = _resolve\n      })\n    } finally {\n      options.signal?.removeEventListener('abort', abort)\n    }\n  }\n\n  /**\n   * handleWindowUpdate is called when the stream receives a window update frame\n   */\n  handleWindowUpdate (header: FrameHeader): void {\n    this.log?.trace('stream received window update id=%s', this._id)\n    this.processFlags(header.flag)\n\n    // increase send window\n    const available = this.sendWindowCapacity\n    this.sendWindowCapacity += header.length\n    // if the update increments a 0 availability, notify the stream that sending can resume\n    if (available === 0 && header.length > 0) {\n      this.sendWindowCapacityUpdate?.()\n    }\n  }\n\n  /**\n   * handleData is called when the stream receives a data frame\n   */\n  async handleData (header: FrameHeader, readData: () => Promise<Uint8ArrayList>): Promise<void> {\n    this.log?.trace('stream received data id=%s', this._id)\n    this.processFlags(header.flag)\n\n    // check that our recv window is not exceeded\n    if (this.recvWindowCapacity < header.length) {\n      throw new ReceiveWindowExceededError('Receive window exceeded')\n    }\n\n    const data = await readData()\n    this.recvWindowCapacity -= header.length\n\n    this.sourcePush(data)\n  }\n\n  /**\n   * processFlags is used to update the state of the stream based on set flags, if any.\n   */\n  private processFlags (flags: number): void {\n    if ((flags & Flag.ACK) === Flag.ACK) {\n      if (this.state === StreamState.SYNSent) {\n        this.state = StreamState.Established\n      }\n    }\n    if ((flags & Flag.FIN) === Flag.FIN) {\n      this.remoteCloseWrite()\n    }\n    if ((flags & Flag.RST) === Flag.RST) {\n      this.reset()\n    }\n  }\n\n  /**\n   * getSendFlags determines any flags that are appropriate\n   * based on the current stream state.\n   *\n   * The state is updated as a side-effect.\n   */\n  private getSendFlags (): number {\n    switch (this.state) {\n      case StreamState.Init:\n        this.state = StreamState.SYNSent\n        return Flag.SYN\n      case StreamState.SYNReceived:\n        this.state = StreamState.Established\n        return Flag.ACK\n      default:\n        return 0\n    }\n  }\n\n  /**\n   * potentially sends a window update enabling further writes to take place.\n   */\n  sendWindowUpdate (): void {\n    // determine the flags if any\n    const flags = this.getSendFlags()\n\n    // If the stream has already been established\n    // and we've processed data within the time it takes for 4 round trips\n    // then we (up to) double the recvWindow\n    const now = Date.now()\n    const rtt = this.getRTT()\n    if (flags === 0 && rtt > -1 && now - this.epochStart < rtt * 4) {\n      // we've already validated that maxStreamWindowSize can't be more than MAX_UINT32\n      this.recvWindow = Math.min(this.recvWindow * 2, this.config.maxStreamWindowSize)\n    }\n\n    if (this.recvWindowCapacity >= this.recvWindow && flags === 0) {\n      // a window update isn't needed\n      return\n    }\n\n    // update the receive window\n    const delta = this.recvWindow - this.recvWindowCapacity\n    this.recvWindowCapacity = this.recvWindow\n\n    // update the epoch start\n    this.epochStart = now\n\n    // send window update\n    this.sendFrame({\n      type: FrameType.WindowUpdate,\n      flag: flags,\n      streamID: this._id,\n      length: delta\n    })\n  }\n}\n", "import { InvalidParametersError, MuxerClosedError, TooManyOutboundProtocolStreamsError, serviceCapabilities, setMaxListeners } from '@libp2p/interface'\nimport { getIterator } from 'get-iterator'\nimport { pushable } from 'it-pushable'\nimport { raceSignal } from 'race-signal'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { defaultConfig, verifyConfig } from './config.js'\nimport { PROTOCOL_ERRORS } from './constants.js'\nimport { Decoder } from './decode.js'\nimport { encodeHeader } from './encode.js'\nimport { InvalidFrameError, NotMatchingPingError, UnrequestedPingError } from './errors.js'\nimport { Flag, FrameType, GoAwayCode } from './frame.js'\nimport { StreamState, YamuxStream } from './stream.js'\nimport type { Config } from './config.js'\nimport type { FrameHeader } from './frame.js'\nimport type { YamuxMuxerComponents } from './index.js'\nimport type { AbortOptions, ComponentLogger, Logger, Stream, StreamMuxer, StreamMuxerFactory, StreamMuxerInit } from '@libp2p/interface'\nimport type { Pushable } from 'it-pushable'\nimport type { Sink, Source } from 'it-stream-types'\n\nconst YAMUX_PROTOCOL_ID = '/yamux/1.0.0'\nconst CLOSE_TIMEOUT = 500\n\nexport interface YamuxMuxerInit extends StreamMuxerInit, Partial<Config> {\n}\n\nexport class Yamux implements StreamMuxerFactory {\n  protocol = YAMUX_PROTOCOL_ID\n  private readonly _components: YamuxMuxerComponents\n  private readonly _init: YamuxMuxerInit\n\n  constructor (components: YamuxMuxerComponents, init: YamuxMuxerInit = {}) {\n    this._components = components\n    this._init = init\n  }\n\n  readonly [Symbol.toStringTag] = '@chainsafe/libp2p-yamux'\n\n  readonly [serviceCapabilities]: string[] = [\n    '@libp2p/stream-multiplexing'\n  ]\n\n  createStreamMuxer (init?: YamuxMuxerInit): YamuxMuxer {\n    return new YamuxMuxer(this._components, {\n      ...this._init,\n      ...init\n    })\n  }\n}\n\nexport interface CloseOptions extends AbortOptions {\n  reason?: GoAwayCode\n}\n\nexport class YamuxMuxer implements StreamMuxer {\n  protocol = YAMUX_PROTOCOL_ID\n  source: Pushable<Uint8ArrayList | Uint8Array>\n  sink: Sink<Source<Uint8ArrayList | Uint8Array>, Promise<void>>\n\n  private readonly config: Config\n  private readonly log?: Logger\n  private readonly logger: ComponentLogger\n\n  /** Used to close the muxer from either the sink or source */\n  private readonly closeController: AbortController\n\n  /** The next stream id to be used when initiating a new stream */\n  private nextStreamID: number\n  /** Primary stream mapping, streamID => stream */\n  private readonly _streams: Map<number, YamuxStream>\n\n  /** The next ping id to be used when pinging */\n  private nextPingID: number\n  /** Tracking info for the currently active ping */\n  private activePing?: { id: number, promise: Promise<void>, resolve(): void }\n  /** Round trip time */\n  private rtt: number\n\n  /** True if client, false if server */\n  private readonly client: boolean\n\n  private localGoAway?: GoAwayCode\n  private remoteGoAway?: GoAwayCode\n\n  /** Number of tracked inbound streams */\n  private numInboundStreams: number\n  /** Number of tracked outbound streams */\n  private numOutboundStreams: number\n\n  private readonly onIncomingStream?: (stream: Stream) => void\n  private readonly onStreamEnd?: (stream: Stream) => void\n\n  constructor (components: YamuxMuxerComponents, init: YamuxMuxerInit) {\n    this.client = init.direction === 'outbound'\n    this.config = { ...defaultConfig, ...init }\n    this.logger = components.logger\n    this.log = this.logger.forComponent('libp2p:yamux')\n    verifyConfig(this.config)\n\n    this.closeController = new AbortController()\n    setMaxListeners(Infinity, this.closeController.signal)\n\n    this.onIncomingStream = init.onIncomingStream\n    this.onStreamEnd = init.onStreamEnd\n\n    this._streams = new Map()\n\n    this.source = pushable({\n      onEnd: (): void => {\n        this.log?.trace('muxer source ended')\n\n        this._streams.forEach(stream => {\n          stream.destroy()\n        })\n      }\n    })\n\n    this.sink = async (source: Source<Uint8ArrayList | Uint8Array>): Promise<void> => {\n      const shutDownListener = (): void => {\n        const iterator = getIterator(source)\n\n        if (iterator.return != null) {\n          const res = iterator.return()\n\n          if (isPromise(res)) {\n            res.catch(err => {\n              this.log?.('could not cause sink source to return', err)\n            })\n          }\n        }\n      }\n\n      let reason, error\n      try {\n        const decoder = new Decoder(source)\n\n        try {\n          this.closeController.signal.addEventListener('abort', shutDownListener)\n\n          for await (const frame of decoder.emitFrames()) {\n            await this.handleFrame(frame.header, frame.readData)\n          }\n        } finally {\n          this.closeController.signal.removeEventListener('abort', shutDownListener)\n        }\n\n        reason = GoAwayCode.NormalTermination\n      } catch (err: any) {\n        // either a protocol or internal error\n        if (PROTOCOL_ERRORS.has(err.name)) {\n          this.log?.error('protocol error in sink', err)\n          reason = GoAwayCode.ProtocolError\n        } else {\n          this.log?.error('internal error in sink', err)\n          reason = GoAwayCode.InternalError\n        }\n\n        error = err as Error\n      }\n\n      this.log?.trace('muxer sink ended')\n\n      if (error != null) {\n        this.abort(error, reason)\n      } else {\n        await this.close({ reason })\n      }\n    }\n\n    this.numInboundStreams = 0\n    this.numOutboundStreams = 0\n\n    // client uses odd streamIDs, server uses even streamIDs\n    this.nextStreamID = this.client ? 1 : 2\n\n    this.nextPingID = 0\n    this.rtt = -1\n\n    this.log?.trace('muxer created')\n\n    if (this.config.enableKeepAlive) {\n      this.keepAliveLoop().catch(e => this.log?.error('keepalive error: %s', e))\n    }\n\n    // send an initial ping to establish RTT\n    this.ping().catch(e => this.log?.error('ping error: %s', e))\n  }\n\n  get streams (): YamuxStream[] {\n    return Array.from(this._streams.values())\n  }\n\n  newStream (name?: string | undefined): YamuxStream {\n    if (this.remoteGoAway !== undefined) {\n      throw new MuxerClosedError('Muxer closed remotely')\n    }\n    if (this.localGoAway !== undefined) {\n      throw new MuxerClosedError('Muxer closed locally')\n    }\n\n    const id = this.nextStreamID\n    this.nextStreamID += 2\n\n    // check against our configured maximum number of outbound streams\n    if (this.numOutboundStreams >= this.config.maxOutboundStreams) {\n      throw new TooManyOutboundProtocolStreamsError('max outbound streams exceeded')\n    }\n\n    this.log?.trace('new outgoing stream id=%s', id)\n\n    const stream = this._newStream(id, name, StreamState.Init, 'outbound')\n    this._streams.set(id, stream)\n\n    this.numOutboundStreams++\n\n    // send a window update to open the stream on the receiver end\n    stream.sendWindowUpdate()\n\n    return stream\n  }\n\n  /**\n   * Initiate a ping and wait for a response\n   *\n   * Note: only a single ping will be initiated at a time.\n   * If a ping is already in progress, a new ping will not be initiated.\n   *\n   * @returns the round-trip-time in milliseconds\n   */\n  async ping (): Promise<number> {\n    if (this.remoteGoAway !== undefined) {\n      throw new MuxerClosedError('Muxer closed remotely')\n    }\n    if (this.localGoAway !== undefined) {\n      throw new MuxerClosedError('Muxer closed locally')\n    }\n\n    // An active ping does not yet exist, handle the process here\n    if (this.activePing === undefined) {\n      // create active ping\n      let _resolve = (): void => {}\n      this.activePing = {\n        id: this.nextPingID++,\n        // this promise awaits resolution or the close controller aborting\n        promise: new Promise<void>((resolve, reject) => {\n          const closed = (): void => {\n            reject(new MuxerClosedError('Muxer closed locally'))\n          }\n          this.closeController.signal.addEventListener('abort', closed, { once: true })\n          _resolve = (): void => {\n            this.closeController.signal.removeEventListener('abort', closed)\n            resolve()\n          }\n        }),\n        resolve: _resolve\n      }\n      // send ping\n      const start = Date.now()\n      this.sendPing(this.activePing.id)\n      // await pong\n      try {\n        await this.activePing.promise\n      } finally {\n        // clean-up active ping\n        delete this.activePing\n      }\n      // update rtt\n      const end = Date.now()\n      this.rtt = end - start\n    } else {\n      // an active ping is already in progress, piggyback off that\n      await this.activePing.promise\n    }\n    return this.rtt\n  }\n\n  /**\n   * Get the ping round trip time\n   *\n   * Note: Will return 0 if no successful ping has yet been completed\n   *\n   * @returns the round-trip-time in milliseconds\n   */\n  getRTT (): number {\n    return this.rtt\n  }\n\n  /**\n   * Close the muxer\n   */\n  async close (options: CloseOptions = {}): Promise<void> {\n    if (this.closeController.signal.aborted) {\n      // already closed\n      return\n    }\n\n    const reason = options?.reason ?? GoAwayCode.NormalTermination\n\n    this.log?.trace('muxer close reason=%s', reason)\n\n    if (options.signal == null) {\n      const signal = AbortSignal.timeout(CLOSE_TIMEOUT)\n      setMaxListeners(Infinity, signal)\n\n      options = {\n        ...options,\n        signal\n      }\n    }\n\n    try {\n      await Promise.all(\n        [...this._streams.values()].map(async s => s.close(options))\n      )\n\n      // send reason to the other side, allow the other side to close gracefully\n      this.sendGoAway(reason)\n\n      this._closeMuxer()\n    } catch (err: any) {\n      this.abort(err)\n    }\n  }\n\n  abort (err: Error, reason?: GoAwayCode): void {\n    if (this.closeController.signal.aborted) {\n      // already closed\n      return\n    }\n\n    reason = reason ?? GoAwayCode.InternalError\n\n    // If reason was provided, use that, otherwise use the presence of `err` to determine the reason\n    this.log?.error('muxer abort reason=%s error=%s', reason, err)\n\n    // Abort all underlying streams\n    for (const stream of this._streams.values()) {\n      stream.abort(err)\n    }\n\n    // send reason to the other side, allow the other side to close gracefully\n    this.sendGoAway(reason)\n\n    this._closeMuxer()\n  }\n\n  isClosed (): boolean {\n    return this.closeController.signal.aborted\n  }\n\n  /**\n   * Called when either the local or remote shuts down the muxer\n   */\n  private _closeMuxer (): void {\n    // stop the sink and any other processes\n    this.closeController.abort()\n\n    // stop the source\n    this.source.end()\n  }\n\n  /** Create a new stream */\n  private _newStream (id: number, name: string | undefined, state: StreamState, direction: 'inbound' | 'outbound'): YamuxStream {\n    if (this._streams.get(id) != null) {\n      throw new InvalidParametersError('Stream already exists with that id')\n    }\n\n    const stream = new YamuxStream({\n      id: id.toString(),\n      name,\n      state,\n      direction,\n      sendFrame: this.sendFrame.bind(this),\n      onEnd: () => {\n        this.closeStream(id)\n        this.onStreamEnd?.(stream)\n      },\n      log: this.logger.forComponent(`libp2p:yamux:${direction}:${id}`),\n      config: this.config,\n      getRTT: this.getRTT.bind(this)\n    })\n\n    return stream\n  }\n\n  /**\n   * closeStream is used to close a stream once both sides have\n   * issued a close.\n   */\n  private closeStream (id: number): void {\n    if (this.client === (id % 2 === 0)) {\n      this.numInboundStreams--\n    } else {\n      this.numOutboundStreams--\n    }\n    this._streams.delete(id)\n  }\n\n  private async keepAliveLoop (): Promise<void> {\n    this.log?.trace('muxer keepalive enabled interval=%s', this.config.keepAliveInterval)\n    while (true) {\n      let timeoutId\n      try {\n        await raceSignal(\n          new Promise((resolve) => {\n            timeoutId = setTimeout(resolve, this.config.keepAliveInterval)\n          }),\n          this.closeController.signal\n        )\n        this.ping().catch(e => this.log?.error('ping error: %s', e))\n      } catch (e) {\n        // closed\n        clearInterval(timeoutId)\n        return\n      }\n    }\n  }\n\n  private async handleFrame (header: FrameHeader, readData?: () => Promise<Uint8ArrayList>): Promise<void> {\n    const {\n      streamID,\n      type,\n      length\n    } = header\n    this.log?.trace('received frame %o', header)\n\n    if (streamID === 0) {\n      switch (type) {\n        case FrameType.Ping:\n        { this.handlePing(header); return }\n        case FrameType.GoAway:\n        { this.handleGoAway(length); return }\n        default:\n          // Invalid state\n          throw new InvalidFrameError('Invalid frame type')\n      }\n    } else {\n      switch (header.type) {\n        case FrameType.Data:\n        case FrameType.WindowUpdate:\n        { await this.handleStreamMessage(header, readData); return }\n        default:\n          // Invalid state\n          throw new InvalidFrameError('Invalid frame type')\n      }\n    }\n  }\n\n  private handlePing (header: FrameHeader): void {\n    // If the ping  is initiated by the sender, send a response\n    if (header.flag === Flag.SYN) {\n      this.log?.trace('received ping request pingId=%s', header.length)\n      this.sendPing(header.length, Flag.ACK)\n    } else if (header.flag === Flag.ACK) {\n      this.log?.trace('received ping response pingId=%s', header.length)\n      this.handlePingResponse(header.length)\n    } else {\n      // Invalid state\n      throw new InvalidFrameError('Invalid frame flag')\n    }\n  }\n\n  private handlePingResponse (pingId: number): void {\n    if (this.activePing === undefined) {\n      // this ping was not requested\n      throw new UnrequestedPingError('ping not requested')\n    }\n    if (this.activePing.id !== pingId) {\n      // this ping doesn't match our active ping request\n      throw new NotMatchingPingError('ping doesn\\'t match our id')\n    }\n\n    // valid ping response\n    this.activePing.resolve()\n  }\n\n  private handleGoAway (reason: GoAwayCode): void {\n    this.log?.trace('received GoAway reason=%s', GoAwayCode[reason] ?? 'unknown')\n    this.remoteGoAway = reason\n\n    // If the other side is friendly, they would have already closed all streams before sending a GoAway\n    // In case they weren't, reset all streams\n    for (const stream of this._streams.values()) {\n      stream.reset()\n    }\n\n    this._closeMuxer()\n  }\n\n  private async handleStreamMessage (header: FrameHeader, readData?: () => Promise<Uint8ArrayList>): Promise<void> {\n    const { streamID, flag, type } = header\n\n    if ((flag & Flag.SYN) === Flag.SYN) {\n      this.incomingStream(streamID)\n    }\n\n    const stream = this._streams.get(streamID)\n    if (stream === undefined) {\n      if (type === FrameType.Data) {\n        this.log?.('discarding data for stream id=%s', streamID)\n        if (readData === undefined) {\n          throw new Error('unreachable')\n        }\n        await readData()\n      } else {\n        this.log?.trace('frame for missing stream id=%s', streamID)\n      }\n      return\n    }\n\n    switch (type) {\n      case FrameType.WindowUpdate: {\n        stream.handleWindowUpdate(header); return\n      }\n      case FrameType.Data: {\n        if (readData === undefined) {\n          throw new Error('unreachable')\n        }\n\n        await stream.handleData(header, readData); return\n      }\n      default:\n        throw new Error('unreachable')\n    }\n  }\n\n  private incomingStream (id: number): void {\n    if (this.client !== (id % 2 === 0)) {\n      throw new InvalidParametersError('Both endpoints are clients')\n    }\n    if (this._streams.has(id)) {\n      return\n    }\n\n    this.log?.trace('new incoming stream id=%s', id)\n\n    if (this.localGoAway !== undefined) {\n      // reject (reset) immediately if we are doing a go away\n      this.sendFrame({\n        type: FrameType.WindowUpdate,\n        flag: Flag.RST,\n        streamID: id,\n        length: 0\n      }); return\n    }\n\n    // check against our configured maximum number of inbound streams\n    if (this.numInboundStreams >= this.config.maxInboundStreams) {\n      this.log?.('maxIncomingStreams exceeded, forcing stream reset')\n      this.sendFrame({\n        type: FrameType.WindowUpdate,\n        flag: Flag.RST,\n        streamID: id,\n        length: 0\n      }); return\n    }\n\n    // allocate a new stream\n    const stream = this._newStream(id, undefined, StreamState.SYNReceived, 'inbound')\n\n    this.numInboundStreams++\n    // the stream should now be tracked\n    this._streams.set(id, stream)\n\n    this.onIncomingStream?.(stream)\n  }\n\n  private sendFrame (header: FrameHeader, data?: Uint8ArrayList): void {\n    this.log?.trace('sending frame %o', header)\n    if (header.type === FrameType.Data) {\n      if (data === undefined) {\n        throw new InvalidFrameError('Invalid frame')\n      }\n      this.source.push(\n        new Uint8ArrayList(encodeHeader(header), data)\n      )\n    } else {\n      this.source.push(encodeHeader(header))\n    }\n  }\n\n  private sendPing (pingId: number, flag: Flag = Flag.SYN): void {\n    if (flag === Flag.SYN) {\n      this.log?.trace('sending ping request pingId=%s', pingId)\n    } else {\n      this.log?.trace('sending ping response pingId=%s', pingId)\n    }\n    this.sendFrame({\n      type: FrameType.Ping,\n      flag,\n      streamID: 0,\n      length: pingId\n    })\n  }\n\n  private sendGoAway (reason: GoAwayCode = GoAwayCode.NormalTermination): void {\n    this.log?.('sending GoAway reason=%s', GoAwayCode[reason])\n    this.localGoAway = reason\n    this.sendFrame({\n      type: FrameType.GoAway,\n      flag: 0,\n      streamID: 0,\n      length: reason\n    })\n  }\n}\n\nfunction isPromise <T = unknown> (thing: any): thing is Promise<T> {\n  return thing != null && typeof thing.then === 'function'\n}\n"],
+  "mappings": "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",
+  "names": ["index_exports", "__export", "GoAwayCode", "yamux", "AbortError", "message", "InvalidParametersError", "message", "MuxerClosedError", "message", "StreamResetError", "StreamStateError", "TooManyOutboundProtocolStreamsError", "message", "serviceCapabilities", "serviceDependencies", "getIterator", "obj", "pDefer", "deferred", "resolve", "reject", "FixedFIFO", "hwm", "data", "last", "FIFO", "options", "obj", "val", "prev", "next", "AbortError", "message", "code", "pushable", "options", "_pushable", "buffer", "next", "_pushable", "getNext", "options", "onEnd", "buffer", "FIFO", "pushable", "onNext", "ended", "drain", "pDefer", "waitNext", "resolve", "reject", "next", "err", "bufferNext", "bufferError", "push", "value", "end", "_return", "_throw", "signal", "cancel", "listener", "AbortError", "opts", "AbortError", "message", "code", "name", "raceSignal", "promise", "signal", "opts", "listener", "error", "resolve", "reject", "alloc", "size", "allocUnsafe", "concat", "arrays", "length", "acc", "curr", "output", "allocUnsafe", "offset", "arr", "equals", "a", "b", "i", "symbol", "findBufAndOffset", "bufs", "index", "offset", "buf", "bufEnd", "isUint8ArrayList", "value", "Uint8ArrayList", "_Uint8ArrayList", "data", "length", "res", "i", "bytes", "beginInclusive", "endExclusive", "concat", "list", "bufStart", "sliceStartInBuf", "sliceEndsInBuf", "start", "search", "needle", "M", "radix", "rightmostPositions", "c", "j", "right", "lastIndex", "lastPatIndex", "skip", "char", "byteOffset", "allocUnsafe", "littleEndian", "alloc", "other", "equals", "acc", "curr", "InvalidFrameError", "message", "UnrequestedPingError", "NotMatchingPingError", "InvalidStateError", "StreamAlreadyExistsError", "DecodeInvalidVersionError", "BothClientsError", "ReceiveWindowExceededError", "PROTOCOL_ERRORS", "InvalidFrameError", "UnrequestedPingError", "NotMatchingPingError", "StreamAlreadyExistsError", "DecodeInvalidVersionError", "BothClientsError", "ReceiveWindowExceededError", "INITIAL_STREAM_WINDOW", "MAX_STREAM_WINDOW", "defaultConfig", "INITIAL_STREAM_WINDOW", "MAX_STREAM_WINDOW", "verifyConfig", "config", "InvalidParametersError", "FrameType", "Flag", "flagCodes", "x", "YAMUX_VERSION", "GoAwayCode", "HEADER_LENGTH", "twoPow24", "decodeHeader", "data", "YAMUX_VERSION", "InvalidFrameError", "Decoder", "source", "returnlessSource", "Uint8ArrayList", "chunk", "header", "type", "length", "FrameType", "InvalidStateError", "HEADER_LENGTH", "out", "iterator", "encodeHeader", "header", "frame", "HEADER_LENGTH", "isPromise", "thing", "closeSource", "source", "log", "res", "getIterator", "isPromise", "err", "DEFAULT_SEND_CLOSE_WRITE_TIMEOUT", "isPromise", "thing", "AbstractStream", "init", "pDefer", "pushable", "err", "source", "StreamStateError", "options", "res", "abortListener", "closeSource", "data", "Uint8ArrayList", "raceSignal", "readStatus", "StreamResetError", "peekable", "iterable", "iterator", "symbol", "queue", "value", "src_default", "isAsyncIterable", "thing", "isPromise", "forEach", "source", "fn", "index", "val", "res", "peekable", "src_default", "value", "done", "func", "StreamState", "YamuxStream", "AbstractStream", "init", "err", "INITIAL_STREAM_WINDOW", "src_default", "buf", "options", "toSend", "HEADER_LENGTH", "flags", "FrameType", "Flag", "resolve", "reject", "abort", "AbortError", "_resolve", "_reject", "header", "available", "readData", "ReceiveWindowExceededError", "data", "now", "rtt", "delta", "YAMUX_PROTOCOL_ID", "CLOSE_TIMEOUT", "Yamux", "components", "init", "serviceCapabilities", "YamuxMuxer", "defaultConfig", "verifyConfig", "pushable", "stream", "source", "shutDownListener", "iterator", "getIterator", "res", "isPromise", "err", "reason", "error", "decoder", "Decoder", "frame", "GoAwayCode", "PROTOCOL_ERRORS", "e", "name", "MuxerClosedError", "id", "TooManyOutboundProtocolStreamsError", "StreamState", "_resolve", "resolve", "reject", "closed", "start", "end", "options", "signal", "s", "state", "direction", "InvalidParametersError", "YamuxStream", "timeoutId", "raceSignal", "header", "readData", "streamID", "type", "length", "FrameType", "InvalidFrameError", "Flag", "pingId", "UnrequestedPingError", "NotMatchingPingError", "flag", "data", "Uint8ArrayList", "encodeHeader", "thing", "yamux", "init", "components", "Yamux"]
 }
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/src/muxer.d.ts.map b/node_modules/@chainsafe/libp2p-yamux/dist/src/muxer.d.ts.map
index c3b4f53..21e3e99 100644
--- a/node_modules/@chainsafe/libp2p-yamux/dist/src/muxer.d.ts.map
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/src/muxer.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"muxer.d.ts","sourceRoot":"","sources":["../../src/muxer.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"muxer.d.ts","sourceRoot":"","sources":["../../src/muxer.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/src/muxer.js b/node_modules/@chainsafe/libp2p-yamux/dist/src/muxer.js
index a1af6b9..f025022 100644
--- a/node_modules/@chainsafe/libp2p-yamux/dist/src/muxer.js
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/src/muxer.js
@@ -1,6 +1,7 @@
 import { InvalidParametersError, MuxerClosedError, TooManyOutboundProtocolStreamsError, serviceCapabilities, setMaxListeners } from '@libp2p/interface';
 import { getIterator } from 'get-iterator';
 import { pushable } from 'it-pushable';
+import { raceSignal } from 'race-signal';
 import { Uint8ArrayList } from 'uint8arraylist';
 import { defaultConfig, verifyConfig } from './config.js';
 import { PROTOCOL_ERRORS } from './constants.js';
@@ -317,17 +318,13 @@ export class YamuxMuxer {
         this._streams.delete(id);
     }
     async keepAliveLoop() {
-        const abortPromise = new Promise((_resolve, reject) => { this.closeController.signal.addEventListener('abort', reject, { once: true }); });
         this.log?.trace('muxer keepalive enabled interval=%s', this.config.keepAliveInterval);
         while (true) {
             let timeoutId;
             try {
-                await Promise.race([
-                    abortPromise,
-                    new Promise((resolve) => {
-                        timeoutId = setTimeout(resolve, this.config.keepAliveInterval);
-                    })
-                ]);
+                await raceSignal(new Promise((resolve) => {
+                    timeoutId = setTimeout(resolve, this.config.keepAliveInterval);
+                }), this.closeController.signal);
                 this.ping().catch(e => this.log?.error('ping error: %s', e));
             }
             catch (e) {
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/src/muxer.js.map b/node_modules/@chainsafe/libp2p-yamux/dist/src/muxer.js.map
index fe325f5..e5a08e6 100644
--- a/node_modules/@chainsafe/libp2p-yamux/dist/src/muxer.js.map
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/src/muxer.js.map
@@ -1 +1 @@
-{"version":3,"file":"muxer.js","sourceRoot":"","sources":["../../src/muxer.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"muxer.js","sourceRoot":"","sources":["../../src/muxer.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/bench/codec.bench.d.ts b/node_modules/@chainsafe/libp2p-yamux/dist/test/bench/codec.bench.d.ts
new file mode 100644
index 0000000..b4e5636
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/bench/codec.bench.d.ts
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=codec.bench.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/bench/codec.bench.d.ts.map b/node_modules/@chainsafe/libp2p-yamux/dist/test/bench/codec.bench.d.ts.map
new file mode 100644
index 0000000..73758eb
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/bench/codec.bench.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"codec.bench.d.ts","sourceRoot":"","sources":["../../../test/bench/codec.bench.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/bench/codec.bench.js b/node_modules/@chainsafe/libp2p-yamux/dist/test/bench/codec.bench.js
new file mode 100644
index 0000000..84f5ae8
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/bench/codec.bench.js
@@ -0,0 +1,46 @@
+import { itBench } from '@dapplion/benchmark';
+import { decodeHeader } from '../../src/decode.js';
+import { encodeHeader } from '../../src/encode.js';
+import { Flag, FrameType } from '../../src/frame.js';
+import { decodeHeaderNaive, encodeHeaderNaive } from '../codec.util.js';
+describe('codec benchmark', () => {
+    for (const { encode, name } of [
+        { encode: encodeHeader, name: 'encodeFrameHeader' },
+        { encode: encodeHeaderNaive, name: 'encodeFrameHeaderNaive' }
+    ]) {
+        itBench({
+            id: `frame header - ${name}`,
+            timeoutBench: 100000000,
+            beforeEach: () => {
+                return {
+                    type: FrameType.WindowUpdate,
+                    flag: Flag.ACK,
+                    streamID: 0xffffffff,
+                    length: 0xffffffff
+                };
+            },
+            fn: (header) => {
+                encode(header);
+            }
+        });
+    }
+    for (const { decode, name } of [
+        { decode: decodeHeader, name: 'decodeHeader' },
+        { decode: decodeHeaderNaive, name: 'decodeHeaderNaive' }
+    ]) {
+        itBench({
+            id: `frame header ${name}`,
+            beforeEach: () => {
+                const header = new Uint8Array(12);
+                for (let i = 1; i < 12; i++) {
+                    header[i] = 255;
+                }
+                return header;
+            },
+            fn: (header) => {
+                decode(header);
+            }
+        });
+    }
+});
+//# sourceMappingURL=codec.bench.js.map
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/bench/codec.bench.js.map b/node_modules/@chainsafe/libp2p-yamux/dist/test/bench/codec.bench.js.map
new file mode 100644
index 0000000..7f4b30c
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/bench/codec.bench.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"codec.bench.js","sourceRoot":"","sources":["../../../test/bench/codec.bench.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,qBAAqB,CAAA;AAC7C,OAAO,EAAE,YAAY,EAAE,MAAM,qBAAqB,CAAA;AAClD,OAAO,EAAE,YAAY,EAAE,MAAM,qBAAqB,CAAA;AAClD,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE,MAAM,oBAAoB,CAAA;AACpD,OAAO,EAAE,iBAAiB,EAAE,iBAAiB,EAAE,MAAM,kBAAkB,CAAA;AAGvE,QAAQ,CAAC,iBAAiB,EAAE,GAAG,EAAE;IAC/B,KAAK,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,IAAI;QAC7B,EAAE,MAAM,EAAE,YAAY,EAAE,IAAI,EAAE,mBAAmB,EAAE;QACnD,EAAE,MAAM,EAAE,iBAAiB,EAAE,IAAI,EAAE,wBAAwB,EAAE;KAC9D,EAAE,CAAC;QACF,OAAO,CAAyB;YAC9B,EAAE,EAAE,kBAAkB,IAAI,EAAE;YAC5B,YAAY,EAAE,SAAS;YACvB,UAAU,EAAE,GAAG,EAAE;gBACf,OAAO;oBACL,IAAI,EAAE,SAAS,CAAC,YAAY;oBAC5B,IAAI,EAAE,IAAI,CAAC,GAAG;oBACd,QAAQ,EAAE,UAAU;oBACpB,MAAM,EAAE,UAAU;iBACnB,CAAA;YACH,CAAC;YACD,EAAE,EAAE,CAAC,MAAM,EAAE,EAAE;gBACb,MAAM,CAAC,MAAM,CAAC,CAAA;YAChB,CAAC;SACF,CAAC,CAAA;IACJ,CAAC;IAED,KAAK,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,IAAI;QAC7B,EAAE,MAAM,EAAE,YAAY,EAAE,IAAI,EAAE,cAAc,EAAE;QAC9C,EAAE,MAAM,EAAE,iBAAiB,EAAE,IAAI,EAAE,mBAAmB,EAAE;KACzD,EAAE,CAAC;QACF,OAAO,CAAwB;YAC7B,EAAE,EAAE,gBAAgB,IAAI,EAAE;YAC1B,UAAU,EAAE,GAAG,EAAE;gBACf,MAAM,MAAM,GAAG,IAAI,UAAU,CAAC,EAAE,CAAC,CAAA;gBACjC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC;oBAC5B,MAAM,CAAC,CAAC,CAAC,GAAG,GAAG,CAAA;gBACjB,CAAC;gBACD,OAAO,MAAM,CAAA;YACf,CAAC;YACD,EAAE,EAAE,CAAC,MAAM,EAAE,EAAE;gBACb,MAAM,CAAC,MAAM,CAAC,CAAA;YAChB,CAAC;SACF,CAAC,CAAA;IACJ,CAAC;AACH,CAAC,CAAC,CAAA"}
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/bench/comparison.bench.d.ts b/node_modules/@chainsafe/libp2p-yamux/dist/test/bench/comparison.bench.d.ts
new file mode 100644
index 0000000..cb9667d
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/bench/comparison.bench.d.ts
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=comparison.bench.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/bench/comparison.bench.d.ts.map b/node_modules/@chainsafe/libp2p-yamux/dist/test/bench/comparison.bench.d.ts.map
new file mode 100644
index 0000000..c29eccd
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/bench/comparison.bench.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"comparison.bench.d.ts","sourceRoot":"","sources":["../../../test/bench/comparison.bench.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/bench/comparison.bench.js b/node_modules/@chainsafe/libp2p-yamux/dist/test/bench/comparison.bench.js
new file mode 100644
index 0000000..19512e4
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/bench/comparison.bench.js
@@ -0,0 +1,36 @@
+import { itBench } from '@dapplion/benchmark';
+import drain from 'it-drain';
+import { pipe } from 'it-pipe';
+import { testClientServer as testMplexClientServer } from '../mplex.util.js';
+import { testClientServer as testYamuxClientServer } from '../util.js';
+describe('comparison benchmark', () => {
+    for (const { impl, name } of [
+        { impl: testYamuxClientServer, name: 'yamux' },
+        { impl: testMplexClientServer, name: 'mplex' }
+    ]) {
+        for (const { numMessages, msgSize } of [
+            { numMessages: 1, msgSize: 2 ** 6 },
+            { numMessages: 1, msgSize: 2 ** 10 },
+            { numMessages: 1, msgSize: 2 ** 16 },
+            { numMessages: 1, msgSize: 2 ** 20 },
+            { numMessages: 1000, msgSize: 2 ** 6 },
+            { numMessages: 1000, msgSize: 2 ** 10 },
+            { numMessages: 1000, msgSize: 2 ** 16 },
+            { numMessages: 1000, msgSize: 2 ** 20 }
+        ]) {
+            itBench({
+                id: `${name} send and receive ${numMessages} ${msgSize / 1024}KB chunks`,
+                beforeEach: () => impl({
+                    onIncomingStream: (stream) => {
+                        void pipe(stream, drain).then(async () => { await stream.close(); });
+                    }
+                }),
+                fn: async ({ client, server }) => {
+                    const stream = await client.newStream();
+                    await pipe(Array.from({ length: numMessages }, () => new Uint8Array(msgSize)), stream, drain);
+                }
+            });
+        }
+    }
+});
+//# sourceMappingURL=comparison.bench.js.map
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/bench/comparison.bench.js.map b/node_modules/@chainsafe/libp2p-yamux/dist/test/bench/comparison.bench.js.map
new file mode 100644
index 0000000..5ca068d
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/bench/comparison.bench.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"comparison.bench.js","sourceRoot":"","sources":["../../../test/bench/comparison.bench.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,qBAAqB,CAAA;AAC7C,OAAO,KAAK,MAAM,UAAU,CAAA;AAC5B,OAAO,EAAE,IAAI,EAAE,MAAM,SAAS,CAAA;AAC9B,OAAO,EAAE,gBAAgB,IAAI,qBAAqB,EAAE,MAAM,kBAAkB,CAAA;AAC5E,OAAO,EAAE,gBAAgB,IAAI,qBAAqB,EAAE,MAAM,YAAY,CAAA;AAEtE,QAAQ,CAAC,sBAAsB,EAAE,GAAG,EAAE;IACpC,KAAK,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI;QAC3B,EAAE,IAAI,EAAE,qBAAqB,EAAE,IAAI,EAAE,OAAO,EAAE;QAC9C,EAAE,IAAI,EAAE,qBAAqB,EAAE,IAAI,EAAE,OAAO,EAAE;KAC/C,EAAE,CAAC;QACF,KAAK,MAAM,EAAE,WAAW,EAAE,OAAO,EAAE,IAAI;YACrC,EAAE,WAAW,EAAE,CAAC,EAAE,OAAO,EAAE,CAAC,IAAI,CAAC,EAAE;YACnC,EAAE,WAAW,EAAE,CAAC,EAAE,OAAO,EAAE,CAAC,IAAI,EAAE,EAAE;YACpC,EAAE,WAAW,EAAE,CAAC,EAAE,OAAO,EAAE,CAAC,IAAI,EAAE,EAAE;YACpC,EAAE,WAAW,EAAE,CAAC,EAAE,OAAO,EAAE,CAAC,IAAI,EAAE,EAAE;YACpC,EAAE,WAAW,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC,IAAI,CAAC,EAAE;YACtC,EAAE,WAAW,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC,IAAI,EAAE,EAAE;YACvC,EAAE,WAAW,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC,IAAI,EAAE,EAAE;YACvC,EAAE,WAAW,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC,IAAI,EAAE,EAAE;SACxC,EAAE,CAAC;YACF,OAAO,CAAqC;gBAC1C,EAAE,EAAE,GAAG,IAAI,qBAAqB,WAAW,IAAI,OAAO,GAAG,IAAI,WAAW;gBACxE,UAAU,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC;oBACrB,gBAAgB,EAAE,CAAC,MAAM,EAAE,EAAE;wBAC3B,KAAK,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC,IAAI,CAAC,KAAK,IAAI,EAAE,GAAG,MAAM,MAAM,CAAC,KAAK,EAAE,CAAA,CAAC,CAAC,CAAC,CAAA;oBACrE,CAAC;iBACF,CAAC;gBACF,EAAE,EAAE,KAAK,EAAE,EAAE,MAAM,EAAE,MAAM,EAAE,EAAE,EAAE;oBAC/B,MAAM,MAAM,GAAG,MAAM,MAAM,CAAC,SAAS,EAAE,CAAA;oBACvC,MAAM,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,WAAW,EAAE,EAAE,GAAG,EAAE,CAAC,IAAI,UAAU,CAAC,OAAO,CAAC,CAAC,EAAE,MAAM,EAAE,KAAK,CAAC,CAAA;gBAC/F,CAAC;aACF,CAAC,CAAA;QACJ,CAAC;IACH,CAAC;AACH,CAAC,CAAC,CAAA"}
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/codec.spec.d.ts b/node_modules/@chainsafe/libp2p-yamux/dist/test/codec.spec.d.ts
new file mode 100644
index 0000000..633c753
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/codec.spec.d.ts
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=codec.spec.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/codec.spec.d.ts.map b/node_modules/@chainsafe/libp2p-yamux/dist/test/codec.spec.d.ts.map
new file mode 100644
index 0000000..9645478
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/codec.spec.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"codec.spec.d.ts","sourceRoot":"","sources":["../../test/codec.spec.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/codec.spec.js b/node_modules/@chainsafe/libp2p-yamux/dist/test/codec.spec.js
new file mode 100644
index 0000000..4d61ce2
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/codec.spec.js
@@ -0,0 +1,28 @@
+import { expect } from 'aegir/chai';
+import { decodeHeader } from '../src/decode.js';
+import { encodeHeader } from '../src/encode.js';
+import { Flag, FrameType, GoAwayCode, stringifyHeader } from '../src/frame.js';
+import { decodeHeaderNaive, encodeHeaderNaive } from './codec.util.js';
+const frames = [
+    { header: { type: FrameType.Ping, flag: Flag.SYN, streamID: 0, length: 1 } },
+    { header: { type: FrameType.WindowUpdate, flag: Flag.SYN, streamID: 1, length: 1 } },
+    { header: { type: FrameType.GoAway, flag: 0, streamID: 0, length: GoAwayCode.NormalTermination } },
+    { header: { type: FrameType.Ping, flag: Flag.ACK, streamID: 0, length: 100 } },
+    { header: { type: FrameType.WindowUpdate, flag: 0, streamID: 99, length: 1000 } },
+    { header: { type: FrameType.WindowUpdate, flag: 0, streamID: 0xffffffff, length: 0xffffffff } },
+    { header: { type: FrameType.GoAway, flag: 0, streamID: 0, length: GoAwayCode.ProtocolError } }
+];
+describe('codec', () => {
+    for (const { header } of frames) {
+        it(`should round trip encode/decode header ${stringifyHeader(header)}`, () => {
+            expect(decodeHeader(encodeHeader(header))).to.deep.equal(header);
+        });
+    }
+    for (const { header } of frames) {
+        it(`should match naive implementations of encode/decode for header ${stringifyHeader(header)}`, () => {
+            expect(encodeHeader(header)).to.deep.equal(encodeHeaderNaive(header));
+            expect(decodeHeader(encodeHeader(header))).to.deep.equal(decodeHeaderNaive(encodeHeaderNaive(header)));
+        });
+    }
+});
+//# sourceMappingURL=codec.spec.js.map
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/codec.spec.js.map b/node_modules/@chainsafe/libp2p-yamux/dist/test/codec.spec.js.map
new file mode 100644
index 0000000..00ce0c1
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/codec.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"codec.spec.js","sourceRoot":"","sources":["../../test/codec.spec.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,MAAM,YAAY,CAAA;AACnC,OAAO,EAAE,YAAY,EAAE,MAAM,kBAAkB,CAAA;AAC/C,OAAO,EAAE,YAAY,EAAE,MAAM,kBAAkB,CAAA;AAC/C,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE,UAAU,EAAE,eAAe,EAAE,MAAM,iBAAiB,CAAA;AAC9E,OAAO,EAAE,iBAAiB,EAAE,iBAAiB,EAAE,MAAM,iBAAiB,CAAA;AAGtE,MAAM,MAAM,GAAsD;IAChE,EAAE,MAAM,EAAE,EAAE,IAAI,EAAE,SAAS,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,GAAG,EAAE,QAAQ,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,EAAE;IAC5E,EAAE,MAAM,EAAE,EAAE,IAAI,EAAE,SAAS,CAAC,YAAY,EAAE,IAAI,EAAE,IAAI,CAAC,GAAG,EAAE,QAAQ,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,EAAE;IACpF,EAAE,MAAM,EAAE,EAAE,IAAI,EAAE,SAAS,CAAC,MAAM,EAAE,IAAI,EAAE,CAAC,EAAE,QAAQ,EAAE,CAAC,EAAE,MAAM,EAAE,UAAU,CAAC,iBAAiB,EAAE,EAAE;IAClG,EAAE,MAAM,EAAE,EAAE,IAAI,EAAE,SAAS,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,GAAG,EAAE,QAAQ,EAAE,CAAC,EAAE,MAAM,EAAE,GAAG,EAAE,EAAE;IAC9E,EAAE,MAAM,EAAE,EAAE,IAAI,EAAE,SAAS,CAAC,YAAY,EAAE,IAAI,EAAE,CAAC,EAAE,QAAQ,EAAE,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,EAAE;IACjF,EAAE,MAAM,EAAE,EAAE,IAAI,EAAE,SAAS,CAAC,YAAY,EAAE,IAAI,EAAE,CAAC,EAAE,QAAQ,EAAE,UAAU,EAAE,MAAM,EAAE,UAAU,EAAE,EAAE;IAC/F,EAAE,MAAM,EAAE,EAAE,IAAI,EAAE,SAAS,CAAC,MAAM,EAAE,IAAI,EAAE,CAAC,EAAE,QAAQ,EAAE,CAAC,EAAE,MAAM,EAAE,UAAU,CAAC,aAAa,EAAE,EAAE;CAC/F,CAAA;AAED,QAAQ,CAAC,OAAO,EAAE,GAAG,EAAE;IACrB,KAAK,MAAM,EAAE,MAAM,EAAE,IAAI,MAAM,EAAE,CAAC;QAChC,EAAE,CAAC,0CAA0C,eAAe,CAAC,MAAM,CAAC,EAAE,EAAE,GAAG,EAAE;YAC3E,MAAM,CAAC,YAAY,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAA;QAClE,CAAC,CAAC,CAAA;IACJ,CAAC;IAED,KAAK,MAAM,EAAE,MAAM,EAAE,IAAI,MAAM,EAAE,CAAC;QAChC,EAAE,CAAC,kEAAkE,eAAe,CAAC,MAAM,CAAC,EAAE,EAAE,GAAG,EAAE;YACnG,MAAM,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,MAAM,CAAC,CAAC,CAAA;YACrE,MAAM,CAAC,YAAY,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,iBAAiB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAA;QACxG,CAAC,CAAC,CAAA;IACJ,CAAC;AACH,CAAC,CAAC,CAAA"}
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/codec.util.d.ts b/node_modules/@chainsafe/libp2p-yamux/dist/test/codec.util.d.ts
new file mode 100644
index 0000000..e795077
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/codec.util.d.ts
@@ -0,0 +1,4 @@
+import type { FrameHeader } from '../src/frame.js';
+export declare function decodeHeaderNaive(data: Uint8Array): FrameHeader;
+export declare function encodeHeaderNaive(header: FrameHeader): Uint8Array;
+//# sourceMappingURL=codec.util.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/codec.util.d.ts.map b/node_modules/@chainsafe/libp2p-yamux/dist/test/codec.util.d.ts.map
new file mode 100644
index 0000000..5b11454
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/codec.util.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"codec.util.d.ts","sourceRoot":"","sources":["../../test/codec.util.ts"],"names":[],"mappings":"AAEA,OAAO,KAAK,EAAE,WAAW,EAAE,MAAM,iBAAiB,CAAA;AAIlD,wBAAgB,iBAAiB,CAAE,IAAI,EAAE,UAAU,GAAG,WAAW,CAYhE;AAED,wBAAgB,iBAAiB,CAAE,MAAM,EAAE,WAAW,GAAG,UAAU,CAclE"}
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/codec.util.js b/node_modules/@chainsafe/libp2p-yamux/dist/test/codec.util.js
new file mode 100644
index 0000000..b989960
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/codec.util.js
@@ -0,0 +1,27 @@
+import { InvalidFrameError } from '../src/errors.js';
+import { HEADER_LENGTH, YAMUX_VERSION } from '../src/frame.js';
+// Slower encode / decode functions that use dataview
+export function decodeHeaderNaive(data) {
+    const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
+    if (view.getUint8(0) !== YAMUX_VERSION) {
+        throw new InvalidFrameError('Invalid frame version');
+    }
+    return {
+        type: view.getUint8(1),
+        flag: view.getUint16(2, false),
+        streamID: view.getUint32(4, false),
+        length: view.getUint32(8, false)
+    };
+}
+export function encodeHeaderNaive(header) {
+    const frame = new Uint8Array(HEADER_LENGTH);
+    const frameView = new DataView(frame.buffer, frame.byteOffset, frame.byteLength);
+    // always assume version 0
+    // frameView.setUint8(0, header.version)
+    frameView.setUint8(1, header.type);
+    frameView.setUint16(2, header.flag, false);
+    frameView.setUint32(4, header.streamID, false);
+    frameView.setUint32(8, header.length, false);
+    return frame;
+}
+//# sourceMappingURL=codec.util.js.map
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/codec.util.js.map b/node_modules/@chainsafe/libp2p-yamux/dist/test/codec.util.js.map
new file mode 100644
index 0000000..0c14fa3
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/codec.util.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"codec.util.js","sourceRoot":"","sources":["../../test/codec.util.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,iBAAiB,EAAE,MAAM,kBAAkB,CAAA;AACpD,OAAO,EAAE,aAAa,EAAE,aAAa,EAAE,MAAM,iBAAiB,CAAA;AAG9D,qDAAqD;AAErD,MAAM,UAAU,iBAAiB,CAAE,IAAgB;IACjD,MAAM,IAAI,GAAG,IAAI,QAAQ,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,UAAU,CAAC,CAAA;IAExE,IAAI,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,KAAK,aAAa,EAAE,CAAC;QACvC,MAAM,IAAI,iBAAiB,CAAC,uBAAuB,CAAC,CAAA;IACtD,CAAC;IACD,OAAO;QACL,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;QACtB,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC;QAC9B,QAAQ,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC;QAClC,MAAM,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC;KACjC,CAAA;AACH,CAAC;AAED,MAAM,UAAU,iBAAiB,CAAE,MAAmB;IACpD,MAAM,KAAK,GAAG,IAAI,UAAU,CAAC,aAAa,CAAC,CAAA;IAE3C,MAAM,SAAS,GAAG,IAAI,QAAQ,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,UAAU,EAAE,KAAK,CAAC,UAAU,CAAC,CAAA;IAEhF,0BAA0B;IAC1B,wCAAwC;IAExC,SAAS,CAAC,QAAQ,CAAC,CAAC,EAAE,MAAM,CAAC,IAAI,CAAC,CAAA;IAClC,SAAS,CAAC,SAAS,CAAC,CAAC,EAAE,MAAM,CAAC,IAAI,EAAE,KAAK,CAAC,CAAA;IAC1C,SAAS,CAAC,SAAS,CAAC,CAAC,EAAE,MAAM,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAA;IAC9C,SAAS,CAAC,SAAS,CAAC,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC,CAAA;IAE5C,OAAO,KAAK,CAAA;AACd,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/compliance.spec.d.ts b/node_modules/@chainsafe/libp2p-yamux/dist/test/compliance.spec.d.ts
new file mode 100644
index 0000000..dac08d9
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/compliance.spec.d.ts
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=compliance.spec.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/compliance.spec.d.ts.map b/node_modules/@chainsafe/libp2p-yamux/dist/test/compliance.spec.d.ts.map
new file mode 100644
index 0000000..dc9e719
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/compliance.spec.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"compliance.spec.d.ts","sourceRoot":"","sources":["../../test/compliance.spec.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/compliance.spec.js b/node_modules/@chainsafe/libp2p-yamux/dist/test/compliance.spec.js
new file mode 100644
index 0000000..92fc32e
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/compliance.spec.js
@@ -0,0 +1,15 @@
+/* eslint-env mocha */
+import tests from '@libp2p/interface-compliance-tests/stream-muxer';
+import { defaultLogger } from '@libp2p/logger';
+import { TestYamux } from './util.js';
+describe('compliance', () => {
+    tests({
+        async setup() {
+            return new TestYamux({
+                logger: defaultLogger()
+            });
+        },
+        async teardown() { }
+    });
+});
+//# sourceMappingURL=compliance.spec.js.map
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/compliance.spec.js.map b/node_modules/@chainsafe/libp2p-yamux/dist/test/compliance.spec.js.map
new file mode 100644
index 0000000..20a514a
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/compliance.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"compliance.spec.js","sourceRoot":"","sources":["../../test/compliance.spec.ts"],"names":[],"mappings":"AAAA,sBAAsB;AAEtB,OAAO,KAAK,MAAM,iDAAiD,CAAA;AACnE,OAAO,EAAE,aAAa,EAAE,MAAM,gBAAgB,CAAA;AAC9C,OAAO,EAAE,SAAS,EAAE,MAAM,WAAW,CAAA;AAErC,QAAQ,CAAC,YAAY,EAAE,GAAG,EAAE;IAC1B,KAAK,CAAC;QACJ,KAAK,CAAC,KAAK;YACT,OAAO,IAAI,SAAS,CAAC;gBACnB,MAAM,EAAE,aAAa,EAAE;aACxB,CAAC,CAAA;QACJ,CAAC;QACD,KAAK,CAAC,QAAQ,KAAK,CAAC;KACrB,CAAC,CAAA;AACJ,CAAC,CAAC,CAAA"}
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/decode.spec.d.ts b/node_modules/@chainsafe/libp2p-yamux/dist/test/decode.spec.d.ts
new file mode 100644
index 0000000..07a9f5c
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/decode.spec.d.ts
@@ -0,0 +1,2 @@
+export declare const randomRanges: (length: number) => number[][];
+//# sourceMappingURL=decode.spec.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/decode.spec.d.ts.map b/node_modules/@chainsafe/libp2p-yamux/dist/test/decode.spec.d.ts.map
new file mode 100644
index 0000000..449c575
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/decode.spec.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"decode.spec.d.ts","sourceRoot":"","sources":["../../test/decode.spec.ts"],"names":[],"mappings":"AAoDA,eAAO,MAAM,YAAY,GAAI,QAAQ,MAAM,KAAG,MAAM,EAAE,EAUrD,CAAA"}
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/decode.spec.js b/node_modules/@chainsafe/libp2p-yamux/dist/test/decode.spec.js
new file mode 100644
index 0000000..819ad0b
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/decode.spec.js
@@ -0,0 +1,296 @@
+import { expect } from 'aegir/chai';
+import { pushable } from 'it-pushable';
+import { Decoder } from '../src/decode.js';
+import { encodeHeader } from '../src/encode.js';
+import { Flag, FrameType, GoAwayCode } from '../src/frame.js';
+import { timeout } from './util.js';
+const frames = [
+    { header: { type: FrameType.Ping, flag: Flag.SYN, streamID: 0, length: 1 } },
+    { header: { type: FrameType.WindowUpdate, flag: Flag.SYN, streamID: 1, length: 1 } },
+    { header: { type: FrameType.GoAway, flag: 0, streamID: 0, length: GoAwayCode.NormalTermination } },
+    { header: { type: FrameType.Ping, flag: Flag.ACK, streamID: 0, length: 100 } },
+    { header: { type: FrameType.WindowUpdate, flag: 0, streamID: 99, length: 1000 } },
+    { header: { type: FrameType.GoAway, flag: 0, streamID: 0, length: GoAwayCode.ProtocolError } }
+];
+const data = (length) => Uint8Array.from(Array.from({ length }), (_, i) => i);
+const expectEqualBytes = (actual, expected, reason) => {
+    expect(actual instanceof Uint8Array ? actual : actual.subarray(), reason).to.deep.equal(expected instanceof Uint8Array ? expected : expected.subarray());
+};
+const expectEqualDataFrame = (actual, expected, reason = '') => {
+    expect(actual.header, reason + ' header').to.deep.equal(expected.header);
+    if (actual.data == null && expected.data != null) {
+        expect.fail('actual has no data but expected does');
+    }
+    if (actual.data != null && expected.data == null) {
+        expect.fail('actual has data but expected does not');
+    }
+    if (actual.data != null && expected.data != null) {
+        expectEqualBytes(actual.data, expected.data, reason + ' data?: string');
+    }
+};
+const expectEqualDataFrames = (actual, expected) => {
+    if (actual.length !== expected.length) {
+        expect.fail('actual');
+    }
+    for (let i = 0; i < actual.length; i++) {
+        expectEqualDataFrame(actual[i], expected[i], String(i));
+    }
+};
+const dataFrame = (length) => ({
+    header: { type: FrameType.Data, flag: 0, streamID: 1, length },
+    data: data(length)
+});
+export const randomRanges = (length) => {
+    const indices = [];
+    let i = 0;
+    let j = 0;
+    while (i < length) {
+        j = i;
+        i += Math.floor(Math.random() * length);
+        indices.push([j, i]);
+    }
+    return indices;
+};
+describe('Decoder internals', () => {
+    describe('readHeader', () => {
+        const frame = frames[0];
+        const p = pushable();
+        const d = new Decoder(p);
+        afterEach(() => {
+            d['buffer'].consume(d['buffer'].length);
+        });
+        it('should handle an empty buffer', async () => {
+            expect(d['buffer'].length, 'a freshly created decoder should have an empty buffer').to.equal(0);
+            expect(d['readHeader'](), 'an empty buffer should read no header').to.equal(undefined);
+        });
+        it('should handle buffer length == header length', async () => {
+            d['buffer'].append(encodeHeader(frame.header));
+            expect(d['readHeader'](), 'the decoded header should match the input').to.deep.equal(frame.header);
+            expect(d['buffer'].length, 'the buffer should be fully drained').to.equal(0);
+        });
+        it('should handle buffer length < header length', async () => {
+            const upTo = 2;
+            d['buffer'].append(encodeHeader(frame.header).slice(0, upTo));
+            expect(d['readHeader'](), 'an buffer that has insufficient bytes should read no header').to.equal(undefined);
+            expect(d['buffer'].length, 'a buffer that has insufficient bytes should not be consumed').to.equal(upTo);
+            d['buffer'].append(encodeHeader(frame.header).slice(upTo));
+            expect(d['readHeader'](), 'the decoded header should match the input').to.deep.equal(frame.header);
+            expect(d['buffer'].length, 'the buffer should be fully drained').to.equal(0);
+        });
+        it('should handle buffer length > header length', async () => {
+            const more = 10;
+            d['buffer'].append(encodeHeader(frame.header));
+            d['buffer'].append(new Uint8Array(more));
+            expect(d['readHeader'](), 'the decoded header should match the input').to.deep.equal(frame.header);
+            expect(d['buffer'].length, 'the buffer should be partially drained').to.equal(more);
+        });
+    });
+    describe('readBytes', () => {
+        const p = pushable();
+        const d = new Decoder(p);
+        afterEach(() => {
+            d['buffer'].consume(d['buffer'].length);
+        });
+        it('should handle buffer length == requested length', async () => {
+            const requested = 10;
+            d['buffer'].append(data(requested));
+            let actual;
+            try {
+                actual = await Promise.race([timeout(1), d['readBytes'](requested)]);
+            }
+            catch (e) {
+                expect.fail('readBytes timed out');
+            }
+            expectEqualBytes(actual, data(requested), 'read bytes should equal input');
+            expect(d['buffer'].length, 'buffer should be drained').to.deep.equal(0);
+        });
+        it('should handle buffer length > requested length', async () => {
+            const requested = 10;
+            d['buffer'].append(data(requested * 2));
+            let actual;
+            try {
+                actual = await Promise.race([timeout(1), d['readBytes'](requested)]);
+            }
+            catch (e) {
+                expect.fail('readBytes timed out');
+            }
+            expectEqualBytes(actual, data(requested), 'read bytes should equal input');
+            expect(d['buffer'].length, 'buffer should be partially drained').to.deep.equal(requested);
+        });
+        it('should handle buffer length < requested length, data available', async () => {
+            const requested = 10;
+            p.push(data(requested));
+            let actual;
+            try {
+                actual = await Promise.race([timeout(10), d['readBytes'](requested)]);
+            }
+            catch (e) {
+                expect.fail('readBytes timed out');
+            }
+            expectEqualBytes(actual, data(requested), 'read bytes should equal input');
+            expect(d['buffer'].length, 'buffer should be drained').to.deep.equal(0);
+        });
+        it('should handle buffer length < requested length, data not available', async () => {
+            const requested = 10;
+            p.push(data(requested - 1));
+            try {
+                await Promise.race([timeout(10), d['readBytes'](requested)]);
+                expect.fail('readBytes should not resolve until the source + buffer have enough bytes');
+            }
+            catch (e) {
+            }
+        });
+    });
+});
+describe('Decoder', () => {
+    describe('emitFrames', () => {
+        let p;
+        let d;
+        beforeEach(() => {
+            p = pushable();
+            d = new Decoder(p);
+        });
+        it('should emit frames from source chunked by frame', async () => {
+            const expected = [];
+            for (const [i, frame] of frames.entries()) {
+                p.push(encodeHeader(frame.header));
+                expected.push(frame);
+                // sprinkle in more data frames
+                if (i % 2 === 1) {
+                    const df = dataFrame(i * 100);
+                    p.push(encodeHeader(df.header));
+                    p.push(df.data);
+                    expected.push(df);
+                }
+            }
+            p.end();
+            const actual = [];
+            for await (const frame of d.emitFrames()) {
+                if (frame.readData === undefined) {
+                    actual.push(frame);
+                }
+                else {
+                    actual.push({ header: frame.header, data: await frame.readData() });
+                }
+            }
+            expectEqualDataFrames(actual, expected);
+        });
+        it('should emit frames from source chunked by partial frame', async () => {
+            const chunkSize = 5;
+            const expected = [];
+            for (const [i, frame] of frames.entries()) {
+                const encoded = encodeHeader(frame.header);
+                for (let i = 0; i < encoded.length; i += chunkSize) {
+                    p.push(encoded.slice(i, i + chunkSize));
+                }
+                expected.push(frame);
+                // sprinkle in more data frames
+                if (i % 2 === 1) {
+                    const df = dataFrame(i * 100);
+                    const encoded = Uint8Array.from([...encodeHeader(df.header), ...df.data]);
+                    for (let i = 0; i < encoded.length; i += chunkSize) {
+                        p.push(encoded.slice(i, i + chunkSize));
+                    }
+                    expected.push(df);
+                }
+            }
+            p.end();
+            const actual = [];
+            for await (const frame of d.emitFrames()) {
+                if (frame.readData === undefined) {
+                    actual.push(frame);
+                }
+                else {
+                    actual.push({ header: frame.header, data: await frame.readData() });
+                }
+            }
+            expect(p.readableLength).to.equal(0);
+            expectEqualDataFrames(actual, expected);
+        });
+        it('should emit frames from source chunked by multiple frames', async () => {
+            const expected = [];
+            for (let i = 0; i < frames.length; i++) {
+                const encoded1 = encodeHeader(frames[i].header);
+                expected.push(frames[i]);
+                i++;
+                const encoded2 = encodeHeader(frames[i].header);
+                expected.push(frames[i]);
+                // sprinkle in more data frames
+                const df = dataFrame(i * 100);
+                const encoded3 = Uint8Array.from([...encodeHeader(df.header), ...df.data]);
+                expected.push(df);
+                const encodedChunk = new Uint8Array(encoded1.length + encoded2.length + encoded3.length);
+                encodedChunk.set(encoded1, 0);
+                encodedChunk.set(encoded2, encoded1.length);
+                encodedChunk.set(encoded3, encoded1.length + encoded2.length);
+                p.push(encodedChunk);
+            }
+            p.end();
+            const actual = [];
+            for await (const frame of d.emitFrames()) {
+                if (frame.readData === undefined) {
+                    actual.push(frame);
+                }
+                else {
+                    actual.push({ header: frame.header, data: await frame.readData() });
+                }
+            }
+            expectEqualDataFrames(actual, expected);
+        });
+        it('should emit frames from source chunked chaoticly', async () => {
+            const expected = [];
+            const encodedFrames = [];
+            for (const [i, frame] of frames.entries()) {
+                encodedFrames.push(encodeHeader(frame.header));
+                expected.push(frame);
+                // sprinkle in more data frames
+                if (i % 2 === 1) {
+                    const df = dataFrame(i * 100);
+                    encodedFrames.push(encodeHeader(df.header));
+                    encodedFrames.push(df.data);
+                    expected.push(df);
+                }
+            }
+            // create a single byte array of all frames to send
+            // so that we can chunk them chaoticly
+            const encoded = new Uint8Array(encodedFrames.reduce((a, b) => a + b.length, 0));
+            let i = 0;
+            for (const e of encodedFrames) {
+                encoded.set(e, i);
+                i += e.length;
+            }
+            for (const [i, j] of randomRanges(encoded.length)) {
+                p.push(encoded.slice(i, j));
+            }
+            p.end();
+            const actual = [];
+            for await (const frame of d.emitFrames()) {
+                if (frame.readData === undefined) {
+                    actual.push(frame);
+                }
+                else {
+                    actual.push({ header: frame.header, data: await frame.readData() });
+                }
+            }
+            expectEqualDataFrames(actual, expected);
+        });
+        it('should error decoding frame while another decode is in progress', async () => {
+            const df1 = dataFrame(100);
+            p.push(encodeHeader(df1.header));
+            p.push(df1.data);
+            const df2 = dataFrame(100);
+            p.push(encodeHeader(df2.header));
+            p.push(df2.data);
+            try {
+                for await (const frame of d.emitFrames()) {
+                    void frame;
+                }
+                expect.fail('decoding another frame before the first is finished should error');
+            }
+            catch (e) {
+                expect(e).to.have.property('name', 'InvalidStateError');
+            }
+        });
+    });
+});
+//# sourceMappingURL=decode.spec.js.map
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/decode.spec.js.map b/node_modules/@chainsafe/libp2p-yamux/dist/test/decode.spec.js.map
new file mode 100644
index 0000000..aed9330
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/decode.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"decode.spec.js","sourceRoot":"","sources":["../../test/decode.spec.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/mplex.util.d.ts b/node_modules/@chainsafe/libp2p-yamux/dist/test/mplex.util.d.ts
new file mode 100644
index 0000000..f0903d1
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/mplex.util.d.ts
@@ -0,0 +1,28 @@
+import type { StreamMuxer, StreamMuxerInit } from '@libp2p/interface';
+import type { Source, Transform } from 'it-stream-types';
+export declare function testYamuxMuxer(name: string, client: boolean, conf?: StreamMuxerInit): StreamMuxer;
+/**
+ * Create a transform that can be paused and unpaused
+ */
+export declare function pauseableTransform<A>(): {
+    transform: Transform<Source<A>, AsyncGenerator<A>>;
+    pause(): void;
+    unpause(): void;
+};
+export declare function testClientServer(conf?: StreamMuxerInit): {
+    client: StreamMuxer & {
+        pauseRead(): void;
+        unpauseRead(): void;
+        pauseWrite(): void;
+        unpauseWrite(): void;
+    };
+    server: StreamMuxer & {
+        pauseRead(): void;
+        unpauseRead(): void;
+        pauseWrite(): void;
+        unpauseWrite(): void;
+    };
+};
+export declare function timeout(ms: number): Promise<unknown>;
+export declare function sleep(ms: number): Promise<unknown>;
+//# sourceMappingURL=mplex.util.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/mplex.util.d.ts.map b/node_modules/@chainsafe/libp2p-yamux/dist/test/mplex.util.d.ts.map
new file mode 100644
index 0000000..7d2cc24
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/mplex.util.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"mplex.util.d.ts","sourceRoot":"","sources":["../../test/mplex.util.ts"],"names":[],"mappings":"AAIA,OAAO,KAAK,EAAE,WAAW,EAAE,eAAe,EAAE,MAAM,mBAAmB,CAAA;AACrE,OAAO,KAAK,EAAE,MAAM,EAAE,SAAS,EAAE,MAAM,iBAAiB,CAAA;AAOxD,wBAAgB,cAAc,CAAE,IAAI,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,GAAE,eAAoB,GAAG,WAAW,CAKtG;AAED;;GAEG;AACH,wBAAgB,kBAAkB,CAAE,CAAC,KAAM;IAAE,SAAS,EAAE,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;IAAC,KAAK,IAAI,IAAI,CAAC;IAAC,OAAO,IAAI,IAAI,CAAA;CAAE,CAsBhI;AAED,wBAAgB,gBAAgB,CAAE,IAAI,GAAE,eAAoB,GAAG;IAC7D,MAAM,EAAE,WAAW,GAAG;QACpB,SAAS,IAAI,IAAI,CAAA;QACjB,WAAW,IAAI,IAAI,CAAA;QACnB,UAAU,IAAI,IAAI,CAAA;QAClB,YAAY,IAAI,IAAI,CAAA;KACrB,CAAA;IACD,MAAM,EAAE,WAAW,GAAG;QACpB,SAAS,IAAI,IAAI,CAAA;QACjB,WAAW,IAAI,IAAI,CAAA;QACnB,UAAU,IAAI,IAAI,CAAA;QAClB,YAAY,IAAI,IAAI,CAAA;KACrB,CAAA;CACF,CA0BA;AAED,wBAAsB,OAAO,CAAE,EAAE,EAAE,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,CAE3D;AAED,wBAAsB,KAAK,CAAE,EAAE,EAAE,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,CAEzD"}
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/mplex.util.js b/node_modules/@chainsafe/libp2p-yamux/dist/test/mplex.util.js
new file mode 100644
index 0000000..38d74fd
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/mplex.util.js
@@ -0,0 +1,71 @@
+import { defaultLogger } from '@libp2p/logger';
+import { mplex } from '@libp2p/mplex';
+import { duplexPair } from 'it-pair/duplex';
+import { pipe } from 'it-pipe';
+const factory = mplex()({
+    logger: defaultLogger()
+});
+export function testYamuxMuxer(name, client, conf = {}) {
+    return factory.createStreamMuxer({
+        ...conf,
+        direction: client ? 'outbound' : 'inbound'
+    });
+}
+/**
+ * Create a transform that can be paused and unpaused
+ */
+export function pauseableTransform() {
+    let resolvePausePromise;
+    let pausePromise;
+    const unpause = () => {
+        resolvePausePromise?.(null);
+    };
+    const pause = () => {
+        pausePromise = new Promise(resolve => {
+            resolvePausePromise = resolve;
+        });
+    };
+    const transform = async function* (source) {
+        for await (const d of source) {
+            if (pausePromise !== undefined) {
+                await pausePromise;
+                pausePromise = undefined;
+                resolvePausePromise = undefined;
+            }
+            yield d;
+        }
+    };
+    return { transform, pause, unpause };
+}
+export function testClientServer(conf = {}) {
+    const pair = duplexPair();
+    const client = testYamuxMuxer('libp2p:mplex:client', true, conf);
+    const server = testYamuxMuxer('libp2p:mplex:server', false, conf);
+    const clientReadTransform = pauseableTransform();
+    const clientWriteTransform = pauseableTransform();
+    const serverReadTransform = pauseableTransform();
+    const serverWriteTransform = pauseableTransform();
+    void pipe(pair[0], clientReadTransform.transform, client, clientWriteTransform.transform, pair[0]);
+    void pipe(pair[1], serverReadTransform.transform, server, serverWriteTransform.transform, pair[1]);
+    return {
+        client: Object.assign(client, {
+            pauseRead: clientReadTransform.pause,
+            unpauseRead: clientReadTransform.unpause,
+            pauseWrite: clientWriteTransform.pause,
+            unpauseWrite: clientWriteTransform.unpause
+        }),
+        server: Object.assign(server, {
+            pauseRead: serverReadTransform.pause,
+            unpauseRead: serverReadTransform.unpause,
+            pauseWrite: serverWriteTransform.pause,
+            unpauseWrite: serverWriteTransform.unpause
+        })
+    };
+}
+export async function timeout(ms) {
+    return new Promise((_resolve, reject) => setTimeout(() => { reject(new Error(`timeout after ${ms}ms`)); }, ms));
+}
+export async function sleep(ms) {
+    return new Promise(resolve => setTimeout(() => { resolve(ms); }, ms));
+}
+//# sourceMappingURL=mplex.util.js.map
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/mplex.util.js.map b/node_modules/@chainsafe/libp2p-yamux/dist/test/mplex.util.js.map
new file mode 100644
index 0000000..e0f8a7f
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/mplex.util.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"mplex.util.js","sourceRoot":"","sources":["../../test/mplex.util.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/muxer.spec.d.ts b/node_modules/@chainsafe/libp2p-yamux/dist/test/muxer.spec.d.ts
new file mode 100644
index 0000000..5855d5d
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/muxer.spec.d.ts
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=muxer.spec.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/muxer.spec.d.ts.map b/node_modules/@chainsafe/libp2p-yamux/dist/test/muxer.spec.d.ts.map
new file mode 100644
index 0000000..cb814f4
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/muxer.spec.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"muxer.spec.d.ts","sourceRoot":"","sources":["../../test/muxer.spec.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/muxer.spec.js b/node_modules/@chainsafe/libp2p-yamux/dist/test/muxer.spec.js
new file mode 100644
index 0000000..fd37f45
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/muxer.spec.js
@@ -0,0 +1,114 @@
+/* eslint-env mocha */
+import { expect } from 'aegir/chai';
+import { duplexPair } from 'it-pair/duplex';
+import { pipe } from 'it-pipe';
+import { sleep, testClientServer, testYamuxMuxer } from './util.js';
+describe('muxer', () => {
+    let client;
+    let server;
+    afterEach(async () => {
+        if (client != null) {
+            await client.close();
+        }
+        if (server != null) {
+            await server.close();
+        }
+    });
+    it('test repeated close', async () => {
+        const client1 = testYamuxMuxer('libp2p:yamux:1', true);
+        // inspect logs to ensure its only closed once
+        await client1.close();
+        await client1.close();
+        await client1.close();
+    });
+    it('test client<->client', async () => {
+        const pair = duplexPair();
+        const client1 = testYamuxMuxer('libp2p:yamux:1', true);
+        const client2 = testYamuxMuxer('libp2p:yamux:2', true);
+        void pipe(pair[0], client1, pair[0]);
+        void pipe(pair[1], client2, pair[1]);
+        client1.newStream();
+        client2.newStream();
+        await sleep(20);
+        expect(client1.isClosed()).to.equal(true);
+        expect(client2.isClosed()).to.equal(true);
+    });
+    it('test server<->server', async () => {
+        const pair = duplexPair();
+        const client1 = testYamuxMuxer('libp2p:yamux:1', false);
+        const client2 = testYamuxMuxer('libp2p:yamux:2', false);
+        void pipe(pair[0], client1, pair[0]);
+        void pipe(pair[1], client2, pair[1]);
+        client1.newStream();
+        client2.newStream();
+        await sleep(20);
+        expect(client1.isClosed()).to.equal(true);
+        expect(client2.isClosed()).to.equal(true);
+    });
+    it('test ping', async () => {
+        ({ client, server } = testClientServer());
+        server.pauseRead();
+        const clientRTT = client.ping();
+        await sleep(10);
+        server.unpauseRead();
+        expect(await clientRTT).to.not.equal(0);
+        server.pauseWrite();
+        const serverRTT = server.ping();
+        await sleep(10);
+        server.unpauseWrite();
+        expect(await serverRTT).to.not.equal(0);
+    });
+    it('test multiple simultaneous pings', async () => {
+        ({ client, server } = testClientServer());
+        client.pauseWrite();
+        const promise = [
+            client.ping(),
+            client.ping(),
+            client.ping()
+        ];
+        await sleep(10);
+        client.unpauseWrite();
+        const clientRTTs = await Promise.all(promise);
+        expect(clientRTTs[0]).to.not.equal(0);
+        expect(clientRTTs[0]).to.equal(clientRTTs[1]);
+        expect(clientRTTs[1]).to.equal(clientRTTs[2]);
+        expect(client['nextPingID']).to.equal(1);
+        await client.close();
+    });
+    it('test go away', async () => {
+        ({ client, server } = testClientServer());
+        await client.close();
+        expect(() => {
+            client.newStream();
+        }).to.throw().with.property('name', 'MuxerClosedError', 'should not be able to open a stream after close');
+    });
+    it('test keep alive', async () => {
+        ({ client, server } = testClientServer({ enableKeepAlive: true, keepAliveInterval: 10 }));
+        await sleep(1000);
+        expect(client['nextPingID']).to.be.gt(2);
+        await client.close();
+        await server.close();
+    });
+    it('test max inbound streams', async () => {
+        ({ client, server } = testClientServer({ maxInboundStreams: 1 }));
+        client.newStream();
+        client.newStream();
+        await sleep(10);
+        expect(server.streams.length).to.equal(1);
+        expect(client.streams.length).to.equal(1);
+    });
+    it('test max outbound streams', async () => {
+        ({ client, server } = testClientServer({ maxOutboundStreams: 1 }));
+        client.newStream();
+        await sleep(10);
+        try {
+            client.newStream();
+            expect.fail('stream creation should fail if exceeding maxOutboundStreams');
+        }
+        catch (e) {
+            expect(server.streams.length).to.equal(1);
+            expect(client.streams.length).to.equal(1);
+        }
+    });
+});
+//# sourceMappingURL=muxer.spec.js.map
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/muxer.spec.js.map b/node_modules/@chainsafe/libp2p-yamux/dist/test/muxer.spec.js.map
new file mode 100644
index 0000000..94f80fa
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/muxer.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"muxer.spec.js","sourceRoot":"","sources":["../../test/muxer.spec.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/stream.spec.d.ts b/node_modules/@chainsafe/libp2p-yamux/dist/test/stream.spec.d.ts
new file mode 100644
index 0000000..2ce8297
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/stream.spec.d.ts
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=stream.spec.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/stream.spec.d.ts.map b/node_modules/@chainsafe/libp2p-yamux/dist/test/stream.spec.d.ts.map
new file mode 100644
index 0000000..77bed14
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/stream.spec.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"stream.spec.d.ts","sourceRoot":"","sources":["../../test/stream.spec.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/stream.spec.js b/node_modules/@chainsafe/libp2p-yamux/dist/test/stream.spec.js
new file mode 100644
index 0000000..caa0e93
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/stream.spec.js
@@ -0,0 +1,193 @@
+/* eslint-env mocha */
+import { expect } from 'aegir/chai';
+import { pipe } from 'it-pipe';
+import { pushable } from 'it-pushable';
+import { defaultConfig } from '../src/config.js';
+import { GoAwayCode } from '../src/frame.js';
+import { StreamState } from '../src/stream.js';
+import { sleep, testClientServer } from './util.js';
+describe('stream', () => {
+    let client;
+    let server;
+    afterEach(async () => {
+        if (client != null) {
+            await client.close();
+        }
+        if (server != null) {
+            await server.close();
+        }
+    });
+    it('test send data - small', async () => {
+        ({ client, server } = testClientServer({ initialStreamWindowSize: defaultConfig.initialStreamWindowSize }));
+        const { default: drain } = await import('it-drain');
+        const p = pushable();
+        const c1 = client.newStream();
+        await sleep(10);
+        const s1 = server.streams[0];
+        const sendPipe = pipe(p, c1);
+        const recvPipe = pipe(s1, drain);
+        for (let i = 0; i < 10; i++) {
+            p.push(new Uint8Array(256));
+        }
+        p.end();
+        await Promise.all([sendPipe, recvPipe]);
+        // the window capacities should have refilled via window updates as received data was consumed
+        expect(c1['sendWindowCapacity']).to.be.gte(defaultConfig.initialStreamWindowSize);
+        expect(s1['recvWindowCapacity']).to.be.gte(defaultConfig.initialStreamWindowSize);
+    });
+    it('test send data - large', async () => {
+        ({ client, server } = testClientServer({ initialStreamWindowSize: defaultConfig.initialStreamWindowSize }));
+        const { default: drain } = await import('it-drain');
+        const p = pushable();
+        const c1 = client.newStream();
+        await sleep(10);
+        const s1 = server.streams[0];
+        const sendPipe = pipe(p, c1);
+        const recvPipe = pipe(s1, drain);
+        // amount of data is greater than initial window size
+        // and each payload is also greater than the max message size
+        // this will payload chunking and also waiting for window updates before continuing to send
+        for (let i = 0; i < 10; i++) {
+            p.push(new Uint8Array(defaultConfig.initialStreamWindowSize));
+        }
+        p.end();
+        await Promise.all([sendPipe, recvPipe]);
+        // the window capacities should have refilled via window updates as received data was consumed
+        expect(c1['sendWindowCapacity']).to.be.gte(defaultConfig.initialStreamWindowSize);
+        expect(s1['recvWindowCapacity']).to.be.gte(defaultConfig.initialStreamWindowSize);
+    });
+    it('test send data - large with increasing recv window size', async () => {
+        ({ client, server } = testClientServer({ initialStreamWindowSize: defaultConfig.initialStreamWindowSize }));
+        const { default: drain } = await import('it-drain');
+        const p = pushable();
+        const c1 = client.newStream();
+        server.pauseWrite();
+        void server.ping();
+        await sleep(10);
+        server.unpauseWrite();
+        const s1 = server.streams[0];
+        const sendPipe = pipe(p, c1);
+        const recvPipe = pipe(s1, drain);
+        // amount of data is greater than initial window size
+        // and each payload is also greater than the max message size
+        // this will payload chunking and also waiting for window updates before continuing to send
+        for (let i = 0; i < 10; i++) {
+            p.push(new Uint8Array(defaultConfig.initialStreamWindowSize));
+        }
+        p.end();
+        await Promise.all([sendPipe, recvPipe]);
+        // the window capacities should have refilled via window updates as received data was consumed
+        expect(c1['sendWindowCapacity']).to.be.gte(defaultConfig.initialStreamWindowSize);
+        expect(s1['recvWindowCapacity']).to.be.gte(defaultConfig.initialStreamWindowSize);
+    });
+    it('test many streams', async () => {
+        ({ client, server } = testClientServer());
+        for (let i = 0; i < 1000; i++) {
+            client.newStream();
+        }
+        await sleep(100);
+        expect(client.streams.length).to.equal(1000);
+        expect(server.streams.length).to.equal(1000);
+    });
+    it('test many streams - ping pong', async () => {
+        ({ client, server } = testClientServer({
+            // echo on incoming streams
+            onIncomingStream: (stream) => { void pipe(stream, stream); }
+        }));
+        const numStreams = 10;
+        const p = [];
+        for (let i = 0; i < numStreams; i++) {
+            client.newStream();
+            p.push(pushable());
+        }
+        await sleep(100);
+        for (let i = 0; i < numStreams; i++) {
+            const s = client.streams[i];
+            void pipe(p[i], s);
+            p[i].push(new Uint8Array(16));
+        }
+        await sleep(100);
+        expect(client.streams.length).to.equal(numStreams);
+        expect(server.streams.length).to.equal(numStreams);
+        await client.close();
+    });
+    it('test stream close', async () => {
+        ({ client, server } = testClientServer());
+        const c1 = client.newStream();
+        await c1.close();
+        await sleep(5);
+        expect(c1.state).to.equal(StreamState.Finished);
+        const s1 = server.streams[0];
+        expect(s1).to.not.be.undefined();
+        expect(s1.state).to.equal(StreamState.SYNReceived);
+    });
+    it('test stream close read', async () => {
+        ({ client, server } = testClientServer());
+        const c1 = client.newStream();
+        await c1.closeRead();
+        await sleep(5);
+        const s1 = server.streams[0];
+        expect(s1).to.not.be.undefined();
+        expect(s1.readStatus).to.equal('ready');
+        expect(s1.writeStatus).to.equal('ready');
+    });
+    it('test stream close write', async () => {
+        ({ client, server } = testClientServer());
+        const c1 = client.newStream();
+        await c1.closeWrite();
+        await sleep(5);
+        expect(c1.readStatus).to.equal('ready');
+        expect(c1.writeStatus).to.equal('closed');
+        const s1 = server.streams[0];
+        expect(s1).to.not.be.undefined();
+        expect(s1.readStatus).to.equal('closed');
+        expect(s1.writeStatus).to.equal('ready');
+    });
+    it('test window overflow', async () => {
+        ({ client, server } = testClientServer({ maxMessageSize: defaultConfig.initialStreamWindowSize, initialStreamWindowSize: defaultConfig.initialStreamWindowSize }));
+        const { default: drain } = await import('it-drain');
+        const p = pushable();
+        const c1 = client.newStream();
+        await sleep(10);
+        const s1 = server.streams[0];
+        const sendPipe = pipe(p, c1);
+        const c1SendData = c1.sendData.bind(c1);
+        c1.sendData = async (data) => {
+            await c1SendData(data);
+            c1['sendWindowCapacity'] = defaultConfig.initialStreamWindowSize * 10;
+        };
+        p.push(new Uint8Array(defaultConfig.initialStreamWindowSize));
+        p.push(new Uint8Array(defaultConfig.initialStreamWindowSize));
+        await sleep(10);
+        const recvPipe = pipe(s1, drain);
+        p.end();
+        try {
+            await Promise.all([sendPipe, recvPipe]);
+        }
+        catch (e) {
+            expect(e).to.have.property('name', 'ReceiveWindowExceededError');
+        }
+        expect(client).to.have.property('remoteGoAway', GoAwayCode.ProtocolError);
+        expect(server).to.have.property('localGoAway', GoAwayCode.ProtocolError);
+    });
+    it('test stream sink error', async () => {
+        ({ client, server } = testClientServer());
+        // don't let the server respond
+        server.pauseRead();
+        const p = pushable();
+        const c1 = client.newStream();
+        const sendPipe = pipe(p, c1);
+        // send more data than the window size, will trigger a wait
+        p.push(new Uint8Array(defaultConfig.initialStreamWindowSize));
+        p.push(new Uint8Array(defaultConfig.initialStreamWindowSize));
+        await sleep(10);
+        // the client should fail to close gracefully because there is unsent data
+        // that will never be sent
+        await client.close({
+            signal: AbortSignal.timeout(10)
+        });
+        p.end();
+        await sendPipe;
+    });
+});
+//# sourceMappingURL=stream.spec.js.map
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/stream.spec.js.map b/node_modules/@chainsafe/libp2p-yamux/dist/test/stream.spec.js.map
new file mode 100644
index 0000000..c599e51
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/stream.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"stream.spec.js","sourceRoot":"","sources":["../../test/stream.spec.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/util.d.ts b/node_modules/@chainsafe/libp2p-yamux/dist/test/util.d.ts
new file mode 100644
index 0000000..13d8ca9
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/util.d.ts
@@ -0,0 +1,37 @@
+import { Yamux, YamuxMuxer } from '../src/muxer.js';
+import type { Config } from '../src/config.js';
+import type { YamuxMuxerInit } from '../src/muxer.js';
+import type { Source, Transform } from 'it-stream-types';
+export declare const testConf: Partial<Config>;
+/**
+ * Yamux must be configured with a client setting `client` to true
+ * and a server setting `client` to falsey
+ *
+ * Since the compliance tests create a dialer and listener,
+ * manually alternate setting `client` to true and false
+ */
+export declare class TestYamux extends Yamux {
+    createStreamMuxer(init?: YamuxMuxerInit): YamuxMuxer;
+}
+export declare function testYamuxMuxer(name: string, client: boolean, conf?: YamuxMuxerInit): YamuxMuxer;
+/**
+ * Create a transform that can be paused and unpaused
+ */
+export declare function pauseableTransform<A>(): {
+    transform: Transform<Source<A>, AsyncGenerator<A>>;
+    pause(): void;
+    unpause(): void;
+};
+export interface YamuxFixture extends YamuxMuxer {
+    pauseRead(): void;
+    unpauseRead(): void;
+    pauseWrite(): void;
+    unpauseWrite(): void;
+}
+export declare function testClientServer(conf?: YamuxMuxerInit): {
+    client: YamuxFixture;
+    server: YamuxFixture;
+};
+export declare function timeout(ms: number): Promise<unknown>;
+export declare function sleep(ms: number): Promise<unknown>;
+//# sourceMappingURL=util.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/util.d.ts.map b/node_modules/@chainsafe/libp2p-yamux/dist/test/util.d.ts.map
new file mode 100644
index 0000000..0f0bdfe
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/util.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"util.d.ts","sourceRoot":"","sources":["../../test/util.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,KAAK,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAA;AACnD,OAAO,KAAK,EAAE,MAAM,EAAE,MAAM,kBAAkB,CAAA;AAC9C,OAAO,KAAK,EAAE,cAAc,EAAE,MAAM,iBAAiB,CAAA;AACrD,OAAO,KAAK,EAAE,MAAM,EAAE,SAAS,EAAE,MAAM,iBAAiB,CAAA;AAYxD,eAAO,MAAM,QAAQ,EAAE,OAAO,CAAC,MAAM,CAEpC,CAAA;AAED;;;;;;GAMG;AACH,qBAAa,SAAU,SAAQ,KAAK;IAClC,iBAAiB,CAAE,IAAI,CAAC,EAAE,cAAc,GAAG,UAAU;CAItD;AAED,wBAAgB,cAAc,CAAE,IAAI,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,GAAE,cAAmB,GAAG,UAAU,CAQpG;AAED;;GAEG;AACH,wBAAgB,kBAAkB,CAAE,CAAC,KAAM;IAAE,SAAS,EAAE,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;IAAC,KAAK,IAAI,IAAI,CAAC;IAAC,OAAO,IAAI,IAAI,CAAA;CAAE,CAsBhI;AAED,MAAM,WAAW,YAAa,SAAQ,UAAU;IAC9C,SAAS,IAAI,IAAI,CAAA;IACjB,WAAW,IAAI,IAAI,CAAA;IACnB,UAAU,IAAI,IAAI,CAAA;IAClB,YAAY,IAAI,IAAI,CAAA;CACrB;AAED,wBAAgB,gBAAgB,CAAE,IAAI,GAAE,cAAmB,GAAG;IAC5D,MAAM,EAAE,YAAY,CAAA;IACpB,MAAM,EAAE,YAAY,CAAA;CACrB,CA0BA;AAED,wBAAsB,OAAO,CAAE,EAAE,EAAE,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,CAE3D;AAED,wBAAsB,KAAK,CAAE,EAAE,EAAE,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,CAEzD"}
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/util.js b/node_modules/@chainsafe/libp2p-yamux/dist/test/util.js
new file mode 100644
index 0000000..b8ff578
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/util.js
@@ -0,0 +1,95 @@
+import { prefixLogger } from '@libp2p/logger';
+import { duplexPair } from 'it-pair/duplex';
+import { pipe } from 'it-pipe';
+import { Yamux, YamuxMuxer } from '../src/muxer.js';
+const isClient = (() => {
+    let client = false;
+    return () => {
+        const isClient = !client;
+        client = isClient;
+        return isClient;
+    };
+})();
+export const testConf = {
+    enableKeepAlive: false
+};
+/**
+ * Yamux must be configured with a client setting `client` to true
+ * and a server setting `client` to falsey
+ *
+ * Since the compliance tests create a dialer and listener,
+ * manually alternate setting `client` to true and false
+ */
+export class TestYamux extends Yamux {
+    createStreamMuxer(init) {
+        const client = isClient();
+        return super.createStreamMuxer({ ...testConf, ...init, direction: client ? 'outbound' : 'inbound' });
+    }
+}
+export function testYamuxMuxer(name, client, conf = {}) {
+    return new YamuxMuxer({
+        logger: prefixLogger(name)
+    }, {
+        ...testConf,
+        ...conf,
+        direction: client ? 'outbound' : 'inbound'
+    });
+}
+/**
+ * Create a transform that can be paused and unpaused
+ */
+export function pauseableTransform() {
+    let resolvePausePromise;
+    let pausePromise;
+    const unpause = () => {
+        resolvePausePromise?.(null);
+    };
+    const pause = () => {
+        pausePromise = new Promise(resolve => {
+            resolvePausePromise = resolve;
+        });
+    };
+    const transform = async function* (source) {
+        for await (const d of source) {
+            if (pausePromise !== undefined) {
+                await pausePromise;
+                pausePromise = undefined;
+                resolvePausePromise = undefined;
+            }
+            yield d;
+        }
+    };
+    return { transform, pause, unpause };
+}
+export function testClientServer(conf = {}) {
+    const pair = duplexPair();
+    const client = testYamuxMuxer('client', true, conf);
+    const server = testYamuxMuxer('server', false, conf);
+    const clientReadTransform = pauseableTransform();
+    const clientWriteTransform = pauseableTransform();
+    const serverReadTransform = pauseableTransform();
+    const serverWriteTransform = pauseableTransform();
+    void pipe(pair[0], clientReadTransform.transform, client, clientWriteTransform.transform, pair[0]);
+    void pipe(pair[1], serverReadTransform.transform, server, serverWriteTransform.transform, pair[1]);
+    return {
+        client: Object.assign(client, {
+            pauseRead: clientReadTransform.pause,
+            unpauseRead: clientReadTransform.unpause,
+            pauseWrite: clientWriteTransform.pause,
+            unpauseWrite: clientWriteTransform.unpause
+        }),
+        server: Object.assign(server, {
+            pauseRead: serverReadTransform.pause,
+            unpauseRead: serverReadTransform.unpause,
+            pauseWrite: serverWriteTransform.pause,
+            unpauseWrite: serverWriteTransform.unpause
+        })
+    };
+}
+export async function timeout(ms) {
+    return new Promise((_resolve, reject) => setTimeout(() => { reject(new Error(`timeout after ${ms}ms`)); }, ms));
+}
+export async function sleep(ms) {
+    return new Promise(resolve => setTimeout(() => { resolve(ms); }, ms));
+}
+//# sourceMappingURL=util.js.map
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/test/util.js.map b/node_modules/@chainsafe/libp2p-yamux/dist/test/util.js.map
new file mode 100644
index 0000000..3698906
--- /dev/null
+++ b/node_modules/@chainsafe/libp2p-yamux/dist/test/util.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"util.js","sourceRoot":"","sources":["../../test/util.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/dist/typedoc-urls.json b/node_modules/@chainsafe/libp2p-yamux/dist/typedoc-urls.json
deleted file mode 100644
index 21b4891..0000000
--- a/node_modules/@chainsafe/libp2p-yamux/dist/typedoc-urls.json
+++ /dev/null
@@ -1,22 +0,0 @@
-{
-  "Config": "https://ChainSafe.github.io/js-libp2p-yamux/interfaces/config.Config.html",
-  "./config:Config": "https://ChainSafe.github.io/js-libp2p-yamux/interfaces/config.Config.html",
-  "defaultConfig": "https://ChainSafe.github.io/js-libp2p-yamux/variables/config.defaultConfig.html",
-  "./config:defaultConfig": "https://ChainSafe.github.io/js-libp2p-yamux/variables/config.defaultConfig.html",
-  "verifyConfig": "https://ChainSafe.github.io/js-libp2p-yamux/functions/config.verifyConfig.html",
-  "./config:verifyConfig": "https://ChainSafe.github.io/js-libp2p-yamux/functions/config.verifyConfig.html",
-  "FrameType": "https://ChainSafe.github.io/js-libp2p-yamux/enums/index.FrameType.html",
-  "GoAwayCode": "https://ChainSafe.github.io/js-libp2p-yamux/enums/index.GoAwayCode.html",
-  "FrameHeader": "https://ChainSafe.github.io/js-libp2p-yamux/interfaces/index.FrameHeader.html",
-  "YamuxMuxerComponents": "https://ChainSafe.github.io/js-libp2p-yamux/interfaces/index.YamuxMuxerComponents.html",
-  ".:YamuxMuxerComponents": "https://ChainSafe.github.io/js-libp2p-yamux/interfaces/index.YamuxMuxerComponents.html",
-  "YamuxMuxerInit": "https://ChainSafe.github.io/js-libp2p-yamux/interfaces/index.YamuxMuxerInit.html",
-  "yamux": "https://ChainSafe.github.io/js-libp2p-yamux/functions/index.yamux.html",
-  ".:yamux": "https://ChainSafe.github.io/js-libp2p-yamux/functions/index.yamux.html",
-  "StreamState": "https://ChainSafe.github.io/js-libp2p-yamux/enums/stream.StreamState.html",
-  "./stream:StreamState": "https://ChainSafe.github.io/js-libp2p-yamux/enums/stream.StreamState.html",
-  "YamuxStream": "https://ChainSafe.github.io/js-libp2p-yamux/classes/stream.YamuxStream.html",
-  "./stream:YamuxStream": "https://ChainSafe.github.io/js-libp2p-yamux/classes/stream.YamuxStream.html",
-  "YamuxStreamInit": "https://ChainSafe.github.io/js-libp2p-yamux/interfaces/stream.YamuxStreamInit.html",
-  "./stream:YamuxStreamInit": "https://ChainSafe.github.io/js-libp2p-yamux/interfaces/stream.YamuxStreamInit.html"
-}
\ No newline at end of file
diff --git a/node_modules/@chainsafe/libp2p-yamux/src/muxer.ts b/node_modules/@chainsafe/libp2p-yamux/src/muxer.ts
index fb941dd..964ed3f 100644
--- a/node_modules/@chainsafe/libp2p-yamux/src/muxer.ts
+++ b/node_modules/@chainsafe/libp2p-yamux/src/muxer.ts
@@ -1,6 +1,7 @@
 import { InvalidParametersError, MuxerClosedError, TooManyOutboundProtocolStreamsError, serviceCapabilities, setMaxListeners } from '@libp2p/interface'
 import { getIterator } from 'get-iterator'
 import { pushable } from 'it-pushable'
+import { raceSignal } from 'race-signal'
 import { Uint8ArrayList } from 'uint8arraylist'
 import { defaultConfig, verifyConfig } from './config.js'
 import { PROTOCOL_ERRORS } from './constants.js'
@@ -395,17 +396,16 @@ export class YamuxMuxer implements StreamMuxer {
   }

   private async keepAliveLoop (): Promise<void> {
-    const abortPromise = new Promise((_resolve, reject) => { this.closeController.signal.addEventListener('abort', reject, { once: true }) })
     this.log?.trace('muxer keepalive enabled interval=%s', this.config.keepAliveInterval)
     while (true) {
       let timeoutId
       try {
-        await Promise.race([
-          abortPromise,
+        await raceSignal(
           new Promise((resolve) => {
             timeoutId = setTimeout(resolve, this.config.keepAliveInterval)
-          })
-        ])
+          }),
+          this.closeController.signal
+        )
         this.ping().catch(e => this.log?.error('ping error: %s', e))
       } catch (e) {
         // closed
